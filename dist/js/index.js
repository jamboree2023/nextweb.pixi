(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/pixi-v8/lib/maths/point/Point.mjs
  var Point, tempPoint;
  var init_Point = __esm({
    "node_modules/pixi-v8/lib/maths/point/Point.mjs"() {
      Point = class {
        constructor(x2 = 0, y2 = 0) {
          this.x = 0;
          this.y = 0;
          this.x = x2;
          this.y = y2;
        }
        clone() {
          return new Point(this.x, this.y);
        }
        copyFrom(p2) {
          this.set(p2.x, p2.y);
          return this;
        }
        copyTo(p2) {
          p2.set(this.x, this.y);
          return p2;
        }
        equals(p2) {
          return p2.x === this.x && p2.y === this.y;
        }
        set(x2 = 0, y2 = x2) {
          this.x = x2;
          this.y = y2;
          return this;
        }
        toString() {
          return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
        }
        static get shared() {
          tempPoint.x = 0;
          tempPoint.y = 0;
          return tempPoint;
        }
      };
      tempPoint = new Point();
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedEvent.mjs
  var FederatedEvent;
  var init_FederatedEvent = __esm({
    "node_modules/pixi-v8/lib/events/FederatedEvent.mjs"() {
      init_Point();
      FederatedEvent = class {
        constructor(manager) {
          this.bubbles = true;
          this.cancelBubble = true;
          this.cancelable = false;
          this.composed = false;
          this.defaultPrevented = false;
          this.eventPhase = FederatedEvent.prototype.NONE;
          this.propagationStopped = false;
          this.propagationImmediatelyStopped = false;
          this.layer = new Point();
          this.page = new Point();
          this.NONE = 0;
          this.CAPTURING_PHASE = 1;
          this.AT_TARGET = 2;
          this.BUBBLING_PHASE = 3;
          this.manager = manager;
        }
        get layerX() {
          return this.layer.x;
        }
        get layerY() {
          return this.layer.y;
        }
        get pageX() {
          return this.page.x;
        }
        get pageY() {
          return this.page.y;
        }
        get data() {
          return this;
        }
        composedPath() {
          if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
        }
        initEvent(_type, _bubbles, _cancelable) {
          throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
          throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        preventDefault() {
          if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
            this.nativeEvent.preventDefault();
          }
          this.defaultPrevented = true;
        }
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = true;
        }
        stopPropagation() {
          this.propagationStopped = true;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/extensions/Extensions.mjs
  var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
  var init_Extensions = __esm({
    "node_modules/pixi-v8/lib/extensions/Extensions.mjs"() {
      ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
        ExtensionType2["Renderer"] = "renderer";
        ExtensionType2["Application"] = "application";
        ExtensionType2["WebGLPipes"] = "webgl-pipes";
        ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
        ExtensionType2["WebGLSystem"] = "webgl-system";
        ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
        ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
        ExtensionType2["WebGPUSystem"] = "webgpu-system";
        ExtensionType2["CanvasSystem"] = "canvas-system";
        ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
        ExtensionType2["CanvasPipes"] = "canvas-pipes";
        ExtensionType2["Asset"] = "asset";
        ExtensionType2["LoadParser"] = "load-parser";
        ExtensionType2["ResolveParser"] = "resolve-parser";
        ExtensionType2["CacheParser"] = "cache-parser";
        ExtensionType2["DetectionParser"] = "detection-parser";
        ExtensionType2["MaskEffect"] = "mask-effect";
        return ExtensionType2;
      })(ExtensionType || {});
      normalizeExtension = (ext) => {
        if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
          if (!ext.extension) {
            throw new Error("Extension class must have an extension object");
          }
          const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
          ext = { ...metadata, ref: ext };
        }
        if (typeof ext === "object") {
          ext = { ...ext };
        } else {
          throw new Error("Invalid extension type");
        }
        if (typeof ext.type === "string") {
          ext.type = [ext.type];
        }
        return ext;
      };
      normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
      extensions = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
          });
          return this;
        },
        add(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => {
              const handlers = this._addHandlers;
              const queue = this._queue;
              if (!handlers[type]) {
                queue[type] = queue[type] || [];
                queue[type].push(ext);
              } else {
                handlers[type](ext);
              }
            });
          });
          return this;
        },
        handle(type, onAdd, onRemove) {
          const addHandlers = this._addHandlers;
          const removeHandlers = this._removeHandlers;
          if (addHandlers[type] || removeHandlers[type]) {
            throw new Error(`Extension type ${type} already has a handler`);
          }
          addHandlers[type] = onAdd;
          removeHandlers[type] = onRemove;
          const queue = this._queue;
          if (queue[type]) {
            queue[type].forEach((ext) => onAdd(ext));
            delete queue[type];
          }
          return this;
        },
        handleByMap(type, map2) {
          return this.handle(
            type,
            (extension) => {
              map2[extension.name] = extension.ref;
            },
            (extension) => {
              delete map2[extension.name];
            }
          );
        },
        handleByNamedList(type, map2, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              const index = map2.findIndex((item) => item.name === extension.name);
              if (index >= 0)
                return;
              map2.push({ name: extension.name, value: extension.ref });
              map2.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
            },
            (extension) => {
              const index = map2.findIndex((item) => item.name === extension.name);
              if (index !== -1) {
                map2.splice(index, 1);
              }
            }
          );
        },
        handleByList(type, list, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              if (list.includes(extension.ref)) {
                return;
              }
              list.push(extension.ref);
              list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
            },
            (extension) => {
              const index = list.indexOf(extension.ref);
              if (index !== -1) {
                list.splice(index, 1);
              }
            }
          );
        }
      };
    }
  });

  // node_modules/pixi-v8/node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/pixi-v8/node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context2, once) {
        this.fn = fn;
        this.context = context2;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context2, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once)
              this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context2) {
        return addListener(this, event, fn, context2, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context2) {
        return addListener(this, event, fn, context2, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
              events.push(listeners[i2]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/pixi-v8/node_modules/eventemitter3/index.mjs
  var import_index, eventemitter3_default;
  var init_eventemitter3 = __esm({
    "node_modules/pixi-v8/node_modules/eventemitter3/index.mjs"() {
      import_index = __toESM(require_eventemitter3(), 1);
      eventemitter3_default = import_index.default;
    }
  });

  // node_modules/@pixi/colord/index.mjs
  var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
  var init_colord = __esm({
    "node_modules/@pixi/colord/index.mjs"() {
      r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
      t = function(r2) {
        return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
      };
      n = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
      };
      e = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
      };
      u = function(r2) {
        return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
      };
      a = function(r2) {
        return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
      };
      o = function(r2) {
        return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
      };
      i = /^#([0-9a-f]{3,8})$/i;
      s = function(r2) {
        var t2 = r2.toString(16);
        return t2.length < 2 ? "0" + t2 : t2;
      };
      h = function(r2) {
        var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
        return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
      };
      b = function(r2) {
        var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
        t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
        var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
        return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
      };
      g = function(r2) {
        return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
      };
      d = function(r2) {
        return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
      };
      f = function(r2) {
        return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
        var t2, n2, e2;
      };
      c = function(r2) {
        return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
        var t2, n2, e2, u2;
      };
      l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      y = { string: [[function(r2) {
        var t2 = i.exec(r2);
        return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
      }, "hex"], [function(r2) {
        var t2 = v.exec(r2) || m.exec(r2);
        return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
      }, "rgb"], [function(t2) {
        var n2 = l.exec(t2) || p.exec(t2);
        if (!n2)
          return null;
        var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
        return f(a2);
      }, "hsl"]], object: [[function(r2) {
        var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
        return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
      }, "rgb"], [function(r2) {
        var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
        if (!t(n2) || !t(e2) || !t(u2))
          return null;
        var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
        return f(i2);
      }, "hsl"], [function(r2) {
        var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
        if (!t(n2) || !t(a2) || !t(o2))
          return null;
        var h2 = function(r3) {
          return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
        }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
        return b(h2);
      }, "hsv"]] };
      N = function(r2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var e2 = t2[n2][0](r2);
          if (e2)
            return [e2, t2[n2][1]];
        }
        return [null, void 0];
      };
      x = function(r2) {
        return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
      };
      M = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
      };
      H = function(r2) {
        return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
      };
      $ = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
      };
      j = function() {
        function r2(r3) {
          this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
        }
        return r2.prototype.isValid = function() {
          return null !== this.parsed;
        }, r2.prototype.brightness = function() {
          return n(H(this.rgba), 2);
        }, r2.prototype.isDark = function() {
          return H(this.rgba) < 0.5;
        }, r2.prototype.isLight = function() {
          return H(this.rgba) >= 0.5;
        }, r2.prototype.toHex = function() {
          return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
          var r3, t2, e2, u2, a2, i2;
        }, r2.prototype.toRgb = function() {
          return o(this.rgba);
        }, r2.prototype.toRgbString = function() {
          return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsl = function() {
          return d(c(this.rgba));
        }, r2.prototype.toHslString = function() {
          return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsv = function() {
          return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
          var r3;
        }, r2.prototype.invert = function() {
          return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
          var r3;
        }, r2.prototype.saturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
        }, r2.prototype.desaturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
        }, r2.prototype.grayscale = function() {
          return w(M(this.rgba, -1));
        }, r2.prototype.lighten = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
        }, r2.prototype.darken = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
        }, r2.prototype.rotate = function(r3) {
          return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
        }, r2.prototype.alpha = function(r3) {
          return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
          var t2;
        }, r2.prototype.hue = function(r3) {
          var t2 = c(this.rgba);
          return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
        }, r2.prototype.isEqual = function(r3) {
          return this.toHex() === w(r3).toHex();
        }, r2;
      }();
      w = function(r2) {
        return r2 instanceof j ? r2 : new j(r2);
      };
      S = [];
      k = function(r2) {
        r2.forEach(function(r3) {
          S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
        });
      };
    }
  });

  // node_modules/@pixi/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
    for (var d2 in a2)
      r2[a2[d2]] = d2;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var d3, i2, n2 = r2[this.toHex()];
      if (n2)
        return n2;
      if (null == f3 ? void 0 : f3.closest) {
        var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
        if (!l2.length)
          for (var c2 in a2)
            l2[c2] = new e2(a2[c2]).toRgb();
        for (var g2 in a2) {
          var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
          u2 < t2 && (t2 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
      return d3 ? new e2(d3).toRgb() : null;
    }, "name"]);
  }
  var init_names = __esm({
    "node_modules/@pixi/colord/plugins/names.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/color/Color.mjs
  var _Color, Color;
  var init_Color = __esm({
    "node_modules/pixi-v8/lib/color/Color.mjs"() {
      init_colord();
      init_names();
      k([names_default]);
      _Color = class {
        constructor(value = 16777215) {
          this._value = null;
          this._components = new Float32Array(4);
          this._components.fill(1);
          this._int = 16777215;
          this.value = value;
        }
        get red() {
          return this._components[0];
        }
        get green() {
          return this._components[1];
        }
        get blue() {
          return this._components[2];
        }
        get alpha() {
          return this._components[3];
        }
        setValue(value) {
          this.value = value;
          return this;
        }
        set value(value) {
          if (value instanceof _Color) {
            this._value = this._cloneSource(value._value);
            this._int = value._int;
            this._components.set(value._components);
          } else if (value === null) {
            throw new Error("Cannot set Color#value to null");
          } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
            this._normalize(value);
            this._value = this._cloneSource(value);
          }
        }
        get value() {
          return this._value;
        }
        _cloneSource(value) {
          if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
            return value;
          } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
            return value.slice(0);
          } else if (typeof value === "object" && value !== null) {
            return { ...value };
          }
          return value;
        }
        _isSourceEqual(value1, value2) {
          const type1 = typeof value1;
          const type2 = typeof value2;
          if (type1 !== type2) {
            return false;
          } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
            return value1 === value2;
          } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
            if (value1.length !== value2.length) {
              return false;
            }
            return value1.every((v2, i2) => v2 === value2[i2]);
          } else if (value1 !== null && value2 !== null) {
            const keys1 = Object.keys(value1);
            const keys2 = Object.keys(value2);
            if (keys1.length !== keys2.length) {
              return false;
            }
            return keys1.every((key) => value1[key] === value2[key]);
          }
          return value1 === value2;
        }
        toRgba() {
          const [r2, g2, b2, a2] = this._components;
          return { r: r2, g: g2, b: b2, a: a2 };
        }
        toRgb() {
          const [r2, g2, b2] = this._components;
          return { r: r2, g: g2, b: b2 };
        }
        toRgbaString() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return `rgba(${r2},${g2},${b2},${this.alpha})`;
        }
        toUint8RgbArray(out2) {
          const [r2, g2, b2] = this._components;
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          out2[0] = Math.round(r2 * 255);
          out2[1] = Math.round(g2 * 255);
          out2[2] = Math.round(b2 * 255);
          return out2;
        }
        toArray(out2) {
          if (!this._arrayRgba) {
            this._arrayRgba = [];
          }
          out2 = out2 || this._arrayRgba;
          const [r2, g2, b2, a2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          out2[3] = a2;
          return out2;
        }
        toRgbArray(out2) {
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          const [r2, g2, b2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          return out2;
        }
        toNumber() {
          return this._int;
        }
        toBgrNumber() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return (b2 << 16) + (g2 << 8) + r2;
        }
        toLittleEndianNumber() {
          const value = this._int;
          return (value >> 16) + (value & 65280) + ((value & 255) << 16);
        }
        multiply(value) {
          const [r2, g2, b2, a2] = _Color._temp.setValue(value)._components;
          this._components[0] *= r2;
          this._components[1] *= g2;
          this._components[2] *= b2;
          this._components[3] *= a2;
          this._refreshInt();
          this._value = null;
          return this;
        }
        premultiply(alpha, applyToRGB = true) {
          if (applyToRGB) {
            this._components[0] *= alpha;
            this._components[1] *= alpha;
            this._components[2] *= alpha;
          }
          this._components[3] = alpha;
          this._refreshInt();
          this._value = null;
          return this;
        }
        toPremultiplied(alpha, applyToRGB = true) {
          if (alpha === 1) {
            return (255 << 24) + this._int;
          }
          if (alpha === 0) {
            return applyToRGB ? 0 : this._int;
          }
          let r2 = this._int >> 16 & 255;
          let g2 = this._int >> 8 & 255;
          let b2 = this._int & 255;
          if (applyToRGB) {
            r2 = r2 * alpha + 0.5 | 0;
            g2 = g2 * alpha + 0.5 | 0;
            b2 = b2 * alpha + 0.5 | 0;
          }
          return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
        }
        toHex() {
          const hexString = this._int.toString(16);
          return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
        }
        toHexa() {
          const alphaValue = Math.round(this._components[3] * 255);
          const alphaString = alphaValue.toString(16);
          return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
        }
        setAlpha(alpha) {
          this._components[3] = this._clamp(alpha);
          return this;
        }
        _normalize(value) {
          let r2;
          let g2;
          let b2;
          let a2;
          if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
            const int = value;
            r2 = (int >> 16 & 255) / 255;
            g2 = (int >> 8 & 255) / 255;
            b2 = (int & 255) / 255;
            a2 = 1;
          } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value);
            [r2, g2, b2, a2 = 1] = value;
          } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value, 0, 255);
            [r2, g2, b2, a2 = 255] = value;
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
            a2 /= 255;
          } else if (typeof value === "string" || typeof value === "object") {
            if (typeof value === "string") {
              const match = _Color.HEX_PATTERN.exec(value);
              if (match) {
                value = `#${match[2]}`;
              }
            }
            const color = w(value);
            if (color.isValid()) {
              ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
              r2 /= 255;
              g2 /= 255;
              b2 /= 255;
            }
          }
          if (r2 !== void 0) {
            this._components[0] = r2;
            this._components[1] = g2;
            this._components[2] = b2;
            this._components[3] = a2;
            this._refreshInt();
          } else {
            throw new Error(`Unable to convert color ${value}`);
          }
        }
        _refreshInt() {
          this._clamp(this._components);
          const [r2, g2, b2] = this._components;
          this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
        }
        _clamp(value, min = 0, max = 1) {
          if (typeof value === "number") {
            return Math.min(Math.max(value, min), max);
          }
          value.forEach((v2, i2) => {
            value[i2] = Math.min(Math.max(v2, min), max);
          });
          return value;
        }
        static isColorLike(value) {
          return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
        }
      };
      Color = _Color;
      Color.shared = new _Color();
      Color._temp = new _Color();
      Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    }
  });

  // node_modules/pixi-v8/lib/maths/misc/const.mjs
  var PI_2, RAD_TO_DEG, DEG_TO_RAD;
  var init_const = __esm({
    "node_modules/pixi-v8/lib/maths/misc/const.mjs"() {
      PI_2 = Math.PI * 2;
      RAD_TO_DEG = 180 / Math.PI;
      DEG_TO_RAD = Math.PI / 180;
    }
  });

  // node_modules/pixi-v8/lib/maths/matrix/Matrix.mjs
  var Matrix, tempMatrix, identityMatrix;
  var init_Matrix = __esm({
    "node_modules/pixi-v8/lib/maths/matrix/Matrix.mjs"() {
      init_const();
      init_Point();
      Matrix = class {
        constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
          this.array = null;
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
        }
        fromArray(array) {
          this.a = array[0];
          this.b = array[1];
          this.c = array[3];
          this.d = array[4];
          this.tx = array[2];
          this.ty = array[5];
        }
        set(a2, b2, c2, d2, tx, ty) {
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
          return this;
        }
        toArray(transpose, out2) {
          if (!this.array) {
            this.array = new Float32Array(9);
          }
          const array = out2 || this.array;
          if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
          } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
          }
          return array;
        }
        apply(pos, newPos) {
          newPos = newPos || new Point();
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = this.a * x2 + this.c * y2 + this.tx;
          newPos.y = this.b * x2 + this.d * y2 + this.ty;
          return newPos;
        }
        applyInverse(pos, newPos) {
          newPos = newPos || new Point();
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const tx = this.tx;
          const ty = this.ty;
          const id = 1 / (a2 * d2 + c2 * -b2);
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
          newPos.y = a2 * id * y2 + -b2 * id * x2 + (-ty * a2 + tx * b2) * id;
          return newPos;
        }
        translate(x2, y2) {
          this.tx += x2;
          this.ty += y2;
          return this;
        }
        scale(x2, y2) {
          this.a *= x2;
          this.d *= y2;
          this.c *= x2;
          this.b *= y2;
          this.tx *= x2;
          this.ty *= y2;
          return this;
        }
        rotate(angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const a1 = this.a;
          const c1 = this.c;
          const tx1 = this.tx;
          this.a = a1 * cos - this.b * sin;
          this.b = a1 * sin + this.b * cos;
          this.c = c1 * cos - this.d * sin;
          this.d = c1 * sin + this.d * cos;
          this.tx = tx1 * cos - this.ty * sin;
          this.ty = tx1 * sin + this.ty * cos;
          return this;
        }
        append(matrix) {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          this.a = matrix.a * a1 + matrix.b * c1;
          this.b = matrix.a * b1 + matrix.b * d1;
          this.c = matrix.c * a1 + matrix.d * c1;
          this.d = matrix.c * b1 + matrix.d * d1;
          this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
          this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
          return this;
        }
        appendFrom(a2, b2) {
          const a1 = a2.a;
          const b1 = a2.b;
          const c1 = a2.c;
          const d1 = a2.d;
          const tx = a2.tx;
          const ty = a2.ty;
          const a22 = b2.a;
          const b22 = b2.b;
          const c2 = b2.c;
          const d2 = b2.d;
          this.a = a1 * a22 + b1 * c2;
          this.b = a1 * b22 + b1 * d2;
          this.c = c1 * a22 + d1 * c2;
          this.d = c1 * b22 + d1 * d2;
          this.tx = tx * a22 + ty * c2 + b2.tx;
          this.ty = tx * b22 + ty * d2 + b2.ty;
          return this;
        }
        setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
          this.a = Math.cos(rotation + skewY) * scaleX;
          this.b = Math.sin(rotation + skewY) * scaleX;
          this.c = -Math.sin(rotation - skewX) * scaleY;
          this.d = Math.cos(rotation - skewX) * scaleY;
          this.tx = x2 - (pivotX * this.a + pivotY * this.c);
          this.ty = y2 - (pivotX * this.b + pivotY * this.d);
          return this;
        }
        prepend(matrix) {
          const tx1 = this.tx;
          if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
          }
          this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
          this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
          return this;
        }
        decompose(transform) {
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const pivot = transform.pivot;
          const skewX = -Math.atan2(-c2, d2);
          const skewY = Math.atan2(b2, a2);
          const delta = Math.abs(skewX + skewY);
          if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
            transform.rotation = skewY;
            transform.skew.x = transform.skew.y = 0;
          } else {
            transform.rotation = 0;
            transform.skew.x = skewX;
            transform.skew.y = skewY;
          }
          transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
          transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
          transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
          transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
          return transform;
        }
        invert() {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          const tx1 = this.tx;
          const n2 = a1 * d1 - b1 * c1;
          this.a = d1 / n2;
          this.b = -b1 / n2;
          this.c = -c1 / n2;
          this.d = a1 / n2;
          this.tx = (c1 * this.ty - d1 * tx1) / n2;
          this.ty = -(a1 * this.ty - b1 * tx1) / n2;
          return this;
        }
        isIdentity() {
          return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        identity() {
          this.a = 1;
          this.b = 0;
          this.c = 0;
          this.d = 1;
          this.tx = 0;
          this.ty = 0;
          return this;
        }
        clone() {
          const matrix = new Matrix();
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        copyTo(matrix) {
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        copyFrom(matrix) {
          this.a = matrix.a;
          this.b = matrix.b;
          this.c = matrix.c;
          this.d = matrix.d;
          this.tx = matrix.tx;
          this.ty = matrix.ty;
          return this;
        }
        toString() {
          return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        static get IDENTITY() {
          return identityMatrix.identity();
        }
        static get shared() {
          return tempMatrix.identity();
        }
      };
      tempMatrix = new Matrix();
      identityMatrix = new Matrix();
    }
  });

  // node_modules/pixi-v8/lib/maths/point/ObservablePoint.mjs
  var ObservablePoint;
  var init_ObservablePoint = __esm({
    "node_modules/pixi-v8/lib/maths/point/ObservablePoint.mjs"() {
      ObservablePoint = class {
        constructor(observer, x2, y2) {
          this._x = x2 || 0;
          this._y = y2 || 0;
          this._observer = observer;
        }
        clone(observer) {
          return new ObservablePoint(observer ?? this._observer, this._x, this._y);
        }
        set(x2 = 0, y2 = x2) {
          if (this._x !== x2 || this._y !== y2) {
            this._x = x2;
            this._y = y2;
            this._observer.onUpdate();
          }
          return this;
        }
        copyFrom(p2) {
          if (this._x !== p2.x || this._y !== p2.y) {
            this._x = p2.x;
            this._y = p2.y;
            this._observer.onUpdate();
          }
          return this;
        }
        copyTo(p2) {
          p2.set(this._x, this._y);
          return p2;
        }
        equals(p2) {
          return p2.x === this._x && p2.y === this._y;
        }
        toString() {
          return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          if (this._x !== value) {
            this._x = value;
            this._observer.onUpdate(this);
          }
        }
        get y() {
          return this._y;
        }
        set y(value) {
          if (this._y !== value) {
            this._y = value;
            this._observer.onUpdate(this);
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/data/uid.mjs
  function uid(name = "default") {
    if (uidCache[name] === void 0) {
      uidCache[name] = -1;
    }
    return ++uidCache[name];
  }
  var uidCache;
  var init_uid = __esm({
    "node_modules/pixi-v8/lib/utils/data/uid.mjs"() {
      uidCache = {
        default: -1
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/logging/deprecation.mjs
  function deprecation(version, message, ignoreDepth = 3) {
    if (warnings[message]) {
      return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed(
          "%cPixiJS Deprecation Warning: %c%s",
          "color:#614108;background:#fffbe6",
          "font-weight:normal;color:#614108;background:#fffbe6",
          `${message}
Deprecated since v${version}`
        );
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
        console.warn(stack);
      }
    }
    warnings[message] = true;
  }
  var warnings, v8_0_0;
  var init_deprecation = __esm({
    "node_modules/pixi-v8/lib/utils/logging/deprecation.mjs"() {
      warnings = {};
      v8_0_0 = "8.0.0";
    }
  });

  // node_modules/pixi-v8/lib/utils/data/removeItems.mjs
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i2;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i2 = startIdx; i2 < len; ++i2) {
      arr[i2] = arr[i2 + removeCount];
    }
    arr.length = len;
  }
  var init_removeItems = __esm({
    "node_modules/pixi-v8/lib/utils/data/removeItems.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/childrenHelperMixin.mjs
  var childrenHelperMixin;
  var init_childrenHelperMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
      init_removeItems();
      init_deprecation();
      childrenHelperMixin = {
        allowChildren: true,
        removeChildren(beginIndex = 0, endIndex) {
          const end = endIndex ?? this.children.length;
          const range = end - beginIndex;
          const removed = [];
          if (range > 0 && range <= end) {
            for (let i2 = end - 1; i2 >= beginIndex; i2--) {
              const child = this.children[i2];
              if (!child)
                continue;
              if (this.layerGroup) {
                this.layerGroup.removeChild(child);
              }
              removed.push(child);
              child.parent = null;
            }
            removeItems(this.children, beginIndex, end);
            for (let i2 = 0; i2 < removed.length; ++i2) {
              this.emit("childRemoved", removed[i2], this, i2);
              removed[i2].emit("removed", this);
            }
            return removed;
          } else if (range === 0 && this.children.length === 0) {
            return removed;
          }
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        removeChildAt(index) {
          const child = this.getChildAt(index);
          return this.removeChild(child);
        },
        getChildAt(index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`getChildAt: Index (${index}) does not exist.`);
          }
          return this.children[index];
        },
        setChildIndex(child, index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
          }
          this.getChildIndex(child);
          this.addChildAt(child, index);
        },
        getChildIndex(child) {
          const index = this.children.indexOf(child);
          if (index === -1) {
            throw new Error("The supplied Container must be a child of the caller");
          }
          return index;
        },
        addChildAt(child, index) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
          }
          const { children } = this;
          if (index < 0 || index > children.length) {
            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
          }
          if (child.parent) {
            const currentIndex = child.parent.children.indexOf(child);
            if (child.parent === this && currentIndex === index) {
              return child;
            }
            if (currentIndex !== -1) {
              child.parent.children.splice(currentIndex, 1);
            }
          }
          if (index === children.length) {
            children.push(child);
          } else {
            children.splice(index, 0, child);
          }
          child.parent = this;
          child.didChange = true;
          child.didViewUpdate = false;
          child._updateFlags = 15;
          if (this.layerGroup) {
            this.layerGroup.addChild(child);
          }
          if (this.sortableChildren)
            this.sortDirty = true;
          this.emit("childAdded", child, this, index);
          child.emit("added", this);
          return child;
        },
        swapChildren(child, child2) {
          if (child === child2) {
            return;
          }
          const index1 = this.getChildIndex(child);
          const index2 = this.getChildIndex(child2);
          this.children[index1] = child2;
          this.children[index2] = child;
        },
        removeFromParent() {
          this.parent?.removeChild(this);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/FilterEffect.mjs
  function getFilterEffect(filters) {
    const filterEffect = filterEffectsPool.pop() || new FilterEffect();
    filterEffect.filters = filters;
    return filterEffect;
  }
  function returnFilterEffect(effect) {
    effect.filters = null;
    filterEffectsPool.push(effect);
  }
  var FilterEffect, filterEffectsPool;
  var init_FilterEffect = __esm({
    "node_modules/pixi-v8/lib/filters/FilterEffect.mjs"() {
      FilterEffect = class {
        constructor(options) {
          this.pipe = "filter";
          this.priority = 1;
          this.filters = options?.filters;
        }
        destroy() {
          for (let i2 = 0; i2 < this.filters.length; i2++) {
            this.filters[i2].destroy();
          }
          this.filters = null;
        }
      };
      filterEffectsPool = [];
    }
  });

  // node_modules/pixi-v8/lib/utils/pool/Pool.mjs
  var Pool;
  var init_Pool = __esm({
    "node_modules/pixi-v8/lib/utils/pool/Pool.mjs"() {
      Pool = class {
        constructor(ClassType, initialSize) {
          this._pool = [];
          this._count = 0;
          this._index = 0;
          this._classType = ClassType;
          if (initialSize) {
            this.prepopulate(initialSize);
          }
        }
        prepopulate(total) {
          for (let i2 = 0; i2 < total; i2++) {
            this._pool[this._index++] = new this._classType();
          }
          this._count += total;
        }
        get(data) {
          let item;
          if (this._index > 0) {
            item = this._pool[--this._index];
          } else {
            item = new this._classType();
          }
          item.init?.(data);
          return item;
        }
        return(item) {
          item.reset?.();
          this._pool[this._index++] = item;
        }
        get totalSize() {
          return this._count;
        }
        get totalFree() {
          return this._pool.length;
        }
        get totalUsed() {
          return this._count - this._pool.length;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/pool/PoolGroup.mjs
  var PoolGroupClass, BigPool;
  var init_PoolGroup = __esm({
    "node_modules/pixi-v8/lib/utils/pool/PoolGroup.mjs"() {
      init_Pool();
      PoolGroupClass = class {
        constructor() {
          this._poolsByClass = /* @__PURE__ */ new Map();
        }
        prepopulate(Class, total) {
          const classPool = this.getPool(Class);
          classPool.prepopulate(total);
        }
        get(Class, data) {
          const pool = this.getPool(Class);
          return pool.get(data);
        }
        return(item) {
          const pool = this.getPool(item.constructor);
          pool.return(item);
        }
        getPool(ClassType) {
          if (!this._poolsByClass.has(ClassType)) {
            this._poolsByClass.set(ClassType, new Pool(ClassType));
          }
          return this._poolsByClass.get(ClassType);
        }
        stats() {
          const stats = {};
          this._poolsByClass.forEach((pool) => {
            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
            stats[name] = {
              free: pool.totalFree,
              used: pool.totalUsed,
              size: pool.totalSize
            };
          });
          return stats;
        }
      };
      BigPool = new PoolGroupClass();
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/MaskEffectManager.mjs
  var MaskEffectManagerClass, MaskEffectManager;
  var init_MaskEffectManager = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/MaskEffectManager.mjs"() {
      init_Extensions();
      init_PoolGroup();
      MaskEffectManagerClass = class {
        constructor() {
          this._effectClasses = [];
          this._tests = [];
          this._initialized = false;
        }
        init() {
          if (this._initialized)
            return;
          this._initialized = true;
          this._effectClasses.forEach((test) => {
            this.add({
              test: test.test,
              maskClass: test
            });
          });
        }
        add(test) {
          this._tests.push(test);
        }
        getMaskEffect(item) {
          if (!this._initialized)
            this.init();
          for (let i2 = 0; i2 < this._tests.length; i2++) {
            const test = this._tests[i2];
            if (test.test(item)) {
              return BigPool.get(test.maskClass, item);
            }
          }
          return item;
        }
        returnMaskEffect(effect) {
          BigPool.return(effect);
        }
      };
      MaskEffectManager = new MaskEffectManagerClass();
      extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/effectsMixin.mjs
  var effectsMixin;
  var init_effectsMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/effectsMixin.mjs"() {
      init_FilterEffect();
      init_MaskEffectManager();
      effectsMixin = {
        _mask: null,
        _filters: null,
        effects: [],
        addEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index !== -1)
            return;
          this.effects.push(effect);
          this.effects.sort((a2, b2) => a2.priority - b2.priority);
          if (!this.isLayerRoot && this.layerGroup) {
            this.layerGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        removeEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index === -1)
            return;
          this.effects.splice(index, 1);
          if (!this.isLayerRoot && this.layerGroup) {
            this.layerGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        set mask(value) {
          this._mask || (this._mask = { mask: null, effect: null });
          if (this._mask.mask === value)
            return;
          if (this._mask.effect) {
            this.removeEffect(this._mask.effect);
            MaskEffectManager.returnMaskEffect(this._mask.effect);
            this._mask.effect = null;
          }
          this._mask.mask = value;
          if (value === null || value === void 0)
            return;
          const effect = MaskEffectManager.getMaskEffect(value);
          this._mask.effect = effect;
          this.addEffect(effect);
        },
        get mask() {
          return this._mask?.mask;
        },
        set filters(value) {
          if (!Array.isArray(value) && value !== null)
            value = [value];
          this._filters || (this._filters = { filters: null, effect: null });
          if (this._filters.filters === value)
            return;
          if (this._filters.effect) {
            this.removeEffect(this._filters.effect);
            returnFilterEffect(this._filters.effect);
            this._filters.effect = null;
          }
          this._filters.filters = value;
          if (!value)
            return;
          const effect = getFilterEffect(value);
          this._filters.effect = effect;
          this.addEffect(effect);
        },
        get filters() {
          return this._filters?.filters;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/findMixin.mjs
  var findMixin;
  var init_findMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/findMixin.mjs"() {
      init_deprecation();
      findMixin = {
        label: null,
        get name() {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          return this.label;
        },
        set name(value) {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          this.label = value;
        },
        getChildByName(name, deep = false) {
          return this.getChildByLabel(name, deep);
        },
        getChildByLabel(label, deep = false) {
          const children = this.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.label === label || label instanceof RegExp && label.test(child.label))
              return child;
          }
          if (deep) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              const found = child.getChildByLabel(label, true);
              if (found) {
                return found;
              }
            }
          }
          return null;
        },
        getChildrenByLabel(label, deep = false, out2 = []) {
          const children = this.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.label === label || label instanceof RegExp && label.test(child.label)) {
              out2.push(child);
            }
          }
          if (deep) {
            for (let i2 = 0; i2 < children.length; i2++) {
              children[i2].getChildrenByLabel(label, true, out2);
            }
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/Rectangle.mjs
  var tempPoints, Rectangle;
  var init_Rectangle = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/Rectangle.mjs"() {
      init_Point();
      tempPoints = [new Point(), new Point(), new Point(), new Point()];
      Rectangle = class {
        constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
          this.type = "rectangle";
          this.x = Number(x2);
          this.y = Number(y2);
          this.width = Number(width);
          this.height = Number(height);
        }
        get left() {
          return this.x;
        }
        get right() {
          return this.x + this.width;
        }
        get top() {
          return this.y;
        }
        get bottom() {
          return this.y + this.height;
        }
        static get EMPTY() {
          return new Rectangle(0, 0, 0, 0);
        }
        clone() {
          return new Rectangle(this.x, this.y, this.width, this.height);
        }
        copyFromBounds(bounds) {
          this.x = bounds.minX;
          this.y = bounds.minY;
          this.width = bounds.maxX - bounds.minX;
          this.height = bounds.maxY - bounds.minY;
          return this;
        }
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 < this.x + this.width) {
            if (y2 >= this.y && y2 < this.y + this.height) {
              return true;
            }
          }
          return false;
        }
        intersects(other, transform) {
          if (!transform) {
            const x02 = this.x < other.x ? other.x : this.x;
            const x12 = this.right > other.right ? other.right : this.right;
            if (x12 <= x02) {
              return false;
            }
            const y02 = this.y < other.y ? other.y : this.y;
            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
            return y12 > y02;
          }
          const x0 = this.left;
          const x1 = this.right;
          const y0 = this.top;
          const y1 = this.bottom;
          if (x1 <= x0 || y1 <= y0) {
            return false;
          }
          const lt = tempPoints[0].set(other.left, other.top);
          const lb = tempPoints[1].set(other.left, other.bottom);
          const rt = tempPoints[2].set(other.right, other.top);
          const rb = tempPoints[3].set(other.right, other.bottom);
          if (rt.x <= lt.x || lb.y <= lt.y) {
            return false;
          }
          const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
          if (s2 === 0) {
            return false;
          }
          transform.apply(lt, lt);
          transform.apply(lb, lb);
          transform.apply(rt, rt);
          transform.apply(rb, rb);
          if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
            return false;
          }
          const nx = s2 * (lb.y - lt.y);
          const ny = s2 * (lt.x - lb.x);
          const n00 = nx * x0 + ny * y0;
          const n10 = nx * x1 + ny * y0;
          const n01 = nx * x0 + ny * y1;
          const n11 = nx * x1 + ny * y1;
          if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
            return false;
          }
          const mx = s2 * (lt.y - rt.y);
          const my = s2 * (rt.x - lt.x);
          const m00 = mx * x0 + my * y0;
          const m10 = mx * x1 + my * y0;
          const m01 = mx * x0 + my * y1;
          const m11 = mx * x1 + my * y1;
          if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
            return false;
          }
          return true;
        }
        pad(paddingX = 0, paddingY = paddingX) {
          this.x -= paddingX;
          this.y -= paddingY;
          this.width += paddingX * 2;
          this.height += paddingY * 2;
          return this;
        }
        fit(rectangle) {
          const x1 = Math.max(this.x, rectangle.x);
          const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.max(this.y, rectangle.y);
          const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = Math.max(x2 - x1, 0);
          this.y = y1;
          this.height = Math.max(y2 - y1, 0);
          return this;
        }
        ceil(resolution = 1, eps = 1e-3) {
          const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
          const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
          this.x = Math.floor((this.x + eps) * resolution) / resolution;
          this.y = Math.floor((this.y + eps) * resolution) / resolution;
          this.width = x2 - this.x;
          this.height = y2 - this.y;
          return this;
        }
        enlarge(rectangle) {
          const x1 = Math.min(this.x, rectangle.x);
          const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.min(this.y, rectangle.y);
          const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = x2 - x1;
          this.y = y1;
          this.height = y2 - y1;
          return this;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.copyFrom(this);
          return out2;
        }
        toString() {
          return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/Bounds.mjs
  var Bounds;
  var init_Bounds = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/Bounds.mjs"() {
      init_Matrix();
      init_Rectangle();
      Bounds = class {
        constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this._matrixStack = [];
          this.matrix = new Matrix();
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        get rectangle() {
          if (!this._rectangle) {
            this._rectangle = new Rectangle();
          }
          const rectangle = this._rectangle;
          if (this.minX > this.maxX || this.minY > this.maxY) {
            rectangle.x = 0;
            rectangle.y = 0;
            rectangle.width = 0;
            rectangle.height = 0;
          } else {
            rectangle.copyFromBounds(this);
          }
          return rectangle;
        }
        clear() {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this._matrixStack.length = 0;
          this.matrix.identity();
        }
        pushMatrix(matrix) {
          this._matrixStack.push(matrix);
          if (this._matrixStack.length > 1) {
            this.matrix.copyFrom(this._matrixStack[this._matrixStack.length - 2]);
            this.matrix.append(matrix);
          } else {
            this.matrix.copyFrom(matrix);
          }
        }
        popMatrix() {
          this._matrixStack.pop();
          if (this._matrixStack.length > 1) {
            this.matrix.copyFrom(this._matrixStack[this._matrixStack.length - 2]);
            this.matrix.append(this._matrixStack[this._matrixStack.length - 1]);
          } else if (this._matrixStack.length === 1) {
            this.matrix.copyFrom(this._matrixStack[0]);
          } else {
            this.matrix.identity();
          }
        }
        setMatrix(matrix) {
          this.matrix.copyFrom(matrix);
        }
        set(x0, y0, x1, y1) {
          this.minX = x0;
          this.minY = y0;
          this.maxX = x1;
          this.maxY = y1;
        }
        addFrame(x0, y0, x1, y1) {
          const matrix = this.matrix;
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          let x2 = a2 * x0 + c2 * y0 + tx;
          let y2 = b2 * x0 + d2 * y0 + ty;
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
          x2 = a2 * x1 + c2 * y0 + tx;
          y2 = b2 * x1 + d2 * y0 + ty;
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
          x2 = a2 * x0 + c2 * y1 + tx;
          y2 = b2 * x0 + d2 * y1 + ty;
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
          x2 = a2 * x1 + c2 * y1 + tx;
          y2 = b2 * x1 + d2 * y1 + ty;
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        addRect(rect) {
          this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height);
        }
        addBounds(bounds) {
          this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
        }
        addBoundsMask(mask) {
          this.minX = this.minX > mask.minX ? this.minX : mask.minX;
          this.minY = this.minY > mask.minY ? this.minY : mask.minY;
          this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
          this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
        }
        applyMatrix(matrix) {
          const minX = this.minX;
          const minY = this.minY;
          const maxX = this.maxX;
          const maxY = this.maxY;
          const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
          let x2 = a2 * minX + c2 * minY + tx;
          let y2 = b2 * minX + d2 * minY + ty;
          this.minX = x2;
          this.minY = y2;
          this.maxX = x2;
          this.maxY = y2;
          x2 = a2 * maxX + c2 * minY + tx;
          y2 = b2 * maxX + d2 * minY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * minX + c2 * maxY + tx;
          y2 = b2 * minX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * maxX + c2 * maxY + tx;
          y2 = b2 * maxX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
        }
        fit(rect) {
          if (this.minX < rect.left)
            this.minX = rect.left;
          if (this.maxX > rect.right)
            this.maxX = rect.right;
          if (this.minY < rect.top)
            this.minY = rect.top;
          if (this.maxY > rect.bottom)
            this.maxY = rect.bottom;
          return this;
        }
        pad(paddingX, paddingY = paddingX) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
          return this;
        }
        ceil() {
          this.minX = Math.floor(this.minX);
          this.minY = Math.floor(this.minY);
          this.maxX = Math.ceil(this.maxX);
          this.maxY = Math.ceil(this.maxY);
          return this;
        }
        clone() {
          return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
        }
        scale(x2, y2 = x2) {
          this.minX *= x2;
          this.minY *= y2;
          this.maxX *= x2;
          this.maxY *= y2;
          return this;
        }
        get x() {
          return this.minX;
        }
        get y() {
          return this.minY;
        }
        get width() {
          return this.maxX - this.minX;
        }
        get height() {
          return this.maxY - this.minY;
        }
        get isPositive() {
          return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        get isValid() {
          return this.minX + this.minY !== Infinity;
        }
        addVertexData(vertexData, beginOffset, endOffset) {
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          const matrix = this.matrix;
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
            const localX = vertexData[i2];
            const localY = vertexData[i2 + 1];
            const x2 = a2 * localX + c2 * localY + tx;
            const y2 = b2 * localX + d2 * localY + ty;
            minX = x2 < minX ? x2 : minX;
            minY = y2 < minY ? y2 : minY;
            maxX = x2 > maxX ? x2 : maxX;
            maxY = y2 > maxY ? y2 : maxY;
          }
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        toString() {
          return `[@pixi:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/updateLocalTransform.mjs
  function updateLocalTransform(lt, container) {
    const scale = container._scale;
    const pivot = container._pivot;
    const position = container._position;
    const sx = scale._x;
    const sy = scale._y;
    const px = pivot._x;
    const py = pivot._y;
    lt.a = container._cx * sx;
    lt.b = container._sx * sx;
    lt.c = container._cy * sy;
    lt.d = container._sy * sy;
    lt.tx = position._x - (px * lt.a + py * lt.c);
    lt.ty = position._y - (px * lt.b + py * lt.d);
  }
  var init_updateLocalTransform = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/updateLocalTransform.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/getGlobalBounds.mjs
  function getGlobalBounds(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    if (target.parent) {
      if (!skipUpdateTransform) {
        parentTransform = updateTransformBackwards(target, new Matrix());
      } else {
        parentTransform = target.parent.worldTransform;
      }
    } else {
      parentTransform = Matrix.IDENTITY;
    }
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    if (!target.visible || !target.measurable)
      return;
    let worldTransform;
    if (!skipUpdateTransform) {
      if (target.didChange) {
        updateLocalTransform(target.localTransform, target);
      }
      worldTransform = Matrix.shared.appendFrom(target.localTransform, parentTransform).clone();
    } else {
      worldTransform = target.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = bounds.clone();
    }
    if (target.view) {
      bounds.setMatrix(worldTransform);
      target.view.addBounds(bounds);
    }
    for (let i2 = 0; i2 < target.children.length; i2++) {
      _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        target.effects[i2].addBounds?.(bounds);
      }
      parentBounds.setMatrix(Matrix.IDENTITY);
      parentBounds.addBounds(bounds);
    }
  }
  function updateTransformBackwards(target, parentTransform) {
    const parent = target.parent;
    if (parent) {
      updateTransformBackwards(parent, parentTransform);
      if (parent.didChange) {
        updateLocalTransform(parent.localTransform, parent);
      }
      parentTransform.append(parent.localTransform);
    }
    return parentTransform;
  }
  var init_getGlobalBounds = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/getGlobalBounds.mjs"() {
      init_Matrix();
      init_updateLocalTransform();
    }
  });

  // node_modules/pixi-v8/lib/utils/logging/warn.mjs
  function warn(...args) {
    if (warnCount === maxWarnings)
      return;
    warnCount++;
    if (warnCount === maxWarnings) {
      console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
      console.warn("PixiJS Warning: ", ...args);
    }
  }
  var warnCount, maxWarnings;
  var init_warn = __esm({
    "node_modules/pixi-v8/lib/utils/logging/warn.mjs"() {
      warnCount = 0;
      maxWarnings = 500;
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/getLocalBounds.mjs
  function getLocalBounds(target, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = new Matrix());
    if (target.view) {
      bounds.setMatrix(relativeMatrix);
      target.view.addBounds(bounds);
    }
    for (let i2 = 0; i2 < target.children.length; i2++) {
      _getLocalBounds(target.children[i2], bounds, relativeMatrix, target);
    }
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getLocalBounds(target, bounds, parentTransform, rootContainer) {
    if (!target.visible || !target.measurable)
      return;
    if (target.didChange) {
      updateLocalTransform(target.localTransform, target);
    }
    const localTransform = target.localTransform;
    const relativeTransform = Matrix.shared.appendFrom(localTransform, parentTransform).clone();
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = new Bounds();
    }
    if (target.view) {
      bounds.setMatrix(relativeTransform);
      target.view.addBounds(bounds);
    }
    for (let i2 = 0; i2 < target.children.length; i2++) {
      _getLocalBounds(target.children[i2], bounds, relativeTransform, rootContainer);
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        target.effects[i2].addLocalBounds?.(bounds, rootContainer);
      }
      parentBounds.setMatrix(Matrix.IDENTITY);
      parentBounds.addBounds(bounds);
    }
  }
  var init_getLocalBounds = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/getLocalBounds.mjs"() {
      init_Matrix();
      init_updateLocalTransform();
      init_Bounds();
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/measureMixin.mjs
  var tempBounds, tempMatrix2, measureMixin;
  var init_measureMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/measureMixin.mjs"() {
      init_Matrix();
      init_Bounds();
      init_getGlobalBounds();
      init_getLocalBounds();
      tempBounds = new Bounds();
      tempMatrix2 = new Matrix();
      measureMixin = {
        get width() {
          return Math.abs(this.scale.x * getLocalBounds(this, tempBounds, tempMatrix2).width);
        },
        set width(value) {
          const localWidth = getLocalBounds(this, tempBounds, tempMatrix2).width;
          if (localWidth !== 0) {
            this.scale.x = value / localWidth;
          } else {
            this.scale.x = 1;
          }
        },
        get height() {
          return Math.abs(this.scale.y * getLocalBounds(this, tempBounds, tempMatrix2).height);
        },
        set height(value) {
          const localHeight = getLocalBounds(this, tempBounds, tempMatrix2).height;
          if (localHeight !== 0) {
            this.scale.y = value / localHeight;
          } else {
            this.scale.y = 1;
          }
        },
        getLocalBounds(rect) {
          const bounds = getLocalBounds(this, new Bounds(), tempMatrix2);
          return rect ? rect.copyFromBounds(bounds) : bounds.rectangle.clone();
        },
        getBounds(skipUpdate, rect) {
          const bounds = getGlobalBounds(this, skipUpdate, tempBounds);
          return rect ? rect.copyFromBounds(bounds) : bounds.rectangle.clone();
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/onRenderMixin.mjs
  var onRenderMixin;
  var init_onRenderMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
      onRenderMixin = {
        _onRender: null,
        set onRender(func) {
          const layerGroup = this.layerGroup;
          if (!func) {
            if (this._onRender) {
              layerGroup?.removeOnRender(this);
            }
            this._onRender = null;
            return;
          }
          if (!this._onRender) {
            layerGroup?.addOnRender(this);
          }
          this._onRender = func;
        },
        get onRender() {
          return this._onRender;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/sortMixin.mjs
  function sortChildren(a2, b2) {
    return a2._zIndex - b2._zIndex;
  }
  var sortMixin;
  var init_sortMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/sortMixin.mjs"() {
      sortMixin = {
        _zIndex: 0,
        sortDirty: false,
        sortableChildren: false,
        get zIndex() {
          return this._zIndex;
        },
        set zIndex(value) {
          if (this._zIndex === value)
            return;
          this._zIndex = value;
          this.depthOfChildModified();
        },
        depthOfChildModified() {
          if (this.parent) {
            this.parent.sortableChildren = true;
            this.parent.sortDirty = true;
          }
          if (this.layerGroup && !this.isLayerRoot) {
            this.layerGroup.structureDidChange = true;
          }
        },
        sortChildren() {
          if (!this.sortDirty)
            return;
          this.sortDirty = false;
          this.children.sort(sortChildren);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
  var toLocalGlobalMixin;
  var init_toLocalGlobalMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
      init_Matrix();
      init_Point();
      init_getGlobalBounds();
      init_updateLocalTransform();
      toLocalGlobalMixin = {
        getGlobalPosition(point = new Point(), skipUpdate = false) {
          if (this.parent) {
            this.parent.toGlobal(this._position, point, skipUpdate);
          } else {
            point.x = this._position.x;
            point.y = this._position.y;
          }
          return point;
        },
        toGlobal(position, point, skipUpdate = false) {
          if (!skipUpdate) {
            if (this.didChange) {
              updateLocalTransform(this.localTransform, this);
            }
            const globalMatrix = updateTransformBackwards(this, new Matrix());
            globalMatrix.append(this.localTransform);
            return globalMatrix.apply(position, point);
          }
          return this.worldTransform.apply(position, point);
        },
        toLocal(position, from, point, skipUpdate) {
          if (from) {
            position = from.toGlobal(position, point, skipUpdate);
          }
          if (!skipUpdate) {
            if (this.didChange) {
              updateLocalTransform(this.localTransform, this);
            }
            const globalMatrix = updateTransformBackwards(this, new Matrix());
            globalMatrix.append(this.localTransform);
            return globalMatrix.applyInverse(position, point);
          }
          return this.worldTransform.applyInverse(position, point);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
  var InstructionSet;
  var init_InstructionSet = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
      init_uid();
      InstructionSet = class {
        constructor() {
          this.uid = uid("instructionSet");
          this.instructions = [];
          this.instructionSize = 0;
        }
        reset() {
          this.instructionSize = 0;
        }
        add(instruction) {
          this.instructions[this.instructionSize++] = instruction;
        }
        log() {
          this.instructions.length = this.instructionSize;
          console.table(this.instructions, ["type", "action"]);
        }
        lastInstruction() {
          return this.instructions[this.instructionSize - 1];
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/LayerGroup.mjs
  var LayerGroup;
  var init_LayerGroup = __esm({
    "node_modules/pixi-v8/lib/scene/container/LayerGroup.mjs"() {
      init_Matrix();
      init_InstructionSet();
      LayerGroup = class {
        constructor(root) {
          this.type = "layer";
          this.root = null;
          this.canBundle = false;
          this.layerGroupParent = null;
          this.layerGroupChildren = [];
          this._children = [];
          this.worldTransform = new Matrix();
          this.worldColor = 4294967295;
          this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
          this.updateTick = 0;
          this.childrenRenderablesToUpdate = { list: [], index: 0 };
          this.structureDidChange = true;
          this.instructionSet = new InstructionSet();
          this._onRenderContainers = [];
          this.root = root;
          this.addChild(root);
        }
        get localTransform() {
          return this.root.localTransform;
        }
        get layerTransform() {
          return this.root.layerTransform;
        }
        addLayerGroupChild(layerGroupChild) {
          if (layerGroupChild.layerGroupParent) {
            layerGroupChild.layerGroupParent._removeLayerGroupChild(layerGroupChild);
          }
          layerGroupChild.layerGroupParent = this;
          this.onChildUpdate(layerGroupChild.root);
          this.layerGroupChildren.push(layerGroupChild);
        }
        _removeLayerGroupChild(layerGroupChild) {
          if (layerGroupChild.root.didChange) {
            this._removeChildFromUpdate(layerGroupChild.root);
          }
          const index = this.layerGroupChildren.indexOf(layerGroupChild);
          if (index > -1) {
            this.layerGroupChildren.splice(index, 1);
          }
          layerGroupChild.layerGroupParent = null;
        }
        addChild(child) {
          this.structureDidChange = true;
          if (child !== this.root) {
            this._children.push(child);
            child.updateTick = -1;
            if (child.parent === this.root) {
              child.relativeLayerDepth = 1;
            } else {
              child.relativeLayerDepth = child.parent.relativeLayerDepth + 1;
            }
            if (child._onRender) {
              this.addOnRender(child);
            }
          }
          if (child.layerGroup) {
            if (child.layerGroup.root === child) {
              this.addLayerGroupChild(child.layerGroup);
              return;
            }
          } else {
            child.layerGroup = this;
            child.didChange = true;
          }
          const children = child.children;
          if (!child.isLayerRoot) {
            this.onChildUpdate(child);
          }
          for (let i2 = 0; i2 < children.length; i2++) {
            this.addChild(children[i2]);
          }
        }
        removeChild(child) {
          this.structureDidChange = true;
          if (child._onRender) {
            this.removeOnRender(child);
          }
          if (child.layerGroup.root !== child) {
            const children = child.children;
            for (let i2 = 0; i2 < children.length; i2++) {
              this.removeChild(children[i2]);
            }
            if (child.didChange) {
              child.layerGroup._removeChildFromUpdate(child);
            }
            child.layerGroup = null;
          } else {
            this._removeLayerGroupChild(child.layerGroup);
          }
          const index = this._children.indexOf(child);
          if (index > -1) {
            this._children.splice(index, 1);
          }
        }
        onChildUpdate(child) {
          let childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
          if (!childrenToUpdate) {
            childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth] = {
              index: 0,
              list: []
            };
          }
          childrenToUpdate.list[childrenToUpdate.index++] = child;
        }
        updateRenderable(container) {
          if (container.layerVisibleRenderable < 3)
            return;
          container.didViewUpdate = false;
          this.instructionSet.renderPipes[container.view.renderPipeId].updateRenderable(container);
        }
        onChildViewUpdate(child) {
          this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
        }
        _removeChildFromUpdate(child) {
          const childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
          if (!childrenToUpdate) {
            return;
          }
          const index = childrenToUpdate.list.indexOf(child);
          if (index > -1) {
            childrenToUpdate.list.splice(index, 1);
          }
          childrenToUpdate.index--;
        }
        get isRenderable() {
          const worldAlpha = this.worldColor >> 24 & 255;
          return this.root.localVisibleRenderable === 3 && worldAlpha > 0;
        }
        addOnRender(container) {
          this._onRenderContainers.push(container);
        }
        removeOnRender(container) {
          this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
        }
        runOnRender() {
          this._onRenderContainers.forEach((container) => {
            container._onRender();
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/definedProps.mjs
  function definedProps(obj) {
    return Object.fromEntries(
      Object.entries(obj).filter(([_k, v2]) => v2 !== void 0)
    );
  }
  var init_definedProps = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/definedProps.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/container/Container.mjs
  var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container;
  var init_Container = __esm({
    "node_modules/pixi-v8/lib/scene/container/Container.mjs"() {
      init_eventemitter3();
      init_Color();
      init_Matrix();
      init_const();
      init_ObservablePoint();
      init_uid();
      init_deprecation();
      init_childrenHelperMixin();
      init_effectsMixin();
      init_findMixin();
      init_measureMixin();
      init_onRenderMixin();
      init_sortMixin();
      init_toLocalGlobalMixin();
      init_LayerGroup();
      init_definedProps();
      defaultSkew = new ObservablePoint(null);
      defaultPivot = new ObservablePoint(null);
      defaultScale = new ObservablePoint(null, 1, 1);
      UPDATE_COLOR = 1;
      UPDATE_BLEND = 2;
      UPDATE_VISIBLE = 4;
      Container = class extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this.uid = uid("renderable");
          this._updateFlags = 15;
          this.isLayerRoot = false;
          this.layerGroup = null;
          this.didChange = false;
          this.didViewUpdate = false;
          this.relativeLayerDepth = 0;
          this.children = [];
          this.parent = null;
          this.includeInBuild = true;
          this.measurable = true;
          this.isSimple = true;
          this.updateTick = -1;
          this.localTransform = new Matrix();
          this.layerTransform = new Matrix();
          this.destroyed = false;
          this._position = new ObservablePoint(this, 0, 0);
          this._scale = defaultScale;
          this._pivot = defaultPivot;
          this._skew = defaultSkew;
          this._cx = 1;
          this._sx = 0;
          this._cy = 0;
          this._sy = 1;
          this._rotation = 0;
          this.localColor = 4294967295;
          this.layerColor = 4294967295;
          this.localBlendMode = "inherit";
          this.layerBlendMode = "normal";
          this.localVisibleRenderable = 3;
          this.layerVisibleRenderable = 3;
          if (options.view) {
            this.view = options.view;
            this.view.owner = this;
            options.view = void 0;
          }
          Object.assign(this, definedProps(options));
          this.children = [];
          options.children?.forEach((child) => this.addChild(child));
          this.effects = [];
          options.effects?.forEach((effect) => this.addEffect(effect));
        }
        static mixin(source2) {
          Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source2));
        }
        addChild(...children) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
          }
          if (children.length > 1) {
            for (let i2 = 0; i2 < children.length; i2++) {
              this.addChild(children[i2]);
            }
            return children[0];
          }
          const child = children[0];
          if (child.parent === this) {
            this.children.splice(this.children.indexOf(child), 1);
            this.children.push(child);
            if (this.layerGroup && !this.isLayerRoot) {
              this.layerGroup.structureDidChange = true;
            }
            return child;
          }
          if (child.parent) {
            child.parent.removeChild(child);
          }
          this.children.push(child);
          if (this.sortableChildren)
            this.sortDirty = true;
          child.parent = this;
          child.didChange = true;
          child.didViewUpdate = false;
          child._updateFlags = 15;
          if (this.layerGroup) {
            this.layerGroup.addChild(child);
          }
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
          if (child._zIndex !== 0) {
            child.depthOfChildModified();
          }
          return child;
        }
        removeChild(...children) {
          if (children.length > 1) {
            for (let i2 = 0; i2 < children.length; i2++) {
              this.removeChild(children[i2]);
            }
            return children[0];
          }
          const child = children[0];
          const index = this.children.indexOf(child);
          if (index > -1) {
            this.children.splice(index, 1);
            if (this.layerGroup) {
              this.layerGroup.removeChild(child);
            }
          }
          child.parent = null;
          this.emit("childRemoved", child, this, index);
          child.emit("removed", this);
          return child;
        }
        onUpdate(point) {
          if (point) {
            if (point === this._skew) {
              this._updateSkew();
            }
          }
          if (this.didChange)
            return;
          this.didChange = true;
          if (this.isLayerRoot) {
            const layerGroupParent = this.layerGroup.layerGroupParent;
            if (layerGroupParent) {
              layerGroupParent.onChildUpdate(this);
            }
          } else if (this.layerGroup) {
            this.layerGroup.onChildUpdate(this);
          }
        }
        onViewUpdate() {
          if (this.didViewUpdate)
            return;
          this.didViewUpdate = true;
          if (this.layerGroup) {
            this.layerGroup.onChildViewUpdate(this);
          }
        }
        set layer(value) {
          if (this.isLayerRoot && value === false) {
            throw new Error("[Pixi] cannot undo a layer just yet");
          }
          if (value) {
            this.enableLayer();
          }
        }
        get layer() {
          return this.isLayerRoot;
        }
        enableLayer() {
          if (this.layerGroup && this.layerGroup.root === this)
            return;
          this.isLayerRoot = true;
          const parentLayerGroup = this.layerGroup;
          if (parentLayerGroup) {
            parentLayerGroup.removeChild(this);
          }
          this.layerGroup = new LayerGroup(this);
          if (parentLayerGroup) {
            for (let i2 = 0; i2 < parentLayerGroup.layerGroupChildren.length; i2++) {
              const childLayerGroup = parentLayerGroup.layerGroupChildren[i2];
              let parent = childLayerGroup.root;
              while (parent) {
                if (parent === this) {
                  this.layerGroup.addLayerGroupChild(childLayerGroup);
                  break;
                }
                parent = parent.parent;
              }
            }
            parentLayerGroup.addLayerGroupChild(this.layerGroup);
          }
          this._updateIsSimple();
        }
        _updateIsSimple() {
          this.isSimple = !this.isLayerRoot && this.effects.length === 0;
        }
        get worldTransform() {
          this._worldTransform || (this._worldTransform = new Matrix());
          if (this.layerGroup) {
            if (this.isLayerRoot) {
              this._worldTransform.copyFrom(this.layerGroup.worldTransform);
            } else {
              this._worldTransform.appendFrom(this.layerTransform, this.layerGroup.worldTransform);
            }
          }
          return this._worldTransform;
        }
        get x() {
          return this._position.x;
        }
        set x(value) {
          this._position.x = value;
        }
        get y() {
          return this._position.y;
        }
        set y(value) {
          this._position.y = value;
        }
        get position() {
          return this._position;
        }
        set position(value) {
          this._position.copyFrom(value);
        }
        get rotation() {
          return this._rotation;
        }
        set rotation(value) {
          if (this._rotation !== value) {
            this._rotation = value;
            this.onUpdate(this._skew);
          }
        }
        get angle() {
          return this.rotation * RAD_TO_DEG;
        }
        set angle(value) {
          this.rotation = value * DEG_TO_RAD;
        }
        get pivot() {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          return this._pivot;
        }
        set pivot(value) {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          this._pivot.copyFrom(value);
        }
        get skew() {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          return this._skew;
        }
        get scale() {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 1, 1);
          }
          return this._scale;
        }
        set scale(value) {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 0, 0);
          }
          this._scale.copyFrom(value);
        }
        _updateSkew() {
          const rotation = this._rotation;
          const skew = this._skew;
          this._cx = Math.cos(rotation + skew._y);
          this._sx = Math.sin(rotation + skew._y);
          this._cy = -Math.sin(rotation - skew._x);
          this._sy = Math.cos(rotation - skew._x);
        }
        set alpha(value) {
          value = value * 255 | 0;
          if (value === (this.localColor >> 24 & 255))
            return;
          this.localColor = this.localColor & 16777215 | value << 24;
          this._updateFlags |= UPDATE_COLOR;
          this.onUpdate();
        }
        get alpha() {
          return (this.localColor >> 24 & 255) / 255;
        }
        set tint(value) {
          const tempColor = Color.shared.setValue(value);
          const bgr = tempColor.toBgrNumber();
          if (bgr === (this.localColor & 16777215))
            return;
          this.localColor = this.localColor & 4278190080 | bgr & 16777215;
          this._updateFlags |= UPDATE_COLOR;
          this.onUpdate();
        }
        get tint() {
          const bgr = this.localColor & 16777215;
          return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
        }
        set blendMode(value) {
          if (this.localBlendMode === value)
            return;
          if (this.layerGroup && !this.isLayerRoot) {
            this.layerGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_BLEND;
          this.localBlendMode = value;
          this.onUpdate();
        }
        get blendMode() {
          return this.localBlendMode;
        }
        get visible() {
          return !!(this.localVisibleRenderable & 2);
        }
        set visible(value) {
          const valueNumber = value ? 1 : 0;
          if ((this.localVisibleRenderable & 2) >> 1 === valueNumber)
            return;
          if (this.layerGroup && !this.isLayerRoot) {
            this.layerGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localVisibleRenderable = this.localVisibleRenderable & 1 | valueNumber << 1;
          this.onUpdate();
        }
        get renderable() {
          return !!(this.localVisibleRenderable & 1);
        }
        set renderable(value) {
          const valueNumber = value ? 1 : 0;
          if ((this.localVisibleRenderable & 1) === valueNumber)
            return;
          this.localVisibleRenderable = this.localVisibleRenderable & 2 | valueNumber;
          this._updateFlags |= UPDATE_VISIBLE;
          if (this.layerGroup && !this.isLayerRoot) {
            this.layerGroup.structureDidChange = true;
          }
          this.onUpdate();
        }
        get isRenderable() {
          const worldAlpha = this.layerColor >> 24 & 255;
          return this.localVisibleRenderable === 3 && worldAlpha > 0;
        }
        destroy(options = false) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          this.removeFromParent();
          this.parent = null;
          this._mask = null;
          this._filters = null;
          this.effects = null;
          this._position = null;
          this._scale = null;
          this._pivot = null;
          this._skew = null;
          this.emit("destroyed");
          this.removeAllListeners();
          const destroyChildren = typeof options === "boolean" ? options : options?.children;
          const oldChildren = this.removeChildren(0, this.children.length);
          if (destroyChildren) {
            for (let i2 = 0; i2 < oldChildren.length; ++i2) {
              oldChildren[i2].destroy(options);
            }
          }
          if (this.view) {
            this.view.destroy(options);
            this.view.owner = null;
          }
        }
      };
      Container.mixin(childrenHelperMixin);
      Container.mixin(toLocalGlobalMixin);
      Container.mixin(onRenderMixin);
      Container.mixin(measureMixin);
      Container.mixin(effectsMixin);
      Container.mixin(findMixin);
      Container.mixin(sortMixin);
    }
  });

  // node_modules/ismobilejs/esm/isMobile.js
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }
  var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
  var init_isMobile = __esm({
    "node_modules/ismobilejs/esm/isMobile.js"() {
      appleIphone = /iPhone/i;
      appleIpod = /iPod/i;
      appleTablet = /iPad/i;
      appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
      androidPhone = /\bAndroid(?:.+)Mobile\b/i;
      androidTablet = /Android/i;
      amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
      amazonTablet = /Silk/i;
      windowsPhone = /Windows Phone/i;
      windowsTablet = /\bWindows(?:.+)ARM\b/i;
      otherBlackBerry = /BlackBerry/i;
      otherBlackBerry10 = /BB10/i;
      otherOpera = /Opera Mini/i;
      otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
      otherFirefox = /Mobile(?:.+)Firefox\b/i;
      isAppleTabletOnIos13 = function(navigator2) {
        return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
      };
    }
  });

  // node_modules/ismobilejs/esm/index.js
  var init_esm = __esm({
    "node_modules/ismobilejs/esm/index.js"() {
      init_isMobile();
      init_isMobile();
    }
  });

  // node_modules/pixi-v8/lib/settings/utils/isMobile.mjs
  var isMobileCall, isMobile2;
  var init_isMobile2 = __esm({
    "node_modules/pixi-v8/lib/settings/utils/isMobile.mjs"() {
      init_esm();
      isMobileCall = isMobile.default ?? isMobile;
      isMobile2 = isMobileCall(globalThis.navigator);
    }
  });

  // node_modules/pixi-v8/lib/accessibility/accessibilityTarget.mjs
  var accessibilityTarget;
  var init_accessibilityTarget = __esm({
    "node_modules/pixi-v8/lib/accessibility/accessibilityTarget.mjs"() {
      accessibilityTarget = {
        accessible: false,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        _accessibleActive: false,
        _accessibleDiv: null,
        accessibleType: "button",
        accessiblePointerEvents: "auto",
        accessibleChildren: true,
        renderId: -1
      };
    }
  });

  // node_modules/pixi-v8/lib/accessibility/AccessibilitySystem.mjs
  var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, AccessibilitySystem;
  var init_AccessibilitySystem = __esm({
    "node_modules/pixi-v8/lib/accessibility/AccessibilitySystem.mjs"() {
      init_FederatedEvent();
      init_Extensions();
      init_Container();
      init_isMobile2();
      init_removeItems();
      init_accessibilityTarget();
      Container.mixin(accessibilityTarget);
      KEY_CODE_TAB = 9;
      DIV_TOUCH_SIZE = 100;
      DIV_TOUCH_POS_X = 0;
      DIV_TOUCH_POS_Y = 0;
      DIV_TOUCH_ZINDEX = 2;
      DIV_HOOK_SIZE = 1;
      DIV_HOOK_POS_X = -1e3;
      DIV_HOOK_POS_Y = -1e3;
      DIV_HOOK_ZINDEX = 2;
      AccessibilitySystem = class {
        constructor(renderer, _mobileInfo = isMobile2) {
          this._mobileInfo = _mobileInfo;
          this.debug = false;
          this._isActive = false;
          this._isMobileAccessibility = false;
          this._pool = [];
          this._renderId = 0;
          this._children = [];
          this._androidUpdateCount = 0;
          this._androidUpdateFrequency = 500;
          this._hookDiv = null;
          if (_mobileInfo.tablet || _mobileInfo.phone) {
            this._createTouchHook();
          }
          const div = document.createElement("div");
          div.style.width = `${DIV_TOUCH_SIZE}px`;
          div.style.height = `${DIV_TOUCH_SIZE}px`;
          div.style.position = "absolute";
          div.style.top = `${DIV_TOUCH_POS_X}px`;
          div.style.left = `${DIV_TOUCH_POS_Y}px`;
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          this._div = div;
          this._renderer = renderer;
          this._onKeyDown = this._onKeyDown.bind(this);
          this._onMouseMove = this._onMouseMove.bind(this);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        get isActive() {
          return this._isActive;
        }
        get isMobileAccessibility() {
          return this._isMobileAccessibility;
        }
        get hookDiv() {
          return this._hookDiv;
        }
        _createTouchHook() {
          const hookDiv = document.createElement("button");
          hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.position = "absolute";
          hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
          hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
          hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
          hookDiv.style.backgroundColor = "#FF0000";
          hookDiv.title = "select to enable accessibility for this content";
          hookDiv.addEventListener("focus", () => {
            this._isMobileAccessibility = true;
            this._activate();
            this._destroyTouchHook();
          });
          document.body.appendChild(hookDiv);
          this._hookDiv = hookDiv;
        }
        _destroyTouchHook() {
          if (!this._hookDiv) {
            return;
          }
          document.body.removeChild(this._hookDiv);
          this._hookDiv = null;
        }
        _activate() {
          if (this._isActive) {
            return;
          }
          this._isActive = true;
          globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.add(this);
          this._renderer.view.canvas.parentNode?.appendChild(this._div);
        }
        _deactivate() {
          if (!this._isActive || this._isMobileAccessibility) {
            return;
          }
          this._isActive = false;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.remove(this);
          this._div.parentNode?.removeChild(this._div);
        }
        _updateAccessibleObjects(container) {
          if (!container.visible || !container.accessibleChildren) {
            return;
          }
          if (container.accessible && container.isInteractive()) {
            if (!container._accessibleActive) {
              this._addChild(container);
            }
            container.renderId = this._renderId;
          }
          const children = container.children;
          if (children) {
            for (let i2 = 0; i2 < children.length; i2++) {
              this._updateAccessibleObjects(children[i2]);
            }
          }
        }
        init(options) {
          this.debug = options?.debug ?? this.debug;
          this._renderer.runners.postrender.remove(this);
        }
        postrender() {
          const now = performance.now();
          if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
            return;
          }
          this._androidUpdateCount = now + this._androidUpdateFrequency;
          if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
            return;
          }
          if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          }
          const { x: x2, y: y2, width, height } = this._renderer.view.canvas.getBoundingClientRect();
          const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
          const sx = width / viewWidth * resolution;
          const sy = height / viewHeight * resolution;
          let div = this._div;
          div.style.left = `${x2}px`;
          div.style.top = `${y2}px`;
          div.style.width = `${viewWidth}px`;
          div.style.height = `${viewHeight}px`;
          for (let i2 = 0; i2 < this._children.length; i2++) {
            const child = this._children[i2];
            if (child.renderId !== this._renderId) {
              child._accessibleActive = false;
              removeItems(this._children, i2, 1);
              this._div.removeChild(child._accessibleDiv);
              this._pool.push(child._accessibleDiv);
              child._accessibleDiv = null;
              i2--;
            } else {
              div = child._accessibleDiv;
              let hitArea = child.hitArea;
              const wt = child.worldTransform;
              if (child.hitArea) {
                div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
                div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
                div.style.width = `${hitArea.width * wt.a * sx}px`;
                div.style.height = `${hitArea.height * wt.d * sy}px`;
              } else {
                hitArea = child.getBounds();
                this.capHitArea(hitArea);
                div.style.left = `${hitArea.x * sx}px`;
                div.style.top = `${hitArea.y * sy}px`;
                div.style.width = `${hitArea.width * sx}px`;
                div.style.height = `${hitArea.height * sy}px`;
                if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                  div.title = child.accessibleTitle;
                }
                if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                  div.setAttribute("aria-label", child.accessibleHint);
                }
              }
              if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
                div.title = child.accessibleTitle;
                div.tabIndex = child.tabIndex;
                if (this.debug) {
                  this.updateDebugHTML(div);
                }
              }
            }
          }
          this._renderId++;
        }
        updateDebugHTML(div) {
          div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
        }
        capHitArea(hitArea) {
          if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
          }
          if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
          }
          const { width: viewWidth, height: viewHeight } = this._renderer;
          if (hitArea.x + hitArea.width > viewWidth) {
            hitArea.width = viewWidth - hitArea.x;
          }
          if (hitArea.y + hitArea.height > viewHeight) {
            hitArea.height = viewHeight - hitArea.y;
          }
        }
        _addChild(container) {
          let div = this._pool.pop();
          if (!div) {
            div = document.createElement("button");
            div.style.width = `${DIV_TOUCH_SIZE}px`;
            div.style.height = `${DIV_TOUCH_SIZE}px`;
            div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
            div.style.position = "absolute";
            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            div.style.borderStyle = "none";
            if (navigator.userAgent.toLowerCase().includes("chrome")) {
              div.setAttribute("aria-live", "off");
            } else {
              div.setAttribute("aria-live", "polite");
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
              div.setAttribute("aria-relevant", "additions");
            } else {
              div.setAttribute("aria-relevant", "text");
            }
            div.addEventListener("click", this._onClick.bind(this));
            div.addEventListener("focus", this._onFocus.bind(this));
            div.addEventListener("focusout", this._onFocusOut.bind(this));
          }
          div.style.pointerEvents = container.accessiblePointerEvents;
          div.type = container.accessibleType;
          if (container.accessibleTitle && container.accessibleTitle !== null) {
            div.title = container.accessibleTitle;
          } else if (!container.accessibleHint || container.accessibleHint === null) {
            div.title = `container ${container.tabIndex}`;
          }
          if (container.accessibleHint && container.accessibleHint !== null) {
            div.setAttribute("aria-label", container.accessibleHint);
          }
          if (this.debug) {
            this.updateDebugHTML(div);
          }
          container._accessibleActive = true;
          container._accessibleDiv = div;
          div.container = container;
          this._children.push(container);
          this._div.appendChild(container._accessibleDiv);
          container._accessibleDiv.tabIndex = container.tabIndex;
        }
        _dispatchEvent(e2, type) {
          const { container: target } = e2.target;
          const boundary = this._renderer.events.rootBoundary;
          const event = Object.assign(new FederatedEvent(boundary), { target });
          boundary.rootTarget = this._renderer.lastObjectRendered;
          type.forEach((type2) => boundary.dispatchEvent(event, type2));
        }
        _onClick(e2) {
          this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
        }
        _onFocus(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "assertive");
          }
          this._dispatchEvent(e2, ["mouseover"]);
        }
        _onFocusOut(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "polite");
          }
          this._dispatchEvent(e2, ["mouseout"]);
        }
        _onKeyDown(e2) {
          if (e2.keyCode !== KEY_CODE_TAB) {
            return;
          }
          this._activate();
        }
        _onMouseMove(e2) {
          if (e2.movementX === 0 && e2.movementY === 0) {
            return;
          }
          this._deactivate();
        }
        destroy() {
          this._destroyTouchHook();
          this._div = null;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown);
          this._pool = null;
          this._children = null;
          this._renderer = null;
        }
      };
      AccessibilitySystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "accessibility"
      };
      extensions.add(AccessibilitySystem);
    }
  });

  // node_modules/pixi-v8/lib/accessibility/init.mjs
  var init_init = __esm({
    "node_modules/pixi-v8/lib/accessibility/init.mjs"() {
      init_Extensions();
      init_Container();
      init_AccessibilitySystem();
      init_accessibilityTarget();
      extensions.add(AccessibilitySystem);
      Container.mixin(accessibilityTarget);
    }
  });

  // node_modules/pixi-v8/lib/ticker/const.mjs
  var UPDATE_PRIORITY;
  var init_const2 = __esm({
    "node_modules/pixi-v8/lib/ticker/const.mjs"() {
      UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
        return UPDATE_PRIORITY2;
      })(UPDATE_PRIORITY || {});
    }
  });

  // node_modules/pixi-v8/lib/ticker/TickerListener.mjs
  var TickerListener;
  var init_TickerListener = __esm({
    "node_modules/pixi-v8/lib/ticker/TickerListener.mjs"() {
      TickerListener = class {
        constructor(fn, context2 = null, priority = 0, once = false) {
          this.next = null;
          this.previous = null;
          this._destroyed = false;
          this._fn = fn;
          this._context = context2;
          this.priority = priority;
          this._once = once;
        }
        match(fn, context2 = null) {
          return this._fn === fn && this._context === context2;
        }
        emit(ticker) {
          if (this._fn) {
            if (this._context) {
              this._fn.call(this._context, ticker);
            } else {
              this._fn(ticker);
            }
          }
          const redirect = this.next;
          if (this._once) {
            this.destroy(true);
          }
          if (this._destroyed) {
            this.next = null;
          }
          return redirect;
        }
        connect(previous) {
          this.previous = previous;
          if (previous.next) {
            previous.next.previous = this;
          }
          this.next = previous.next;
          previous.next = this;
        }
        destroy(hard = false) {
          this._destroyed = true;
          this._fn = null;
          this._context = null;
          if (this.previous) {
            this.previous.next = this.next;
          }
          if (this.next) {
            this.next.previous = this.previous;
          }
          const redirect = this.next;
          this.next = hard ? null : redirect;
          this.previous = null;
          return redirect;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/ticker/Ticker.mjs
  var _Ticker, Ticker;
  var init_Ticker = __esm({
    "node_modules/pixi-v8/lib/ticker/Ticker.mjs"() {
      init_const2();
      init_TickerListener();
      _Ticker = class {
        constructor() {
          this.autoStart = false;
          this.deltaTime = 1;
          this.lastTime = -1;
          this.speed = 1;
          this.started = false;
          this._requestId = null;
          this._maxElapsedMS = 100;
          this._minElapsedMS = 0;
          this._protected = false;
          this._lastFrame = -1;
          this._head = new TickerListener(null, null, Infinity);
          this.deltaMS = 1 / _Ticker.targetFPMS;
          this.elapsedMS = 1 / _Ticker.targetFPMS;
          this._tick = (time) => {
            this._requestId = null;
            if (this.started) {
              this.update(time);
              if (this.started && this._requestId === null && this._head.next) {
                this._requestId = requestAnimationFrame(this._tick);
              }
            }
          };
        }
        _requestIfNeeded() {
          if (this._requestId === null && this._head.next) {
            this.lastTime = performance.now();
            this._lastFrame = this.lastTime;
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
        _cancelIfNeeded() {
          if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
          }
        }
        _startIfPossible() {
          if (this.started) {
            this._requestIfNeeded();
          } else if (this.autoStart) {
            this.start();
          }
        }
        add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context2, priority));
        }
        addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context2, priority, true));
        }
        _addListener(listener) {
          let current = this._head.next;
          let previous = this._head;
          if (!current) {
            listener.connect(previous);
          } else {
            while (current) {
              if (listener.priority > current.priority) {
                listener.connect(previous);
                break;
              }
              previous = current;
              current = current.next;
            }
            if (!listener.previous) {
              listener.connect(previous);
            }
          }
          this._startIfPossible();
          return this;
        }
        remove(fn, context2) {
          let listener = this._head.next;
          while (listener) {
            if (listener.match(fn, context2)) {
              listener = listener.destroy();
            } else {
              listener = listener.next;
            }
          }
          if (!this._head.next) {
            this._cancelIfNeeded();
          }
          return this;
        }
        get count() {
          if (!this._head) {
            return 0;
          }
          let count2 = 0;
          let current = this._head;
          while (current = current.next) {
            count2++;
          }
          return count2;
        }
        start() {
          if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
          }
        }
        stop() {
          if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
          }
        }
        destroy() {
          if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            while (listener) {
              listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
          }
        }
        update(currentTime = performance.now()) {
          let elapsedMS;
          if (currentTime > this.lastTime) {
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            if (elapsedMS > this._maxElapsedMS) {
              elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            if (this._minElapsedMS) {
              const delta = currentTime - this._lastFrame | 0;
              if (delta < this._minElapsedMS) {
                return;
              }
              this._lastFrame = currentTime - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
            const head = this._head;
            let listener = head.next;
            while (listener) {
              listener = listener.emit(this);
            }
            if (!head.next) {
              this._cancelIfNeeded();
            }
          } else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          }
          this.lastTime = currentTime;
        }
        get FPS() {
          return 1e3 / this.elapsedMS;
        }
        get minFPS() {
          return 1e3 / this._maxElapsedMS;
        }
        set minFPS(fps) {
          const minFPS = Math.min(this.maxFPS, fps);
          const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
          this._maxElapsedMS = 1 / minFPMS;
        }
        get maxFPS() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        }
        set maxFPS(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        }
        static get shared() {
          if (!_Ticker._shared) {
            const shared = _Ticker._shared = new _Ticker();
            shared.autoStart = true;
            shared._protected = true;
          }
          return _Ticker._shared;
        }
        static get system() {
          if (!_Ticker._system) {
            const system = _Ticker._system = new _Ticker();
            system.autoStart = true;
            system._protected = true;
          }
          return _Ticker._system;
        }
      };
      Ticker = _Ticker;
      Ticker.targetFPMS = 0.06;
    }
  });

  // node_modules/pixi-v8/lib/ticker/TickerPlugin.mjs
  var TickerPlugin;
  var init_TickerPlugin = __esm({
    "node_modules/pixi-v8/lib/ticker/TickerPlugin.mjs"() {
      init_Extensions();
      init_const2();
      init_Ticker();
      TickerPlugin = class {
        static init(options) {
          options = Object.assign({
            autoStart: true,
            sharedTicker: false
          }, options);
          Object.defineProperty(
            this,
            "ticker",
            {
              set(ticker) {
                if (this._ticker) {
                  this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                  ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
                }
              },
              get() {
                return this._ticker;
              }
            }
          );
          this.stop = () => {
            this._ticker.stop();
          };
          this.start = () => {
            this._ticker.start();
          };
          this._ticker = null;
          this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
          if (options.autoStart) {
            this.start();
          }
        }
        static destroy() {
          if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null;
            oldTicker.destroy();
          }
        }
      };
      TickerPlugin.extension = ExtensionType.Application;
    }
  });

  // node_modules/pixi-v8/lib/app/ResizePlugin.mjs
  var ResizePlugin;
  var init_ResizePlugin = __esm({
    "node_modules/pixi-v8/lib/app/ResizePlugin.mjs"() {
      init_Extensions();
      ResizePlugin = class {
        static init(options) {
          Object.defineProperty(
            this,
            "resizeTo",
            {
              set(dom) {
                globalThis.removeEventListener("resize", this.queueResize);
                this._resizeTo = dom;
                if (dom) {
                  globalThis.addEventListener("resize", this.queueResize);
                  this.resize();
                }
              },
              get() {
                return this._resizeTo;
              }
            }
          );
          this.queueResize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            this._resizeId = requestAnimationFrame(() => this.resize());
          };
          this._cancelResize = () => {
            if (this._resizeId) {
              cancelAnimationFrame(this._resizeId);
              this._resizeId = null;
            }
          };
          this.resize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            let width;
            let height;
            if (this._resizeTo === globalThis.window) {
              width = globalThis.innerWidth;
              height = globalThis.innerHeight;
            } else {
              const { clientWidth, clientHeight } = this._resizeTo;
              width = clientWidth;
              height = clientHeight;
            }
            this.renderer.resize(width, height);
            this.render();
          };
          this._resizeId = null;
          this._resizeTo = null;
          this.resizeTo = options.resizeTo || null;
        }
        static destroy() {
          globalThis.removeEventListener("resize", this.queueResize);
          this._cancelResize();
          this._cancelResize = null;
          this.queueResize = null;
          this.resizeTo = null;
          this.resize = null;
        }
      };
      ResizePlugin.extension = ExtensionType.Application;
    }
  });

  // node_modules/pixi-v8/lib/app/init.mjs
  var init_init2 = __esm({
    "node_modules/pixi-v8/lib/app/init.mjs"() {
      init_Extensions();
      init_TickerPlugin();
      init_ResizePlugin();
      extensions.add(ResizePlugin);
      extensions.add(TickerPlugin);
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/LoaderParser.mjs
  var LoaderParserPriority;
  var init_LoaderParser = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/LoaderParser.mjs"() {
      LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
        LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
        LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
        LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
        return LoaderParserPriority2;
      })(LoaderParserPriority || {});
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/copySearchParams.mjs
  var copySearchParams;
  var init_copySearchParams = __esm({
    "node_modules/pixi-v8/lib/assets/utils/copySearchParams.mjs"() {
      copySearchParams = (targetUrl, sourceUrl) => {
        const searchParams = sourceUrl.split("?")[1];
        if (searchParams) {
          targetUrl += `?${searchParams}`;
        }
        return targetUrl;
      };
    }
  });

  // node_modules/pixi-v8/lib/settings/adapter/adapter.mjs
  var BrowserAdapter;
  var init_adapter = __esm({
    "node_modules/pixi-v8/lib/settings/adapter/adapter.mjs"() {
      BrowserAdapter = {
        createCanvas: (width, height) => {
          const canvas2 = document.createElement("canvas");
          canvas2.width = width;
          canvas2.height = height;
          return canvas2;
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (url, options) => fetch(url, options),
        parseXML: (xml) => {
          const parser = new DOMParser();
          return parser.parseFromString(xml, "text/xml");
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/settings/settings.mjs
  var settings;
  var init_settings = __esm({
    "node_modules/pixi-v8/lib/settings/settings.mjs"() {
      init_adapter();
      settings = {
        ADAPTER: BrowserAdapter,
        RETINA_PREFIX: /@([0-9\.]+)x/,
        FAIL_IF_MAJOR_PERFORMANCE_CAVEAT: false,
        RESOLUTION: 1
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/path.mjs
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url) {
    const re = url.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i2 = 0; i2 <= path2.length; ++i2) {
      if (i2 < path2.length) {
        code = path2.charCodeAt(i2);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i2 - 1 || dots === 1) {
        } else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i2;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i2)}`;
          } else {
            res = path2.slice(lastSlash + 1, i2);
          }
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path;
  var init_path = __esm({
    "node_modules/pixi-v8/lib/utils/path.mjs"() {
      init_settings();
      path = {
        toPosix(path2) {
          return replaceAll(path2, "\\", "/");
        },
        isUrl(path2) {
          return /^https?:/.test(this.toPosix(path2));
        },
        isDataUrl(path2) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
        },
        isBlobUrl(path2) {
          return path2.startsWith("blob:");
        },
        hasProtocol(path2) {
          return /^[^/:]+:/.test(this.toPosix(path2));
        },
        getProtocol(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          const matchFile = /^file:\/\/\//.exec(path2);
          if (matchFile) {
            return matchFile[0];
          }
          const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
          if (matchProtocol) {
            return matchProtocol[0];
          }
          return "";
        },
        toAbsolute(url, customBaseUrl, customRootUrl) {
          assertPath(url);
          if (this.isDataUrl(url) || this.isBlobUrl(url))
            return url;
          const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));
          const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
          url = this.toPosix(url);
          if (url.startsWith("/")) {
            return path.join(rootUrl, url.slice(1));
          }
          const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
          return absolutePath;
        },
        normalize(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          if (this.isDataUrl(path2) || this.isBlobUrl(path2))
            return path2;
          path2 = this.toPosix(path2);
          let protocol = "";
          const isAbsolute = path2.startsWith("/");
          if (this.hasProtocol(path2)) {
            protocol = this.rootname(path2);
            path2 = path2.slice(protocol.length);
          }
          const trailingSeparator = path2.endsWith("/");
          path2 = normalizeStringPosix(path2, false);
          if (path2.length > 0 && trailingSeparator)
            path2 += "/";
          if (isAbsolute)
            return `/${path2}`;
          return protocol + path2;
        },
        isAbsolute(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          if (this.hasProtocol(path2))
            return true;
          return path2.startsWith("/");
        },
        join(...segments) {
          if (segments.length === 0) {
            return ".";
          }
          let joined;
          for (let i2 = 0; i2 < segments.length; ++i2) {
            const arg = segments[i2];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else {
                const prevArg = segments[i2 - 1] ?? "";
                if (this.extname(prevArg)) {
                  joined += `/../${arg}`;
                } else {
                  joined += `/${arg}`;
                }
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return this.normalize(joined);
        },
        dirname(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          path2 = this.toPosix(path2);
          let code = path2.charCodeAt(0);
          const hasRoot = code === 47;
          let end = -1;
          let matchedSlash = true;
          const proto = this.getProtocol(path2);
          const origpath = path2;
          path2 = path2.slice(proto.length);
          for (let i2 = path2.length - 1; i2 >= 1; --i2) {
            code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                end = i2;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
          if (hasRoot && end === 1)
            return "//";
          return proto + path2.slice(0, end);
        },
        rootname(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          let root = "";
          if (path2.startsWith("/"))
            root = "/";
          else {
            root = this.getProtocol(path2);
          }
          if (this.isUrl(path2)) {
            const index = path2.indexOf("/", root.length);
            if (index !== -1) {
              root = path2.slice(0, index);
            } else
              root = path2;
            if (!root.endsWith("/"))
              root += "/";
          }
          return root;
        },
        basename(path2, ext) {
          assertPath(path2);
          if (ext)
            assertPath(ext);
          path2 = removeUrlParams(this.toPosix(path2));
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i2;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
            if (ext.length === path2.length && ext === path2)
              return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i2 = path2.length - 1; i2 >= 0; --i2) {
              const code = path2.charCodeAt(i2);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i2 + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i2;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path2.length;
            return path2.slice(start, end);
          }
          for (i2 = path2.length - 1; i2 >= 0; --i2) {
            if (path2.charCodeAt(i2) === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        },
        extname(path2) {
          assertPath(path2);
          path2 = removeUrlParams(this.toPosix(path2));
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i2 = path2.length - 1; i2 >= 0; --i2) {
            const code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path2.slice(startDot, end);
        },
        parse(path2) {
          assertPath(path2);
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path2.length === 0)
            return ret;
          path2 = removeUrlParams(this.toPosix(path2));
          let code = path2.charCodeAt(0);
          const isAbsolute = this.isAbsolute(path2);
          let start;
          const protocol = "";
          ret.root = this.rootname(path2);
          if (isAbsolute || this.hasProtocol(path2)) {
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i2 = path2.length - 1;
          let preDotState = 0;
          for (; i2 >= start; --i2) {
            code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path2.slice(1, end);
              else
                ret.base = ret.name = path2.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path2.slice(1, startDot);
              ret.base = path2.slice(1, end);
            } else {
              ret.name = path2.slice(startPart, startDot);
              ret.base = path2.slice(startPart, end);
            }
            ret.ext = path2.slice(startDot, end);
          }
          ret.dir = this.dirname(path2);
          if (protocol)
            ret.dir = protocol + ret.dir;
          return ret;
        },
        sep: "/",
        delimiter: ":"
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/convertToList.mjs
  var convertToList;
  var init_convertToList = __esm({
    "node_modules/pixi-v8/lib/assets/utils/convertToList.mjs"() {
      convertToList = (input, transform, forceTransform = false) => {
        if (!Array.isArray(input)) {
          input = [input];
        }
        if (!transform) {
          return input;
        }
        return input.map((item) => {
          if (typeof item === "string" || forceTransform) {
            return transform(item);
          }
          return item;
        });
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/cache/Cache.mjs
  var CacheClass, Cache;
  var init_Cache = __esm({
    "node_modules/pixi-v8/lib/assets/cache/Cache.mjs"() {
      init_warn();
      init_convertToList();
      CacheClass = class {
        constructor() {
          this._parsers = [];
          this._cache = /* @__PURE__ */ new Map();
          this._cacheMap = /* @__PURE__ */ new Map();
        }
        reset() {
          this._cacheMap.clear();
          this._cache.clear();
        }
        has(key) {
          return this._cache.has(key);
        }
        get(key) {
          const result = this._cache.get(key);
          if (!result) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
          }
          return result;
        }
        set(key, value) {
          const keys = convertToList(key);
          let cacheableAssets;
          for (let i2 = 0; i2 < this.parsers.length; i2++) {
            const parser = this.parsers[i2];
            if (parser.test(value)) {
              cacheableAssets = parser.getCacheableAssets(keys, value);
              break;
            }
          }
          if (!cacheableAssets) {
            cacheableAssets = {};
            keys.forEach((key2) => {
              cacheableAssets[key2] = value;
            });
          }
          const cacheKeys = Object.keys(cacheableAssets);
          const cachedAssets = {
            cacheKeys,
            keys
          };
          keys.forEach((key2) => {
            this._cacheMap.set(key2, cachedAssets);
          });
          cacheKeys.forEach((key2) => {
            if (this._cache.has(key2) && this._cache.get(key2) !== value) {
              warn("[Cache] already has key:", key2);
            }
            this._cache.set(key2, cacheableAssets[key2]);
          });
        }
        remove(key) {
          if (!this._cacheMap.has(key)) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
          }
          const cacheMap2 = this._cacheMap.get(key);
          const cacheKeys = cacheMap2.cacheKeys;
          cacheKeys.forEach((key2) => {
            this._cache.delete(key2);
          });
          cacheMap2.keys.forEach((key2) => {
            this._cacheMap.delete(key2);
          });
        }
        get parsers() {
          return this._parsers;
        }
      };
      Cache = new CacheClass();
    }
  });

  // node_modules/pixi-v8/lib/utils/NOOP.mjs
  var NOOP;
  var init_NOOP = __esm({
    "node_modules/pixi-v8/lib/utils/NOOP.mjs"() {
      NOOP = () => {
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/utils/createIdFromString.mjs
  function createIdFromString(value, groupId) {
    let id = idHash[value];
    if (id === void 0) {
      if (idCounts[groupId] === void 0) {
        idCounts[groupId] = 1;
      }
      idHash[value] = id = idCounts[groupId]++;
    }
    return id;
  }
  var idCounts, idHash;
  var init_createIdFromString = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
      idCounts = /* @__PURE__ */ Object.create(null);
      idHash = /* @__PURE__ */ Object.create(null);
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureStyle.mjs
  var _TextureStyle, TextureStyle;
  var init_TextureStyle = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
      init_eventemitter3();
      init_deprecation();
      init_createIdFromString();
      _TextureStyle = class extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this.resourceType = "textureSampler";
          this.touched = 0;
          this._maxAnisotropy = 1;
          options = { ..._TextureStyle.defaultOptions, ...options };
          this.addressMode = options.addressMode;
          this.addressModeU = options.addressModeU ?? this.addressModeU;
          this.addressModeV = options.addressModeV ?? this.addressModeV;
          this.addressModeW = options.addressModeW ?? this.addressModeW;
          this.scaleMode = options.scaleMode;
          this.magFilter = options.magFilter ?? this.magFilter;
          this.minFilter = options.minFilter ?? this.minFilter;
          this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
          this.lodMinClamp = options.lodMinClamp;
          this.lodMaxClamp = options.lodMaxClamp;
          this.compare = options.compare;
          this.maxAnisotropy = options.maxAnisotropy ?? 1;
        }
        set addressMode(value) {
          this.addressModeU = value;
          this.addressModeV = value;
          this.addressModeW = value;
        }
        get addressMode() {
          return this.addressModeU;
        }
        set wrapMode(value) {
          deprecation("8", "TextureStyle.wrapMode is now TextureStyle.addressMode");
          this.addressMode = value;
        }
        get wrapMode() {
          return this.addressMode;
        }
        set scaleMode(value) {
          this.magFilter = value;
          this.minFilter = value;
          this.mipmapFilter = value;
        }
        get scaleMode() {
          return this.magFilter;
        }
        set maxAnisotropy(value) {
          this._maxAnisotropy = Math.min(value, 16);
          if (this._maxAnisotropy > 1) {
            this.scaleMode = "linear";
          }
        }
        get maxAnisotropy() {
          return this._maxAnisotropy;
        }
        get resourceId() {
          return this._resourceId || this._generateResourceId();
        }
        update() {
          this.emit("change", this);
          this._resourceId = null;
        }
        _generateResourceId() {
          const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
          this._resourceId = createIdFromString(bigKey, "sampler");
          return this._resourceId;
        }
        destroy() {
          this.emit("destroy", this);
          this.removeAllListeners();
        }
      };
      TextureStyle = _TextureStyle;
      TextureStyle.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
  var _TextureSource, TextureSource;
  var init_TextureSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
      init_eventemitter3();
      init_uid();
      init_deprecation();
      init_TextureStyle();
      _TextureSource = class extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this.options = options;
          this.uid = uid("textureSource");
          this.resourceType = "textureSource";
          this.resourceId = uid("textureResource");
          this.uploadMethodId = "unknown";
          this._resolution = 1;
          this.pixelWidth = 1;
          this.pixelHeight = 1;
          this.width = 1;
          this.height = 1;
          this.sampleCount = 1;
          this.mipLevelCount = 1;
          this.autoGenerateMipmaps = false;
          this.format = "rgba8unorm-srgb";
          this.dimension = "2d";
          this.antialias = false;
          this.depthStencil = true;
          this.touched = 0;
          this._batchTick = -1;
          this._textureBindLocation = -1;
          options = { ..._TextureSource.defaultOptions, ...options };
          this.resource = options.resource;
          this._resolution = options.resolution;
          if (options.width) {
            this.pixelWidth = options.width * this._resolution;
          } else {
            this.pixelWidth = options.resource?.width ?? 1;
          }
          if (options.height) {
            this.pixelHeight = options.height * this._resolution;
          } else {
            this.pixelHeight = options.resource?.height ?? 1;
          }
          this.width = this.pixelWidth / this._resolution;
          this.height = this.pixelHeight / this._resolution;
          this.format = options.format;
          this.dimension = options.dimensions;
          this.mipLevelCount = options.mipLevelCount;
          this.autoGenerateMipmaps = options.autoGenerateMipmaps;
          this.sampleCount = options.sampleCount;
          this.antialias = options.antialias;
          this.alphaMode = options.alphaMode;
          const style = options.style ?? {};
          this.style = style instanceof TextureStyle ? style : new TextureStyle(style);
          this.destroyed = false;
        }
        get source() {
          return this;
        }
        get style() {
          return this._style;
        }
        set style(value) {
          if (this.style === value)
            return;
          this._style?.off("change", this._onStyleChange, this);
          this._style = value;
          this._style?.on("change", this._onStyleChange, this);
          this._onStyleChange();
        }
        _onStyleChange() {
          this.emit("styleChange", this);
        }
        update() {
          this.emit("update", this);
        }
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          if (this._style) {
            this._style.destroy();
            this._style = null;
          }
          this.uploadMethodId = null;
          this.resource = null;
          this.removeAllListeners();
        }
        unload() {
          this.resourceId++;
          this.emit("change", this);
          this.emit("unload", this);
        }
        get resourceWidth() {
          const { resource } = this;
          return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
        }
        get resourceHeight() {
          const { resource } = this;
          return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
        }
        get resolution() {
          return this._resolution;
        }
        set resolution(resolution) {
          if (this._resolution === resolution)
            return;
          this._resolution = resolution;
          this.width = this.pixelWidth / resolution;
          this.height = this.pixelHeight / resolution;
        }
        resize(width, height, resolution) {
          resolution = resolution || this._resolution;
          width = width || this.width;
          height = height || this.height;
          const newPixelWidth = Math.round(width * resolution);
          const newPixelHeight = Math.round(height * resolution);
          this.width = newPixelWidth / resolution;
          this.height = newPixelHeight / resolution;
          this._resolution = resolution;
          if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
            return;
          }
          this.pixelWidth = newPixelWidth;
          this.pixelHeight = newPixelHeight;
          this.emit("resize", this);
          this.resourceId++;
          this.emit("change", this);
        }
        set wrapMode(value) {
          deprecation(v8_0_0, "TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead.");
          this._style.wrapMode = value;
        }
        get wrapMode() {
          deprecation(v8_0_0, "TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead.");
          return this._style.wrapMode;
        }
        set scaleMode(value) {
          deprecation(v8_0_0, "TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead.");
          this._style.scaleMode = value;
        }
        get scaleMode() {
          deprecation(v8_0_0, "TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead.");
          return this._style.scaleMode;
        }
      };
      TextureSource = _TextureSource;
      TextureSource.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "no-premultiply-alpha",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: false,
        sampleCount: 1,
        antialias: false,
        style: {}
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
  var BufferImageSource;
  var init_BufferImageSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
      init_TextureSource();
      BufferImageSource = class extends TextureSource {
        constructor() {
          super(...arguments);
          this.uploadMethodId = "buffer";
        }
        static from(options) {
          const buffer = options.resource || new Float32Array(options.width * options.height * 4);
          let format = options.format;
          if (!format) {
            if (buffer instanceof Float32Array) {
              format = "rgba32float";
            } else if (buffer instanceof Int32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Uint32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Int16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Uint16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Int8Array) {
              format = "bgra8unorm";
            } else {
              format = "bgra8unorm";
            }
          }
          return new BufferImageSource({
            ...options,
            format
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/matrix/groupD8.mjs
  function init() {
    for (let i2 = 0; i2 < 16; i2++) {
      const row = [];
      rotationCayley.push(row);
      for (let j2 = 0; j2 < 16; j2++) {
        const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
        const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
        const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
        const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
        for (let k2 = 0; k2 < 16; k2++) {
          if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
            row.push(k2);
            break;
          }
        }
      }
    }
    for (let i2 = 0; i2 < 16; i2++) {
      const mat = new Matrix();
      mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
  var init_groupD8 = __esm({
    "node_modules/pixi-v8/lib/maths/matrix/groupD8.mjs"() {
      init_Matrix();
      ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
      uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
      vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
      vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
      rotationCayley = [];
      rotationMatrices = [];
      signum = Math.sign;
      init();
      groupD8 = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (ind) => ux[ind],
        uY: (ind) => uy[ind],
        vX: (ind) => vx[ind],
        vY: (ind) => vy[ind],
        inv: (rotation) => {
          if (rotation & 8) {
            return rotation & 15;
          }
          return -rotation & 7;
        },
        add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
        sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
        rotate180: (rotation) => rotation ^ 4,
        isVertical: (rotation) => (rotation & 3) === 2,
        byDirection: (dx, dy) => {
          if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
              return groupD8.S;
            }
            return groupD8.N;
          } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
              return groupD8.E;
            }
            return groupD8.W;
          } else if (dy > 0) {
            if (dx > 0) {
              return groupD8.SE;
            }
            return groupD8.SW;
          } else if (dx > 0) {
            return groupD8.NE;
          }
          return groupD8.NW;
        },
        matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
          const mat = rotationMatrices[groupD8.inv(rotation)];
          mat.tx = tx;
          mat.ty = ty;
          matrix.append(mat);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureLayout.mjs
  var TextureLayout;
  var init_TextureLayout = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureLayout.mjs"() {
      init_eventemitter3();
      init_groupD8();
      init_Rectangle();
      TextureLayout = class extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
          this.frame = options.frame || new Rectangle(0, 0, 1, 1);
          this.orig = options.orig || this.frame;
          this.rotate = options.rotate ?? 0;
          this.trim = options.trim;
          this.defaultAnchor = options.defaultAnchor;
          this.defaultBorders = options.defaultBorders;
          this.updateUvs();
        }
        updateUvs() {
          const uvs = this.uvs;
          const frame = this.frame;
          let rotate = this.rotate;
          if (rotate) {
            const w2 = frame.width / 2;
            const h2 = frame.height / 2;
            const cX = frame.x + w2;
            const cY = frame.y + h2;
            rotate = groupD8.add(rotate, groupD8.NW);
            uvs.x0 = cX + w2 * groupD8.uX(rotate);
            uvs.y0 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x1 = cX + w2 * groupD8.uX(rotate);
            uvs.y1 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x2 = cX + w2 * groupD8.uX(rotate);
            uvs.y2 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x3 = cX + w2 * groupD8.uX(rotate);
            uvs.y3 = cY + h2 * groupD8.uY(rotate);
          } else {
            uvs.x0 = frame.x;
            uvs.y0 = frame.y;
            uvs.x1 = frame.x + frame.width;
            uvs.y1 = frame.y;
            uvs.x2 = frame.x + frame.width;
            uvs.y2 = frame.y + frame.height;
            uvs.x3 = frame.x;
            uvs.y3 = frame.y + frame.height;
          }
        }
        update() {
          this.updateUvs();
          this.emit("update", this);
        }
        destroy() {
          this.emit("destroy", this);
          this.removeAllListeners();
          this.frame = null;
          this.orig = null;
          this.trim = null;
          this.defaultAnchor = null;
          this.uvs = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
  var tempMat, TextureMatrix;
  var init_TextureMatrix = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
      init_Matrix();
      tempMat = new Matrix();
      TextureMatrix = class {
        constructor(texture, clampMargin) {
          this.mapCoord = new Matrix();
          this.uClampFrame = new Float32Array(4);
          this.uClampOffset = new Float32Array(2);
          this._textureID = -1;
          this._updateID = 0;
          this.clampOffset = 0;
          this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
          this.isSimple = false;
          this.texture = texture;
        }
        get texture() {
          return this._texture;
        }
        set texture(value) {
          if (this.texture === value)
            return;
          this._texture?.removeListener("update", this.update, this);
          this._texture = value;
          this._texture.addListener("update", this.update, this);
          this.update();
        }
        multiplyUvs(uvs, out2) {
          if (out2 === void 0) {
            out2 = uvs;
          }
          const mat = this.mapCoord;
          for (let i2 = 0; i2 < uvs.length; i2 += 2) {
            const x2 = uvs[i2];
            const y2 = uvs[i2 + 1];
            out2[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
            out2[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
          }
          return out2;
        }
        update() {
          const tex = this._texture;
          this._updateID++;
          const uvs = tex.layout.uvs;
          this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
          const orig = tex.layout.orig;
          const trim = tex.layout.trim;
          if (trim) {
            tempMat.set(
              orig.width / trim.width,
              0,
              0,
              orig.height / trim.height,
              -trim.x / trim.width,
              -trim.y / trim.height
            );
            this.mapCoord.append(tempMat);
          }
          const texBase = tex.source;
          const frame = this.uClampFrame;
          const margin = this.clampMargin / texBase._resolution;
          const offset = this.clampOffset;
          frame[0] = (tex.frameX + margin + offset) / texBase.width;
          frame[1] = (tex.frameY + margin + offset) / texBase.height;
          frame[2] = (tex.frameX + tex.frameWidth - margin + offset) / texBase.width;
          frame[3] = (tex.frameY + tex.frameHeight - margin + offset) / texBase.height;
          this.uClampOffset[0] = offset / texBase.pixelWidth;
          this.uClampOffset[1] = offset / texBase.pixelHeight;
          this.isSimple = tex.frameWidth === texBase.width && tex.frameHeight === texBase.height && tex.layout.rotate === 0;
          return true;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/Texture.mjs
  var Texture;
  var init_Texture = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/Texture.mjs"() {
      init_eventemitter3();
      init_Cache();
      init_uid();
      init_deprecation();
      init_NOOP();
      init_BufferImageSource();
      init_TextureSource();
      init_TextureLayout();
      init_TextureMatrix();
      Texture = class extends eventemitter3_default {
        constructor({ source: source2, layout, label, frame } = {}) {
          super();
          this.id = uid("texture");
          this.styleSourceKey = 0;
          this.label = label;
          this.source = source2?.source ?? new TextureSource();
          layout = layout instanceof TextureLayout ? layout : new TextureLayout(layout);
          if (frame) {
            const { width, height } = this._source;
            layout.frame.x = frame.x / width;
            layout.frame.y = frame.y / height;
            layout.frame.width = frame.width / width;
            layout.frame.height = frame.height / height;
            layout.updateUvs();
          }
          this.layout = layout;
          this.destroyed = false;
        }
        static from(id) {
          if (typeof id === "string") {
            return Cache.get(id);
          } else if (id instanceof TextureSource) {
            return new Texture({ source: id });
          }
          return new Texture({
            source: new TextureSource(id)
          });
        }
        static fromBuffer(options) {
          return new Texture({
            source: BufferImageSource.from({
              ...options,
              style: {
                scaleMode: "nearest"
              }
            })
          });
        }
        set source(value) {
          if (this._source) {
            this._source.off("resize", this.onUpdate, this);
          }
          this._source = value;
          value.on("resize", this.onUpdate, this);
          this.emit("update", this);
        }
        get source() {
          return this._source;
        }
        get layout() {
          return this._layout;
        }
        set layout(value) {
          this._layout?.off("update", this.onUpdate, this);
          this._layout = value;
          value.on("update", this.onUpdate, this);
          this.emit("update", this);
        }
        get textureMatrix() {
          if (!this._textureMatrix) {
            this._textureMatrix = new TextureMatrix(this);
          }
          return this._textureMatrix;
        }
        set frameWidth(value) {
          this._layout.frame.width = value / this._source.width;
        }
        get frameWidth() {
          return this._source.pixelWidth / this._source._resolution * this._layout.frame.width;
        }
        set frameHeight(value) {
          this._layout.frame.height = value / this._source.height;
        }
        get frameHeight() {
          return this._source.pixelHeight / this._source._resolution * this._layout.frame.height;
        }
        set frameX(value) {
          if (value === 0) {
            this._layout.frame.x = 0;
            return;
          }
          this._layout.frame.x = this._source.width / value;
        }
        get frameX() {
          return this._source.width * this._layout.frame.x;
        }
        set frameY(value) {
          if (value === 0) {
            this._layout.frame.y = 0;
            return;
          }
          this._layout.frame.y = this._source.height / value;
        }
        get frameY() {
          return this._source.height * this._layout.frame.y;
        }
        get width() {
          return this._source.width * this._layout.orig.width;
        }
        get height() {
          return this._source.height * this._layout.orig.height;
        }
        destroy(destroySource = false) {
          if (this._layout) {
            this._layout.destroy();
            this._layout = null;
          }
          if (this._source) {
            if (destroySource) {
              this._source.destroy();
              this._source = null;
            }
          }
          this._textureMatrix = null;
          this.destroyed = true;
          this.emit("destroy", this);
          this.removeAllListeners();
        }
        onUpdate() {
          this.emit("update", this);
        }
        get baseTexture() {
          deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
          return this._source;
        }
      };
      Texture.EMPTY = new Texture({});
      Texture.EMPTY.label = "EMPTY";
      Texture.EMPTY.destroy = NOOP;
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/AbstractBitmapFont.mjs
  var AbstractBitmapFont;
  var init_AbstractBitmapFont = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/AbstractBitmapFont.mjs"() {
      init_eventemitter3();
      init_deprecation();
      AbstractBitmapFont = class extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.chars = /* @__PURE__ */ Object.create(null);
          this.lineHeight = 0;
          this.fontFamily = "";
          this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
          this.baseLineOffset = 0;
          this.distanceField = { type: "none", range: 0 };
          this.pages = [];
          this.baseMeasurementFontSize = 100;
          this.baseRenderedFontSize = 100;
        }
        get font() {
          deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
          return this.fontFamily;
        }
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        get size() {
          deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
          return this.fontMetrics.fontSize;
        }
        get distanceFieldRange() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
          return this.distanceField.range;
        }
        get distanceFieldType() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
          return this.distanceField.type;
        }
        destroy() {
          this.emit("destroy", this);
          this.removeAllListeners();
          for (const i2 in this.chars) {
            this.chars[i2].texture.destroy();
          }
          this.chars = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/BitmapFont.mjs
  var BitmapFont;
  var init_BitmapFont = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/BitmapFont.mjs"() {
      init_Rectangle();
      init_Texture();
      init_AbstractBitmapFont();
      BitmapFont = class extends AbstractBitmapFont {
        constructor(options) {
          super();
          const { textures, data } = options;
          Object.keys(data.pages).forEach((key) => {
            const pageData = data.pages[parseInt(key, 10)];
            const texture = textures[pageData.id];
            this.pages.push({ texture });
          });
          Object.keys(data.chars).forEach((key) => {
            const charData = data.chars[key];
            const textureSource = textures[charData.page].source;
            const frame = new Rectangle(
              charData.x / textureSource.width,
              charData.y / textureSource.height,
              charData.width / textureSource.width,
              charData.height / textureSource.height
            );
            const texture = new Texture({
              source: textureSource,
              layout: {
                frame
              }
            });
            this.chars[key] = {
              id: key.codePointAt(0),
              xOffset: charData.xOffset,
              yOffset: charData.yOffset,
              xAdvance: charData.xAdvance,
              kerning: charData.kerning ?? {},
              texture
            };
          });
          this.baseRenderedFontSize = data.fontSize;
          const writable = this;
          writable.baseMeasurementFontSize = data.fontSize;
          writable.fontMetrics = {
            ascent: 0,
            descent: 0,
            fontSize: data.fontSize
          };
          writable.baseLineOffset = data.baseLineOffset;
          writable.lineHeight = data.lineHeight;
          writable.fontFamily = data.fontFamily;
          writable.distanceField = data.distanceField ?? {
            type: "none",
            range: 0
          };
        }
        destroy() {
          super.destroy();
          for (let i2 = 0; i2 < this.pages.length; i2++) {
            const { texture } = this.pages[i2];
            texture.destroy(true);
          }
          this.pages = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/asset/textFormat.mjs
  var TextFormat;
  var init_textFormat = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/asset/textFormat.mjs"() {
      TextFormat = {
        test(data) {
          return typeof data === "string" && data.startsWith("info face=");
        },
        parse(txt) {
          const items = txt.match(/^[a-z]+\s+.+$/gm);
          const rawData = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
          };
          for (const i2 in items) {
            const name = items[i2].match(/^[a-z]+/gm)[0];
            const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
            const itemData = {};
            for (const i22 in attributeList) {
              const split = attributeList[i22].split("=");
              const key = split[0];
              const strValue = split[1].replace(/"/gm, "");
              const floatValue = parseFloat(strValue);
              const value = isNaN(floatValue) ? strValue : floatValue;
              itemData[key] = value;
            }
            rawData[name].push(itemData);
          }
          const font = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
          };
          const [info] = rawData.info;
          const [common] = rawData.common;
          const [distanceField] = rawData.distanceField ?? [];
          if (distanceField) {
            font.distanceField = {
              range: parseInt(distanceField.distanceRange, 10),
              type: distanceField.fieldType
            };
          }
          font.fontSize = parseInt(info.size, 10);
          font.fontFamily = info.face;
          font.lineHeight = parseInt(common.lineHeight, 10);
          const page = rawData.page;
          for (let i2 = 0; i2 < page.length; i2++) {
            font.pages.push({
              id: parseInt(page[i2].id, 10) || 0,
              file: page[i2].file
            });
          }
          const map2 = {};
          font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
          const char = rawData.char;
          for (let i2 = 0; i2 < char.length; i2++) {
            const charNode = char[i2];
            const id = parseInt(charNode.id, 10);
            let letter = charNode.letter ?? charNode.char;
            if (letter === "space")
              letter = " ";
            map2[id] = letter;
            font.chars[letter] = {
              id,
              page: parseInt(charNode.page, 10) || 0,
              x: parseInt(charNode.x, 10),
              y: parseInt(charNode.y, 10),
              width: parseInt(charNode.width, 10),
              height: parseInt(charNode.height, 10),
              xOffset: parseInt(charNode.xoffset, 10),
              yOffset: parseInt(charNode.yoffset, 10),
              xAdvance: parseInt(charNode.xadvance, 10),
              kerning: {}
            };
          }
          const kerning = rawData.kerning || [];
          for (let i2 = 0; i2 < kerning.length; i2++) {
            const first = parseInt(kerning[i2].first, 10);
            const second = parseInt(kerning[i2].second, 10);
            const amount = parseInt(kerning[i2].amount, 10);
            font.chars[map2[second]].kerning[map2[first]] = amount;
          }
          return font;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/asset/xmlFormat.mjs
  var XMLFormat;
  var init_xmlFormat = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/asset/xmlFormat.mjs"() {
      XMLFormat = {
        test(data) {
          const xml = data;
          return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
        },
        parse(xml) {
          const data = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
          };
          const info = xml.getElementsByTagName("info")[0];
          const common = xml.getElementsByTagName("common")[0];
          const distanceField = xml.getElementsByTagName("distanceField")[0];
          if (distanceField) {
            data.distanceField = {
              type: distanceField.getAttribute("fieldType"),
              range: parseInt(distanceField.getAttribute("distanceRange"), 10)
            };
          }
          const page = xml.getElementsByTagName("page");
          const char = xml.getElementsByTagName("char");
          const kerning = xml.getElementsByTagName("kerning");
          data.fontSize = parseInt(info.getAttribute("size"), 10);
          data.fontFamily = info.getAttribute("face");
          data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
          for (let i2 = 0; i2 < page.length; i2++) {
            data.pages.push({
              id: parseInt(page[i2].getAttribute("id"), 10) || 0,
              file: page[i2].getAttribute("file")
            });
          }
          const map2 = {};
          data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
          for (let i2 = 0; i2 < char.length; i2++) {
            const charNode = char[i2];
            const id = parseInt(charNode.getAttribute("id"), 10);
            let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char");
            if (letter === "space")
              letter = " ";
            map2[id] = letter;
            data.chars[letter] = {
              id,
              page: parseInt(charNode.getAttribute("page"), 10) || 0,
              x: parseInt(charNode.getAttribute("x"), 10),
              y: parseInt(charNode.getAttribute("y"), 10),
              width: parseInt(charNode.getAttribute("width"), 10),
              height: parseInt(charNode.getAttribute("height"), 10),
              xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
              yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
              xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
              kerning: {}
            };
          }
          for (let i2 = 0; i2 < kerning.length; i2++) {
            const first = parseInt(kerning[i2].getAttribute("first"), 10);
            const second = parseInt(kerning[i2].getAttribute("second"), 10);
            const amount = parseInt(kerning[i2].getAttribute("amount"), 10);
            data.chars[map2[second]].kerning[map2[first]] = amount;
          }
          return data;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/asset/xmlStringFormat.mjs
  var XMLStringFormat;
  var init_xmlStringFormat = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/asset/xmlStringFormat.mjs"() {
      init_settings();
      init_xmlFormat();
      XMLStringFormat = {
        test(data) {
          if (typeof data === "string" && data.includes("<font>")) {
            return XMLFormat.test(settings.ADAPTER.parseXML(data));
          }
          return false;
        },
        parse(data) {
          return XMLFormat.parse(settings.ADAPTER.parseXML(data));
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/asset/loadBitmapFont.mjs
  var validExtensions, bitmapFontCachePlugin, xmlBitmapFontLoader;
  var init_loadBitmapFont = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/asset/loadBitmapFont.mjs"() {
      init_LoaderParser();
      init_copySearchParams();
      init_Extensions();
      init_settings();
      init_path();
      init_BitmapFont();
      init_textFormat();
      init_xmlStringFormat();
      validExtensions = [".xml", ".fnt"];
      bitmapFontCachePlugin = {
        extension: ExtensionType.CacheParser,
        test: (asset) => asset instanceof BitmapFont,
        getCacheableAssets(keys, asset) {
          const out2 = {};
          keys.forEach((key) => {
            out2[key] = asset;
          });
          out2[asset.fontFamily] = asset;
          return out2;
        }
      };
      xmlBitmapFontLoader = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        test(url) {
          return validExtensions.includes(path.extname(url).toLowerCase());
        },
        async testParse(data) {
          return TextFormat.test(data) || XMLStringFormat.test(data);
        },
        async parse(asset, data, loader) {
          const bitmapFontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
          const { src } = data;
          const { pages } = bitmapFontData;
          const textureUrls = [];
          for (let i2 = 0; i2 < pages.length; ++i2) {
            const pageFile = pages[i2].file;
            let imagePath = path.join(path.dirname(src), pageFile);
            imagePath = copySearchParams(imagePath, src);
            textureUrls.push(imagePath);
          }
          const loadedTextures = await loader.load(textureUrls);
          const textures = textureUrls.map((url) => loadedTextures[url]);
          const bitmapFont = new BitmapFont({
            data: bitmapFontData,
            textures
          });
          return bitmapFont;
        },
        async load(url, _options) {
          const response = await settings.ADAPTER.fetch(url);
          return await response.text();
        },
        unload(bitmapFont) {
          bitmapFont.destroy();
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/cache/parsers/cacheTextureArray.mjs
  var cacheTextureArray;
  var init_cacheTextureArray = __esm({
    "node_modules/pixi-v8/lib/assets/cache/parsers/cacheTextureArray.mjs"() {
      init_Extensions();
      init_Texture();
      cacheTextureArray = {
        extension: ExtensionType.CacheParser,
        test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
        getCacheableAssets: (keys, asset) => {
          const out2 = {};
          keys.forEach((key) => {
            asset.forEach((item, i2) => {
              out2[key + (i2 === 0 ? "" : i2 + 1)] = item;
            });
          });
          return out2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/utils/testImageFormat.mjs
  async function testImageFormat(imageData) {
    if ("Image" in globalThis) {
      return new Promise((resolve) => {
        const image = new Image();
        image.onload = () => {
          resolve(true);
        };
        image.onerror = () => {
          resolve(false);
        };
        image.src = imageData;
      });
    }
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const blob = await (await fetch(imageData)).blob();
        await createImageBitmap(blob);
      } catch (e2) {
        return false;
      }
      return true;
    }
    return false;
  }
  var init_testImageFormat = __esm({
    "node_modules/pixi-v8/lib/assets/detections/utils/testImageFormat.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectAvif.mjs
  var detectAvif;
  var init_detectAvif = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectAvif.mjs"() {
      init_Extensions();
      init_testImageFormat();
      detectAvif = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 1
        },
        test: async () => testImageFormat(
          "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
        ),
        add: async (formats) => [...formats, "avif"],
        remove: async (formats) => formats.filter((f2) => f2 !== "avif")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectDefaults.mjs
  var imageFormats, detectDefaults;
  var init_detectDefaults = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectDefaults.mjs"() {
      init_Extensions();
      imageFormats = ["png", "jpg", "jpeg"];
      detectDefaults = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: -1
        },
        test: () => Promise.resolve(true),
        add: async (formats) => [...formats, ...imageFormats],
        remove: async (formats) => formats.filter((f2) => !imageFormats.includes(f2))
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/utils/testVideoFormat.mjs
  function testVideoFormat(mimeType) {
    if (inWorker) {
      return false;
    }
    const video = document.createElement("video");
    return video.canPlayType(mimeType) !== "";
  }
  var inWorker;
  var init_testVideoFormat = __esm({
    "node_modules/pixi-v8/lib/assets/detections/utils/testVideoFormat.mjs"() {
      inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectMp4.mjs
  var detectMp4;
  var init_detectMp4 = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectMp4.mjs"() {
      init_Extensions();
      init_testVideoFormat();
      detectMp4 = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/mp4"),
        add: async (formats) => [...formats, "mp4", "m4v"],
        remove: async (formats) => formats.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectOgv.mjs
  var detectOgv;
  var init_detectOgv = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectOgv.mjs"() {
      init_Extensions();
      init_testVideoFormat();
      detectOgv = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/ogg"),
        add: async (formats) => [...formats, "ogv"],
        remove: async (formats) => formats.filter((f2) => f2 !== "ogv")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectWebm.mjs
  var detectWebm;
  var init_detectWebm = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectWebm.mjs"() {
      init_Extensions();
      init_testVideoFormat();
      detectWebm = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/webm"),
        add: async (formats) => [...formats, "webm"],
        remove: async (formats) => formats.filter((f2) => f2 !== "webm")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectWebp.mjs
  var detectWebp;
  var init_detectWebp = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectWebp.mjs"() {
      init_Extensions();
      init_testImageFormat();
      detectWebp = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testImageFormat(
          "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
        ),
        add: async (formats) => [...formats, "webp"],
        remove: async (formats) => formats.filter((f2) => f2 !== "webp")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/checkDataUrl.mjs
  function checkDataUrl(url, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes) {
        if (url.startsWith(`data:${mime}`))
          return true;
      }
      return false;
    }
    return url.startsWith(`data:${mimes}`);
  }
  var init_checkDataUrl = __esm({
    "node_modules/pixi-v8/lib/assets/utils/checkDataUrl.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/checkExtension.mjs
  function checkExtension(url, extension) {
    const tempURL = url.split("?")[0];
    const ext = path.extname(tempURL).toLowerCase();
    if (Array.isArray(extension)) {
      return extension.includes(ext);
    }
    return ext === extension;
  }
  var init_checkExtension = __esm({
    "node_modules/pixi-v8/lib/assets/utils/checkExtension.mjs"() {
      init_path();
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/loadJson.mjs
  var validJSONExtension, validJSONMIME, loadJson;
  var init_loadJson = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/loadJson.mjs"() {
      init_Extensions();
      init_settings();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validJSONExtension = ".json";
      validJSONMIME = "application/json";
      loadJson = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        name: "loadJson",
        test(url) {
          return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
        },
        async load(url) {
          const response = await settings.ADAPTER.fetch(url);
          const json = await response.json();
          return json;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/loadTxt.mjs
  var validTXTExtension, validTXTMIME, loadTxt;
  var init_loadTxt = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/loadTxt.mjs"() {
      init_Extensions();
      init_settings();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validTXTExtension = ".txt";
      validTXTMIME = "text/plain";
      loadTxt = {
        name: "loadTxt",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        test(url) {
          return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
        },
        async load(url) {
          const response = await settings.ADAPTER.fetch(url);
          const txt = await response.text();
          return txt;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/loadWebFont.mjs
  function getFontFamilyName(url) {
    const ext = path.extname(url);
    const name = path.basename(url, ext);
    const nameWithSpaces = name.replace(/(-|_)/g, " ");
    const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
    let valid = nameTokens.length > 0;
    for (const token of nameTokens) {
      if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
        valid = false;
        break;
      }
    }
    let fontFamilyName = nameTokens.join(" ");
    if (!valid) {
      fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
    }
    return fontFamilyName;
  }
  function encodeURIWhenNeeded(uri) {
    if (validURICharactersRegex.test(uri)) {
      return uri;
    }
    return encodeURI(uri);
  }
  var validWeights, validFontExtensions, validFontMIMEs, CSS_IDENT_TOKEN_REGEX, validURICharactersRegex, loadWebFont;
  var init_loadWebFont = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/loadWebFont.mjs"() {
      init_Extensions();
      init_settings();
      init_warn();
      init_path();
      init_Cache();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validWeights = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
      ];
      validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
      validFontMIMEs = [
        "font/ttf",
        "font/otf",
        "font/woff",
        "font/woff2"
      ];
      CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
      validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
      loadWebFont = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        name: "loadWebFont",
        test(url) {
          return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
        },
        async load(url, options) {
          const fonts = settings.ADAPTER.getFontFaceSet();
          if (fonts) {
            const fontFaces = [];
            const name = options.data?.family ?? getFontFamilyName(url);
            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
            const data = options.data ?? {};
            for (let i2 = 0; i2 < weights.length; i2++) {
              const weight = weights[i2];
              const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {
                ...data,
                weight
              });
              await font.load();
              fonts.add(font);
              fontFaces.push(font);
            }
            Cache.set(name, {
              url,
              fontFaces
            });
            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
          }
          warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
          return null;
        },
        unload(font) {
          (Array.isArray(font) ? font : [font]).forEach((t2) => {
            Cache.remove(t2.family);
            settings.ADAPTER.getFontFaceSet().delete(t2);
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
  function SVGToGraphicsPath(svgPath, path2) {
    const commands = svgPath.match(/[a-df-z][^a-df-z]*/gi);
    const data = svgPath.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
    const betterCommands = [];
    commands.forEach((command) => {
      const data2 = command.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
      const type = command[0];
      let totalInstructions = 1;
      if (data2) {
        totalInstructions = data2.length / commandSizeMap[type.toLowerCase()];
      }
      for (let i2 = 0; i2 < totalInstructions; i2++) {
        betterCommands.push(type);
      }
    });
    let dataIndex = 0;
    let lastX = 0;
    let lastY = 0;
    for (let i2 = 0; i2 < betterCommands.length; i2++) {
      const type = betterCommands[i2];
      switch (type) {
        case "M":
          lastX = data[dataIndex++];
          lastY = data[dataIndex++];
          path2.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += data[dataIndex++];
          lastY += data[dataIndex++];
          path2.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = data[dataIndex++];
          path2.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += data[dataIndex++];
          path2.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = data[dataIndex++];
          path2.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += data[dataIndex++];
          path2.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = data[dataIndex++];
          lastY = data[dataIndex++];
          path2.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += data[dataIndex++];
          lastY += data[dataIndex++];
          path2.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = data[dataIndex + 4];
          lastY = data[dataIndex + 5];
          path2.bezierCurveTo(
            data[dataIndex],
            data[dataIndex + 1],
            data[dataIndex + 2],
            data[dataIndex + 3],
            lastX,
            lastY
          );
          dataIndex += 6;
          break;
        case "c":
          path2.bezierCurveTo(
            lastX + data[dataIndex],
            lastY + data[dataIndex + 1],
            lastX + data[dataIndex + 2],
            lastY + data[dataIndex + 3],
            lastX + data[dataIndex + 4],
            lastY + data[dataIndex + 5]
          );
          lastX += data[dataIndex + 4];
          lastY += data[dataIndex + 5];
          dataIndex += 6;
          break;
        case "S":
          lastX = data[dataIndex + 2];
          lastY = data[dataIndex + 3];
          path2.bezierCurveToShort(
            data[dataIndex],
            data[dataIndex + 1],
            lastX,
            lastY
          );
          dataIndex += 4;
          break;
        case "s":
          path2.bezierCurveToShort(
            lastX + data[dataIndex],
            lastY + data[dataIndex + 1],
            lastX + data[dataIndex + 2],
            lastY + data[dataIndex + 3]
          );
          lastX += data[dataIndex + 2];
          lastY += data[dataIndex + 3];
          dataIndex += 4;
          break;
        case "Q":
          lastX = data[dataIndex + 2];
          lastY = data[dataIndex + 3];
          path2.quadraticCurveTo(
            data[dataIndex],
            data[dataIndex + 1],
            lastX,
            lastY
          );
          dataIndex += 4;
          break;
        case "q":
          path2.quadraticCurveTo(
            lastX + data[dataIndex],
            lastY + data[dataIndex + 1],
            lastX + data[dataIndex + 2],
            lastY + data[dataIndex + 3]
          );
          lastX += data[dataIndex + 2];
          lastY += data[dataIndex + 3];
          dataIndex += 4;
          break;
        case "T":
          lastX = data[dataIndex++];
          lastY = data[dataIndex++];
          path2.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "t":
          lastX += data[dataIndex++];
          lastY += data[dataIndex++];
          path2.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "A":
          lastX = data[dataIndex + 5];
          lastY = data[dataIndex + 6];
          path2.arcToSvg(
            data[dataIndex],
            data[dataIndex + 1],
            data[dataIndex + 2],
            data[dataIndex + 3],
            data[dataIndex + 4],
            lastX,
            lastY
          );
          dataIndex += 7;
          break;
        case "a":
          lastX += data[dataIndex + 5];
          lastY += data[dataIndex + 6];
          path2.arcToSvg(
            data[dataIndex],
            data[dataIndex + 1],
            data[dataIndex + 2],
            data[dataIndex + 3],
            data[dataIndex + 4],
            lastX,
            lastY
          );
          dataIndex += 7;
          break;
        case "Z":
        case "z":
          path2.closePath();
          break;
        default:
          warn(`Unknown SVG path command: ${type}`);
      }
    }
    return path2;
  }
  var commandSizeMap;
  var init_SVGToGraphicsPath = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
      init_warn();
      commandSizeMap = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/Circle.mjs
  var Circle;
  var init_Circle = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/Circle.mjs"() {
      init_Rectangle();
      Circle = class {
        constructor(x2 = 0, y2 = 0, radius = 0) {
          this.type = "circle";
          this.x = x2;
          this.y = y2;
          this.radius = radius;
        }
        clone() {
          return new Circle(this.x, this.y, this.radius);
        }
        contains(x2, y2) {
          if (this.radius <= 0) {
            return false;
          }
          const r2 = this.radius * this.radius;
          let dx = this.x - x2;
          let dy = this.y - y2;
          dx *= dx;
          dy *= dy;
          return dx + dy <= r2;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x - this.radius;
          out2.y = this.y - this.radius;
          out2.width = this.radius * 2;
          out2.height = this.radius * 2;
          return out2;
        }
        copyFrom(circle) {
          this.x = circle.x;
          this.y = circle.y;
          this.radius = circle.radius;
          return this;
        }
        copyTo(circle) {
          circle.copyFrom(this);
          return circle;
        }
        toString() {
          return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/Ellipse.mjs
  var Ellipse;
  var init_Ellipse = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/Ellipse.mjs"() {
      init_Rectangle();
      Ellipse = class {
        constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
          this.type = "ellipse";
          this.x = x2;
          this.y = y2;
          this.halfWidth = halfWidth;
          this.halfHeight = halfHeight;
        }
        clone() {
          return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        contains(x2, y2) {
          if (this.halfWidth <= 0 || this.halfHeight <= 0) {
            return false;
          }
          let normx = (x2 - this.x) / this.halfWidth;
          let normy = (y2 - this.y) / this.halfHeight;
          normx *= normx;
          normy *= normy;
          return normx + normy <= 1;
        }
        getBounds() {
          return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);
        }
        copyFrom(ellipse) {
          this.x = ellipse.x;
          this.y = ellipse.y;
          this.halfWidth = ellipse.halfWidth;
          this.halfHeight = ellipse.halfHeight;
          return this;
        }
        copyTo(ellipse) {
          ellipse.copyFrom(this);
          return ellipse;
        }
        toString() {
          return `[@pixi/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/Polygon.mjs
  var Polygon;
  var init_Polygon = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/Polygon.mjs"() {
      init_Rectangle();
      Polygon = class {
        constructor(...points) {
          this.type = "polygon";
          let flat = Array.isArray(points[0]) ? points[0] : points;
          if (typeof flat[0] !== "number") {
            const p2 = [];
            for (let i2 = 0, il = flat.length; i2 < il; i2++) {
              p2.push(flat[i2].x, flat[i2].y);
            }
            flat = p2;
          }
          this.points = flat;
          this.closePath = true;
        }
        clone() {
          const points = this.points.slice();
          const polygon = new Polygon(points);
          polygon.closePath = this.closePath;
          return polygon;
        }
        contains(x2, y2) {
          let inside = false;
          const length = this.points.length / 2;
          for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
            const xi = this.points[i2 * 2];
            const yi = this.points[i2 * 2 + 1];
            const xj = this.points[j2 * 2];
            const yj = this.points[j2 * 2 + 1];
            const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
            if (intersect) {
              inside = !inside;
            }
          }
          return inside;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          const points = this.points;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
            const x2 = points[i2];
            const y2 = points[i2 + 1];
            minX = x2 < minX ? x2 : minX;
            maxX = x2 > maxX ? x2 : maxX;
            minY = y2 < minY ? y2 : minY;
            maxY = y2 > maxY ? y2 : maxY;
          }
          out2.x = minX;
          out2.width = maxX - minX;
          out2.y = minY;
          out2.height = maxY - minY;
          return out2;
        }
        copyFrom(polygon) {
          this.points = polygon.points.slice();
          this.closePath = polygon.closePath;
          return this;
        }
        copyTo(polygon) {
          polygon.copyFrom(this);
          return polygon;
        }
        toString() {
          return `[@pixi/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
        }
        get lastX() {
          return this.points[this.points.length - 2];
        }
        get lastY() {
          return this.points[this.points.length - 1];
        }
        get x() {
          return this.points[this.points.length - 2];
        }
        get y() {
          return this.points[this.points.length - 1];
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/RoundedRectangle.mjs
  var RoundedRectangle;
  var init_RoundedRectangle = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/RoundedRectangle.mjs"() {
      init_Rectangle();
      RoundedRectangle = class {
        constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
          this.type = "roundedRectangle";
          this.x = x2;
          this.y = y2;
          this.width = width;
          this.height = height;
          this.radius = radius;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x;
          out2.y = this.y;
          out2.width = this.width;
          out2.height = this.height;
          return out2;
        }
        clone() {
          return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        }
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 <= this.x + this.width) {
            if (y2 >= this.y && y2 <= this.y + this.height) {
              const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
              if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
                return true;
              }
              let dx = x2 - (this.x + radius);
              let dy = y2 - (this.y + radius);
              const radius2 = radius * radius;
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + this.width - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dy = y2 - (this.y + this.height - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
            }
          }
          return false;
        }
        toString() {
          return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
  function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY) {
    const scale = 1;
    let distanceTolerance = PATH_DISTANCE_EPSILON / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
      let dx = x4 - x1;
      let dy = y4 - y1;
      const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
      const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
      let da1;
      let da2;
      if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          const a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < mAngleTolerance) {
            points.push(x1234, y1234);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
            if (da2 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else if (d2 > FLT_EPSILON) {
        if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
          }
        }
      } else if (d3 > FLT_EPSILON) {
        if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else {
        dx = x1234 - (x1 + x4) / 2;
        dy = y1234 - (y1 + y4) / 2;
        if (dx * dx + dy * dy <= distanceTolerance) {
          points.push(x1234, y1234);
          return;
        }
      }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
  var init_buildAdaptiveBezier = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
      RECURSION_LIMIT = 8;
      FLT_EPSILON = 11920929e-14;
      PATH_DISTANCE_EPSILON = 1;
      curveAngleToleranceEpsilon = 0.01;
      mAngleTolerance = 0;
      mCuspLimit = 0;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
  function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY) {
    const scale = 1;
    let distanceTolerance = PATH_DISTANCE_EPSILON2 / scale;
    distanceTolerance *= distanceTolerance;
    begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT2) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx = x3 - x1;
    let dy = y3 - y1;
    const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
    if (d2 > FLT_EPSILON2) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
          points.push(x123, y123);
          return;
        }
        let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da >= pi)
          da = 2 * pi - da;
        if (da < mAngleTolerance2) {
          points.push(x123, y123);
          return;
        }
      }
    } else {
      dx = x123 - (x1 + x3) / 2;
      dy = y123 - (y1 + y3) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x123, y123);
        return;
      }
    }
    recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
  var init_buildAdaptiveQuadratic = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
      RECURSION_LIMIT2 = 8;
      FLT_EPSILON2 = 11920929e-14;
      PATH_DISTANCE_EPSILON2 = 1;
      curveAngleToleranceEpsilon2 = 0.01;
      mAngleTolerance2 = 0;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArc.mjs
  function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
    let dist = Math.abs(start - end);
    if (!clockwise && start > end) {
      dist = 2 * Math.PI - dist;
    } else if (clockwise && end > start) {
      dist = 2 * Math.PI - dist;
    }
    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
    steps = Math.max(steps, 3);
    let f2 = dist / steps;
    let t2 = start;
    f2 *= clockwise ? -1 : 1;
    for (let i2 = 0; i2 < steps + 1; i2++) {
      const cs = Math.cos(t2);
      const sn = Math.sin(t2);
      const nx = x2 + cs * radius;
      const ny = y2 + sn * radius;
      points.push(nx, ny);
      t2 += f2;
    }
  }
  var init_buildArc = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
  function buildArcTo(points, x1, y1, x2, y2, radius) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    buildArc(
      points,
      cx + x1,
      cy + y1,
      radius,
      startAngle,
      endAngle,
      b1 * a2 > b2 * a1
    );
  }
  var init_buildArcTo = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
      init_buildArc();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
  function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
      {
        x: x1 - y1 * a2,
        y: y1 + x1 * a2
      },
      {
        x: x2 + y2 * a2,
        y: y2 - x2 * a2
      },
      {
        x: x2,
        y: y2
      }
    ];
  }
  function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
      return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    getArcCenter(
      px,
      py,
      cx,
      cy,
      rx,
      ry,
      largeArcFlag,
      sweepFlag,
      sinPhi,
      cosPhi,
      pxp,
      pyp,
      out
    );
    let { ang1, ang2 } = out;
    const { centerX, centerY } = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = { x: 0, y: 0 };
    for (let i2 = 0; i2 < segments; i2++) {
      const curve = approxUnitArc(ang1, ang2);
      const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      buildAdaptiveBezier(
        points,
        lastX,
        lastY,
        x1,
        y1,
        x2,
        y2,
        x3,
        y3
      );
      lastX = x3;
      lastY = y3;
      ang1 += ang2;
    }
  }
  var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
  var init_buildArcToSvg = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
      init_buildAdaptiveBezier();
      TAU = Math.PI * 2;
      out = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
      };
      mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
        x2 *= rx;
        y2 *= ry;
        const xp = cosPhi * x2 - sinPhi * y2;
        const yp = sinPhi * x2 + cosPhi * y2;
        out2.x = xp + centerX;
        out2.y = yp + centerY;
        return out2;
      };
      vectorAngle = (ux2, uy2, vx2, vy2) => {
        const sign = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
        let dot = ux2 * vx2 + uy2 * vy2;
        if (dot > 1) {
          dot = 1;
        }
        if (dot < -1) {
          dot = -1;
        }
        return sign * Math.acos(dot);
      };
      getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
        const rxSq = Math.pow(rx, 2);
        const rySq = Math.pow(ry, 2);
        const pxpSq = Math.pow(pxp, 2);
        const pypSq = Math.pow(pyp, 2);
        let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
        if (radicant < 0) {
          radicant = 0;
        }
        radicant /= rxSq * pypSq + rySq * pxpSq;
        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
        const centerXp = radicant * rx / ry * pyp;
        const centerYp = radicant * -ry / rx * pxp;
        const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
        const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
        const vx1 = (pxp - centerXp) / rx;
        const vy1 = (pyp - centerYp) / ry;
        const vx2 = (-pxp - centerXp) / rx;
        const vy2 = (-pyp - centerYp) / ry;
        const ang1 = vectorAngle(1, 0, vx1, vy1);
        let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
        if (sweepFlag === 0 && ang2 > 0) {
          ang2 -= TAU;
        }
        if (sweepFlag === 1 && ang2 < 0) {
          ang2 += TAU;
        }
        out2.centerX = centerX;
        out2.centerY = centerY;
        out2.ang1 = ang1;
        out2.ang2 = ang2;
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/path/ShapePath.mjs
  var tempRectangle, ShapePath;
  var init_ShapePath = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/path/ShapePath.mjs"() {
      init_Circle();
      init_Ellipse();
      init_Polygon();
      init_Rectangle();
      init_RoundedRectangle();
      init_Bounds();
      init_buildAdaptiveBezier();
      init_buildAdaptiveQuadratic();
      init_buildArc();
      init_buildArcTo();
      init_buildArcToSvg();
      tempRectangle = new Rectangle();
      ShapePath = class {
        constructor(graphicsPath2D) {
          this.shapePrimitives = [];
          this._currentPoly = null;
          this._bounds = new Bounds();
          this._graphicsPath2D = graphicsPath2D;
        }
        moveTo(x2, y2) {
          this.startPoly(x2, y2);
          return this;
        }
        lineTo(x2, y2) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          const fromX = points[points.length - 2];
          const fromY = points[points.length - 1];
          if (fromX !== x2 || fromY !== y2) {
            points.push(x2, y2);
          }
          return this;
        }
        arc(x2, y2, radius, startAngle, endAngle, anticlockwise) {
          this._ensurePoly(false);
          const points = this._currentPoly.points;
          buildArc(points, x2, y2, radius, startAngle, endAngle, anticlockwise);
          return this;
        }
        arcTo(x1, y1, x2, y2, radius) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          buildArcTo(points, x1, y1, x2, y2, radius);
          return this;
        }
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          const points = this._currentPoly.points;
          buildArcToSvg(
            points,
            this._currentPoly.lastX,
            this._currentPoly.lastY,
            x2,
            y2,
            rx,
            ry,
            xAxisRotation,
            largeArcFlag,
            sweepFlag
          );
          return this;
        }
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveBezier(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            cp2x,
            cp2y,
            x2,
            y2
          );
          return this;
        }
        quadraticCurveTo(cp1x, cp1y, x2, y2) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveQuadratic(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            x2,
            y2
          );
          return this;
        }
        closePath() {
          this.endPoly(true);
          return this;
        }
        addPath(path2, transform) {
          this.endPoly();
          if (transform && !transform.isIdentity()) {
            path2 = path2.clone(true);
            path2.transform(transform);
          }
          for (let i2 = 0; i2 < path2.instructions.length; i2++) {
            const instruction = path2.instructions[i2];
            this[instruction.action](...instruction.data);
          }
          return this;
        }
        finish(closePath = false) {
          this.endPoly(closePath);
        }
        rect(x2, y2, w2, h2, transform) {
          this.drawShape(new Rectangle(x2, y2, w2, h2), transform);
          return this;
        }
        circle(x2, y2, radius, transform) {
          this.drawShape(new Circle(x2, y2, radius), transform);
          return this;
        }
        poly(points, close, transform) {
          const polygon = new Polygon(points);
          polygon.closePath = close;
          this.drawShape(polygon, transform);
        }
        ellipse(x2, y2, radiusX, radiusY, transform) {
          this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform);
          return this;
        }
        roundRect(x2, y2, w2, h2, radii, transform) {
          this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radii), transform);
          return this;
        }
        drawShape(shape, matrix) {
          this.endPoly();
          this.shapePrimitives.push({ shape, transform: matrix });
          return this;
        }
        startPoly(x2, y2) {
          let currentPoly = this._currentPoly;
          if (currentPoly) {
            this.endPoly();
          }
          currentPoly = new Polygon();
          currentPoly.points.push(x2, y2);
          this._currentPoly = currentPoly;
          return this;
        }
        endPoly(closePath = false) {
          const shape = this._currentPoly;
          if (shape && shape.points.length > 2) {
            shape.closePath = closePath;
            this.shapePrimitives.push({ shape });
          }
          this._currentPoly = null;
          return this;
        }
        _ensurePoly(start = true) {
          if (this._currentPoly)
            return;
          this._currentPoly = new Polygon();
          if (start) {
            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (lastShape) {
              let lx = lastShape.shape.x;
              let ly = lastShape.shape.y;
              if (lastShape.transform.isIdentity()) {
                const t2 = lastShape.transform;
                const tempX = lx;
                lx = t2.a * lx + t2.c * ly + t2.tx;
                ly = t2.b * tempX + t2.d * ly + t2.ty;
              }
              this._currentPoly.points.push(lx, lx);
            } else {
              this._currentPoly.points.push(0, 0);
            }
          }
        }
        buildPath() {
          const path2 = this._graphicsPath2D;
          this.shapePrimitives.length = 0;
          this._currentPoly = null;
          for (let i2 = 0; i2 < path2.instructions.length; i2++) {
            const instruction = path2.instructions[i2];
            this[instruction.action](...instruction.data);
          }
          this.finish();
        }
        get bounds() {
          const bounds = this._bounds;
          bounds.clear();
          const shapePrimitives = this.shapePrimitives;
          for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
            const shapePrimitive = shapePrimitives[i2];
            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
            if (shapePrimitive.transform) {
              bounds.pushMatrix(shapePrimitive.transform);
              bounds.addRect(boundsRect);
              bounds.popMatrix();
            } else {
              bounds.addRect(boundsRect);
            }
          }
          return bounds;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/path/GraphicsPath.mjs
  function adjustTransform(currentMatrix, transform) {
    if (currentMatrix) {
      return currentMatrix.prepend(transform);
    }
    return transform.clone();
  }
  var GraphicsPath;
  var init_GraphicsPath = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
      init_Point();
      init_uid();
      init_warn();
      init_SVGToGraphicsPath();
      init_ShapePath();
      GraphicsPath = class {
        constructor(instructions) {
          this.instructions = [];
          this.uid = uid("graphicsPath");
          this._dirty = true;
          if (typeof instructions === "string") {
            SVGToGraphicsPath(instructions, this);
          } else {
            this.instructions = instructions?.slice() ?? [];
          }
        }
        get shapePath() {
          if (!this._shapePath) {
            this._shapePath = new ShapePath(this);
          }
          if (this._dirty) {
            this._dirty = false;
            this._shapePath.buildPath();
          }
          return this._shapePath;
        }
        addPath(path2, transform) {
          path2 = path2.clone();
          this.instructions.push({ action: "addPath", data: [path2, transform] });
          this._dirty = true;
          return this;
        }
        arc(...args) {
          this.instructions.push({ action: "arc", data: args });
          this._dirty = true;
          return this;
        }
        arcTo(...args) {
          this.instructions.push({ action: "arcTo", data: args });
          this._dirty = true;
          return this;
        }
        arcToSvg(...args) {
          this.instructions.push({ action: "arcToSvg", data: args });
          this._dirty = true;
          return this;
        }
        bezierCurveTo(...args) {
          this.instructions.push({ action: "bezierCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        bezierCurveToShort(cp2x, cp2y, x2, y2) {
          const last = this.instructions[this.instructions.length - 1];
          const lastPoint = this._getLastPoint(Point.shared);
          let cp1x = 0;
          let cp1y = 0;
          if (!last || last.action !== "bezierCurveTo") {
            cp1x = lastPoint.x;
            cp1y = lastPoint.y;
          } else {
            cp1x = last.data[2];
            cp1y = last.data[3];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cp1x = currentX + (currentX - cp1x);
            cp1y = currentY + (currentY - cp1y);
          }
          this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2] });
          this._dirty = true;
          return this;
        }
        closePath() {
          this.instructions.push({ action: "closePath", data: [] });
          this._dirty = true;
          return this;
        }
        ellipse(...args) {
          this.instructions.push({ action: "ellipse", data: args });
          this._dirty = true;
          return this;
        }
        lineTo(...args) {
          this.instructions.push({ action: "lineTo", data: args });
          this._dirty = true;
          return this;
        }
        moveTo(...args) {
          this.instructions.push({ action: "moveTo", data: args });
          return this;
        }
        quadraticCurveTo(...args) {
          this.instructions.push({ action: "quadraticCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        quadraticCurveToShort(x2, y2) {
          const last = this.instructions[this.instructions.length - 1];
          const lastPoint = this._getLastPoint(Point.shared);
          let cpx1 = 0;
          let cpy1 = 0;
          if (!last || last.action !== "quadraticCurveTo") {
            cpx1 = lastPoint.x;
            cpy1 = lastPoint.y;
          } else {
            cpx1 = last.data[0];
            cpy1 = last.data[1];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cpx1 = currentX + (currentX - cpx1);
            cpy1 = currentY + (currentY - cpy1);
          }
          this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2] });
          this._dirty = true;
          return this;
        }
        rect(x2, y2, w2, h2, transform) {
          this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform] });
          this._dirty = true;
          return this;
        }
        circle(x2, y2, radius, transform) {
          this.instructions.push({ action: "circle", data: [x2, y2, radius, transform] });
          this._dirty = true;
          return this;
        }
        roundRect(...args) {
          this.instructions.push({ action: "roundRect", data: args });
          this._dirty = true;
          return this;
        }
        poly(...args) {
          this.instructions.push({ action: "poly", data: args });
          this._dirty = true;
          return this;
        }
        star(x2, y2, points, radius, innerRadius, rotation = 0, transform) {
          innerRadius = innerRadius || radius / 2;
          const startAngle = -1 * Math.PI / 2 + rotation;
          const len = points * 2;
          const delta = Math.PI * 2 / len;
          const polygon = [];
          for (let i2 = 0; i2 < len; i2++) {
            const r2 = i2 % 2 ? innerRadius : radius;
            const angle = i2 * delta + startAngle;
            polygon.push(
              x2 + r2 * Math.cos(angle),
              y2 + r2 * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform);
          return this;
        }
        clone(deep = false) {
          const newGraphicsPath2D = new GraphicsPath();
          if (!deep) {
            newGraphicsPath2D.instructions = this.instructions.slice();
          } else {
            for (let i2 = 0; i2 < this.instructions.length; i2++) {
              const instruction = this.instructions[i2];
              newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
            }
          }
          return newGraphicsPath2D;
        }
        clear() {
          this.instructions.length = 0;
          this._dirty = true;
          return this;
        }
        transform(matrix) {
          if (matrix.isIdentity())
            return this;
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let x2 = 0;
          let y2 = 0;
          let cpx1 = 0;
          let cpy1 = 0;
          let cpx2 = 0;
          let cpy2 = 0;
          let rx = 0;
          let ry = 0;
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            const data = instruction.data;
            switch (instruction.action) {
              case "moveTo":
              case "lineTo":
                x2 = data[0];
                y2 = data[1];
                data[0] = a2 * x2 + c2 * y2 + tx;
                data[1] = b2 * x2 + d2 * y2 + ty;
                break;
              case "bezierCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                cpx2 = data[2];
                cpy2 = data[3];
                x2 = data[4];
                y2 = data[5];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * cpx2 + c2 * cpy2 + tx;
                data[3] = b2 * cpx2 + d2 * cpy2 + ty;
                data[4] = a2 * x2 + c2 * y2 + tx;
                data[5] = b2 * x2 + d2 * y2 + ty;
                break;
              case "quadraticCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                x2 = data[2];
                y2 = data[3];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * x2 + c2 * y2 + tx;
                data[3] = b2 * x2 + d2 * y2 + ty;
                break;
              case "arcToSvg":
                x2 = data[5];
                y2 = data[6];
                rx = data[0];
                ry = data[1];
                data[0] = a2 * rx + c2 * ry;
                data[1] = b2 * rx + d2 * ry;
                data[5] = a2 * x2 + c2 * y2 + tx;
                data[6] = b2 * x2 + d2 * y2 + ty;
                break;
              case "rect":
                data[4] = adjustTransform(data[4], matrix);
                break;
              case "ellipse":
                data[8] = adjustTransform(data[8], matrix);
                break;
              case "roundRect":
                data[5] = adjustTransform(data[5], matrix);
                break;
              case "addPath":
                data[0].transform(matrix);
                break;
              default:
                warn("unknown transform action", instruction.action);
                break;
            }
          }
          this._dirty = true;
          return this;
        }
        get bounds() {
          return this.shapePath.bounds;
        }
        _getLastPoint(out2) {
          let index = this.instructions.length - 1;
          let lastInstruction = this.instructions[index];
          if (!lastInstruction) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          while (lastInstruction.action === "closePath") {
            index--;
            if (index < 0) {
              out2.x = 0;
              out2.y = 0;
              return out2;
            }
            lastInstruction = this.instructions[index];
          }
          let x2;
          let y2;
          let transform;
          switch (lastInstruction.action) {
            case "moveTo":
            case "lineTo":
              out2.x = lastInstruction.data[0];
              out2.y = lastInstruction.data[1];
              break;
            case "quadraticCurveTo":
              out2.x = lastInstruction.data[2];
              out2.y = lastInstruction.data[3];
              break;
            case "bezierCurveTo":
              out2.x = lastInstruction.data[4];
              out2.y = lastInstruction.data[5];
              break;
            case "arc":
            case "arcToSvg":
              out2.x = lastInstruction.data[5];
              out2.y = lastInstruction.data[6];
              break;
            case "addPath":
              out2.x = lastInstruction.data[0].lastX;
              out2.y = lastInstruction.data[2].lastY;
              break;
            case "rect":
              transform = lastInstruction.data[4];
              x2 = lastInstruction.data[0];
              y2 = lastInstruction.data[1];
              if (transform) {
                const { a: a2, b: b2, c: c2, d: d2, tx, ty } = transform;
                out2.x = a2 * x2 + c2 * y2 + tx;
                out2.y = b2 * x2 + d2 * y2 + ty;
              } else {
                out2.x = x2;
                out2.y = y2;
              }
              break;
            default:
              warn(`${lastInstruction.action} is not supported yet`);
              break;
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/svg/SVGParser.mjs
  function SVGParser(svg, graphicsContext) {
    if (typeof svg === "string") {
      const div = document.createElement("div");
      div.innerHTML = svg.trim();
      svg = div.querySelector("svg");
    }
    const session = {
      context: graphicsContext,
      path: new GraphicsPath()
    };
    renderChildren(svg, session, null, null);
    return graphicsContext;
  }
  function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children = svg.children;
    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
    if (f1 && fillStyle) {
      fillStyle = { ...fillStyle, ...f1 };
    } else if (f1) {
      fillStyle = f1;
    }
    if (s1 && strokeStyle) {
      strokeStyle = { ...strokeStyle, ...s1 };
    } else if (s1) {
      strokeStyle = s1;
    }
    session.context.fillStyle = fillStyle;
    session.context.strokeStyle = strokeStyle;
    let x2;
    let y2;
    let x1;
    let y1;
    let x22;
    let y22;
    let cx;
    let cy;
    let r2;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d2;
    let graphicsPath;
    let width;
    let height;
    switch (svg.nodeName.toLowerCase()) {
      case "path":
        d2 = svg.getAttribute("d");
        graphicsPath = new GraphicsPath(d2);
        session.context.path(graphicsPath);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "circle":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        r2 = parseFloatAttribute(svg, "r", 0);
        session.context.ellipse(cx, cy, r2, r2);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "rect":
        x2 = parseFloatAttribute(svg, "x", 0);
        y2 = parseFloatAttribute(svg, "y", 0);
        width = parseFloatAttribute(svg, "width", 0);
        height = parseFloatAttribute(svg, "height", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        if (rx || ry) {
          session.context.roundRect(x2, y2, width, height, rx || ry);
        } else {
          session.context.rect(x2, y2, width, height);
        }
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "ellipse":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        session.context.beginPath();
        session.context.ellipse(cx, cy, rx, ry);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "line":
        x1 = parseFloatAttribute(svg, "x1", 0);
        y1 = parseFloatAttribute(svg, "y1", 0);
        x22 = parseFloatAttribute(svg, "x2", 0);
        y22 = parseFloatAttribute(svg, "y2", 0);
        session.context.beginPath();
        session.context.moveTo(x1, y1);
        session.context.lineTo(x22, y22);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polygon":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, true);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polyline":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, false);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "g":
      case "svg":
        break;
      default: {
        console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
        break;
      }
    }
    for (let i2 = 0; i2 < children.length; i2++) {
      renderChildren(children[i2], session, fillStyle, strokeStyle);
    }
  }
  function parseFloatAttribute(svg, id, defaultValue2) {
    const value = svg.getAttribute(id);
    return value ? Number(value) : defaultValue2;
  }
  function parseStyle(svg) {
    const style = svg.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    let useFill = false;
    let useStroke = false;
    if (style) {
      const styleParts = style.split(";");
      for (let i2 = 0; i2 < styleParts.length; i2++) {
        const stylePart = styleParts[i2];
        const [key, value] = stylePart.split(":");
        switch (key) {
          case "stroke":
            if (value !== "none") {
              strokeStyle.color = Color.shared.setValue(value).toNumber();
              useStroke = true;
            }
            break;
          case "stroke-width":
            strokeStyle.width = Number(value);
            break;
          case "fill":
            if (value !== "none") {
              useFill = true;
              fillStyle.color = Color.shared.setValue(value).toNumber();
            }
            break;
          case "fill-opacity":
            fillStyle.alpha = Number(value);
            break;
          case "stroke-opacity":
            strokeStyle.alpha = Number(value);
            break;
          case "opacity":
            fillStyle.alpha = Number(value);
            strokeStyle.alpha = Number(value);
            break;
        }
      }
    } else {
      const stroke = svg.getAttribute("stroke");
      if (stroke && stroke !== "none") {
        useStroke = true;
        strokeStyle.color = Color.shared.setValue(stroke).toNumber();
        strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
      }
      const fill = svg.getAttribute("fill");
      if (fill && fill !== "none") {
        useFill = true;
        fillStyle.color = Color.shared.setValue(fill).toNumber();
      }
    }
    return {
      strokeStyle: useStroke ? strokeStyle : null,
      fillStyle: useFill ? fillStyle : null
    };
  }
  var init_SVGParser = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
      init_Color();
      init_GraphicsPath();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
  var ImageSource, canvas, size, ctx;
  var init_ImageSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
      init_settings();
      init_NOOP();
      init_Texture();
      init_TextureSource();
      ImageSource = class extends TextureSource {
        constructor() {
          super(...arguments);
          this.uploadMethodId = "image";
        }
      };
      canvas = settings.ADAPTER.createCanvas();
      size = 1;
      canvas.width = size;
      canvas.height = size;
      ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, size, size);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(size, 0);
      ctx.lineTo(size, size);
      ctx.closePath();
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      Texture.WHITE = new Texture({
        source: new ImageSource({
          resource: canvas
        })
      });
      Texture.WHITE.label = "WHITE";
      Texture.WHITE.destroy = NOOP;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/fill/FillGradient.mjs
  var _FillGradient, FillGradient;
  var init_FillGradient = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
      init_Color();
      init_Matrix();
      init_ImageSource();
      init_Texture();
      init_settings();
      init_uid();
      _FillGradient = class {
        constructor(x0, y0, x1, y1) {
          this.uid = uid("fillGradient");
          this.type = "linear";
          this.gradientStops = [];
          this.x0 = x0;
          this.y0 = y0;
          this.x1 = x1;
          this.y1 = y1;
        }
        addColorStop(offset, color) {
          this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHex() });
          return this;
        }
        buildLinearGradient() {
          const defaultSize = _FillGradient.defaultTextureSize;
          const { gradientStops } = this;
          const canvas2 = settings.ADAPTER.createCanvas();
          canvas2.width = defaultSize;
          canvas2.height = defaultSize;
          const ctx2 = canvas2.getContext("2d");
          const gradient = ctx2.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);
          for (let i2 = 0; i2 < gradientStops.length; i2++) {
            const stop = gradientStops[i2];
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx2.fillStyle = gradient;
          ctx2.fillRect(0, 0, defaultSize, defaultSize);
          this.texture = new Texture({
            source: new ImageSource({
              resource: canvas2,
              style: {
                addressModeU: "clamp-to-edge",
                addressModeV: "repeat"
              }
            })
          });
          const { x0, y0, x1, y1 } = this;
          const m2 = new Matrix();
          const dx = x1 - x0;
          const dy = y1 - y0;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          m2.translate(-x0, -y0);
          m2.scale(1 / defaultSize, 1 / defaultSize);
          m2.rotate(-angle);
          m2.scale(256 / dist, 1);
          this.transform = m2;
        }
      };
      FillGradient = _FillGradient;
      FillGradient.defaultTextureSize = 256;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/fill/FillPattern.mjs
  var repetitionMap, FillPattern;
  var init_FillPattern = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
      init_Matrix();
      init_uid();
      repetitionMap = {
        repeat: {
          addressModeU: "repeat",
          addressModeV: "repeat"
        },
        "repeat-x": {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
          addressModeU: "clamp-to-edge",
          addressModeV: "repeat"
        },
        "no-repeat": {
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      };
      FillPattern = class {
        constructor(texture, repetition) {
          this.uid = uid("fillPattern");
          this.transform = new Matrix();
          this.texture = texture;
          this.transform.scale(
            1 / texture.frameWidth,
            1 / texture.frameHeight
          );
          if (repetition) {
            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
          }
        }
        setTransform(transform) {
          const texture = this.texture;
          this.transform.copyFrom(transform);
          this.transform.invert();
          this.transform.scale(
            1 / texture.frameWidth,
            1 / texture.frameHeight
          );
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
  function convertFillInputToFillStyle(value, defaultStyle) {
    if (!value) {
      return null;
    }
    let fillStyleToParse;
    let styleToMerge;
    if (value?.fill) {
      styleToMerge = value.fill;
      fillStyleToParse = { ...defaultStyle, ...value };
    } else {
      styleToMerge = value;
      fillStyleToParse = defaultStyle;
    }
    if (Color.isColorLike(styleToMerge)) {
      const temp = Color.shared.setValue(styleToMerge ?? 0);
      const opts = {
        ...fillStyleToParse,
        color: temp.toNumber(),
        alpha: fillStyleToParse.alpha ?? temp.alpha,
        texture: Texture.WHITE
      };
      return opts;
    } else if (styleToMerge instanceof FillPattern) {
      const pattern = styleToMerge;
      return {
        ...fillStyleToParse,
        color: 16777215,
        texture: pattern.texture,
        matrix: pattern.transform,
        fill: fillStyleToParse.fill ?? null
      };
    } else if (styleToMerge instanceof FillGradient) {
      const gradient = styleToMerge;
      gradient.buildLinearGradient();
      return {
        ...fillStyleToParse,
        color: 16777215,
        texture: gradient.texture,
        matrix: gradient.transform
      };
    }
    const style = { ...defaultStyle, ...value };
    if (style.texture !== Texture.WHITE) {
      const m2 = style.matrix || new Matrix();
      m2.scale(1 / style.texture.frameWidth, 1 / style.texture.frameHeight);
      style.matrix = m2;
      style.color = 16777215;
    }
    style.color = Color.shared.setValue(style.color).toNumber();
    return style;
  }
  var init_convertFillInputToFillStyle = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsContext.mjs
  var tmpPoint, tempMatrix3, _GraphicsContext, GraphicsContext;
  var init_GraphicsContext = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsContext.mjs"() {
      init_eventemitter3();
      init_Color();
      init_Matrix();
      init_Point();
      init_Texture();
      init_uid();
      init_deprecation();
      init_Bounds();
      init_GraphicsPath();
      init_SVGParser();
      init_convertFillInputToFillStyle();
      tmpPoint = new Point();
      tempMatrix3 = new Matrix();
      _GraphicsContext = class extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.uid = uid("graphicsContext");
          this.dirty = true;
          this.batchMode = "auto";
          this.instructions = [];
          this._activePath = new GraphicsPath();
          this._transform = new Matrix();
          this._fillStyle = { ..._GraphicsContext.defaultFillStyle };
          this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };
          this._stateStack = [];
          this._tick = 0;
          this._bounds = new Bounds();
          this._boundsDirty = true;
        }
        get fillStyle() {
          return this._fillStyle;
        }
        set fillStyle(value) {
          this._fillStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultFillStyle);
        }
        get strokeStyle() {
          return this._strokeStyle;
        }
        set strokeStyle(value) {
          this._strokeStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultStrokeStyle);
        }
        texture(texture, tint, dx, dy, dw, dh) {
          this.instructions.push({
            action: "texture",
            data: {
              image: texture,
              dx: dx || 0,
              dy: dy || 0,
              dw: dw || texture.frameWidth,
              dh: dh || texture.frameHeight,
              transform: this._transform.clone(),
              alpha: this._fillStyle.alpha,
              style: tint ? Color.shared.setValue(tint).toNumber() : 0
            }
          });
          this.onUpdate();
          return this;
        }
        beginPath() {
          this._activePath = new GraphicsPath();
          return this;
        }
        fill(style, alpha) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style) {
            if (alpha !== void 0 && typeof style === "number") {
              deprecation("8.0.0", "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
              style = { color: style, alpha };
            }
            this.fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);
          }
          this.instructions.push({
            action: "fill",
            data: { style: this.fillStyle, path: path2 }
          });
          this.onUpdate();
          this._activePath.instructions.length = 0;
          this._tick = 0;
          return this;
        }
        stroke(style) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style) {
            this.strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);
          }
          this.instructions.push({
            action: "stroke",
            data: { style: this.strokeStyle, path: path2 }
          });
          this.onUpdate();
          this._activePath.instructions.length = 0;
          this._tick = 0;
          return this;
        }
        cut() {
          for (let i2 = 0; i2 < 2; i2++) {
            const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
            const holePath = this._activePath.clone();
            if (lastInstruction) {
              if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
                lastInstruction.data.hole = holePath;
              }
            }
          }
          this._activePath.instructions.length = 0;
          return this;
        }
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arc(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius,
            startAngle,
            endAngle,
            counterclockwise
          );
          return this;
        }
        arcTo(x1, y1, x2, y2, radius) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcTo(
            t2.a * x1 + t2.c * y1 + t2.tx,
            t2.b * x1 + t2.d * y1 + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius
          );
          return this;
        }
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcToSvg(
            rx,
            ry,
            xAxisRotation,
            largeArcFlag,
            sweepFlag,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.bezierCurveTo(
            t2.a * cp1x + t2.c * cp1y + t2.tx,
            t2.b * cp1x + t2.d * cp1y + t2.ty,
            t2.a * cp2x + t2.c * cp2y + t2.tx,
            t2.b * cp2x + t2.d * cp2y + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        closePath() {
          this._tick++;
          this._activePath?.closePath();
          return this;
        }
        ellipse(x2, y2, radiusX, radiusY) {
          this._tick++;
          this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
          return this;
        }
        circle(x2, y2, radius) {
          this._tick++;
          this._activePath.circle(x2, y2, radius, this._transform.clone());
          return this;
        }
        path(path2) {
          this._tick++;
          this._activePath.addPath(path2, this._transform.clone());
          return this;
        }
        lineTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.lineTo(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        moveTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.moveTo(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        quadraticCurveTo(cpx, cpy, x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.quadraticCurveTo(
            t2.a * cpx + t2.c * cpy + t2.tx,
            t2.b * cpx + t2.d * cpy + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
        }
        rect(x2, y2, w2, h2) {
          this._tick++;
          this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
          return this;
        }
        roundRect(x2, y2, w2, h2, radii) {
          this._tick++;
          this._activePath.roundRect(x2, y2, w2, h2, radii, this._transform.clone());
          return this;
        }
        poly(points, close) {
          this._tick++;
          this._activePath.poly(points, close, this._transform.clone());
          return this;
        }
        star(x2, y2, points, radius, innerRadius, rotation) {
          this._tick++;
          this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
          return this;
        }
        svg(svg) {
          this._tick++;
          SVGParser(svg, this);
        }
        restore() {
          const state = this._stateStack.pop();
          if (state) {
            this._transform = state.transform;
            this._fillStyle = state.fillStyle;
            this._strokeStyle = state.strokeStyle;
          }
        }
        save() {
          this._stateStack.push({
            transform: this._transform.clone(),
            fillStyle: { ...this._fillStyle },
            strokeStyle: { ...this._strokeStyle }
          });
        }
        getTransform() {
          return this._transform;
        }
        resetTransform() {
          this._transform.identity();
          return this;
        }
        rotate(angle) {
          this._transform.rotate(angle);
          return this;
        }
        scale(x2, y2 = x2) {
          this._transform.scale(x2, y2);
          return this;
        }
        setTransform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
            return this;
          }
          this._transform.set(a2, b2, c2, d2, dx, dy);
          return this;
        }
        transform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.append(a2);
            return this;
          }
          tempMatrix3.set(a2, b2, c2, d2, dx, dy);
          this._transform.append(tempMatrix3);
          return this;
        }
        translate(x2, y2) {
          this._transform.translate(x2, y2);
          return this;
        }
        clear() {
          this.instructions.length = 0;
          this.resetTransform();
          this.onUpdate();
          return this;
        }
        onUpdate() {
          if (this.dirty)
            return;
          this.emit("update", this, 16);
          this.dirty = true;
          this._boundsDirty = true;
        }
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          const bounds = this._bounds;
          bounds.clear();
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            const action = instruction.action;
            if (action === "fill") {
              const data = instruction.data;
              bounds.addBounds(data.path.bounds);
            } else if (action === "texture") {
              const data = instruction.data;
              bounds.pushMatrix(data.transform);
              bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh);
              bounds.popMatrix();
            }
          }
          return bounds;
        }
        containsPoint(point) {
          const instructions = this.instructions;
          let hasHit = false;
          instructions.forEach((instruction) => {
            const data = instruction.data;
            const path2 = data.path;
            if (!instruction.action || !path2)
              return;
            const style = data.style;
            const shapes = path2.shapePath?.shapePrimitives;
            this._forEachShape(shapes, (shape) => {
              if (!style || !shape)
                return;
              if (typeof style !== "number" && style.matrix) {
                style.matrix.applyInverse(point, tmpPoint);
              } else {
                tmpPoint.copyFrom(point);
              }
              hasHit = shape.contains(tmpPoint.x, tmpPoint.y);
              const holes = data.hole;
              if (!holes)
                return;
              const holeShapes = holes.shapePath?.shapePrimitives;
              if (!holeShapes)
                return;
              this._forEachShape(holeShapes, (hole) => {
                if (hole.contains(tmpPoint.x, tmpPoint.y)) {
                  hasHit = false;
                }
              });
            });
          });
          return hasHit;
        }
        _forEachShape(shapes, callback) {
          shapes?.forEach((shapePrimitive) => {
            const shape = shapePrimitive?.shape;
            if (shape) {
              callback(shape);
            }
          });
        }
        destroy(options = false) {
          this._stateStack.length = 0;
          this._transform = null;
          this.emit("destroy", this);
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fillStyle.texture) {
              this._fillStyle.texture.destroy(destroyTextureSource);
            }
            if (this._strokeStyle.texture) {
              this._strokeStyle.texture.destroy(destroyTextureSource);
            }
          }
          this._fillStyle = null;
          this._strokeStyle = null;
          this.instructions = null;
          this._activePath = null;
          this._bounds = null;
          this._stateStack = null;
          this.customShader = null;
          this._transform = null;
        }
      };
      GraphicsContext = _GraphicsContext;
      GraphicsContext.defaultFillStyle = {
        color: 0,
        alpha: 1,
        texture: Texture.WHITE,
        matrix: null,
        fill: null
      };
      GraphicsContext.defaultStrokeStyle = {
        width: 1,
        color: 0,
        alpha: 1,
        alignment: 0.5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: Texture.WHITE,
        matrix: null,
        fill: null
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadSVG.mjs
  var SVG_XML, validSVGExtension, validSVGMIME, loadSvg;
  var init_loadSVG = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadSVG.mjs"() {
      init_Extensions();
      init_GraphicsContext();
      init_settings();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
      validSVGExtension = ".svg";
      validSVGMIME = "image/svg+xml";
      loadSvg = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        name: "loadSVG",
        test(url) {
          return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
        },
        async testParse(data) {
          return typeof data === "string" && data.startsWith("data:image/svg+xml") || typeof data === "string" && SVG_XML.test(data);
        },
        async parse(asset) {
          const context2 = new GraphicsContext();
          context2.svg(asset);
          return context2;
        },
        async load(url) {
          const response = await settings.ADAPTER.fetch(url);
          return response.text();
        },
        unload(asset) {
          asset.destroy(true);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/network/getResolutionOfUrl.mjs
  function getResolutionOfUrl(url, defaultValue2 = 1) {
    const resolution = settings.RETINA_PREFIX?.exec(url);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue2;
  }
  var init_getResolutionOfUrl = __esm({
    "node_modules/pixi-v8/lib/utils/network/getResolutionOfUrl.mjs"() {
      init_settings();
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/WorkerManager.mjs
  var UUID, MAX_WORKERS, WHITE_PNG, checkImageBitmapCode, workerCode, workerURL, WorkerManagerClass, WorkerManager;
  var init_WorkerManager = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/WorkerManager.mjs"() {
      UUID = 0;
      WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
      checkImageBitmapCode = {
        id: "checkImageBitmap",
        code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
      };
      workerCode = {
        id: "loadImageBitmap",
        code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
      };
      WorkerManagerClass = class {
        constructor() {
          this._initialized = false;
          this._createdWorkers = 0;
          this._workerPool = [];
          this._queue = [];
          this._resolveHash = {};
        }
        isImageBitmapSupported() {
          if (this._isImageBitmapSupported !== void 0)
            return this._isImageBitmapSupported;
          this._isImageBitmapSupported = new Promise((resolve) => {
            const workerURL2 = URL.createObjectURL(new Blob(
              [checkImageBitmapCode.code],
              { type: "application/javascript" }
            ));
            const worker = new Worker(workerURL2);
            worker.addEventListener("message", (event) => {
              worker.terminate();
              URL.revokeObjectURL(workerURL2);
              resolve(event.data);
            });
          });
          return this._isImageBitmapSupported;
        }
        loadImageBitmap(src) {
          return this._run("loadImageBitmap", [src]);
        }
        async _initWorkers() {
          if (this._initialized)
            return;
          this._initialized = true;
        }
        _getWorker() {
          if (MAX_WORKERS === void 0) {
            MAX_WORKERS = navigator.hardwareConcurrency || 4;
          }
          let worker = this._workerPool.pop();
          if (!worker && this._createdWorkers < MAX_WORKERS) {
            if (!workerURL) {
              workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
            }
            this._createdWorkers++;
            worker = new Worker(workerURL);
            worker.addEventListener("message", (event) => {
              this._complete(event.data);
              this._returnWorker(event.target);
              this._next();
            });
          }
          return worker;
        }
        _returnWorker(worker) {
          this._workerPool.push(worker);
        }
        _complete(data) {
          if (data.error !== void 0) {
            this._resolveHash[data.uuid].reject(data.error);
          } else {
            this._resolveHash[data.uuid].resolve(data.data);
          }
          this._resolveHash[data.uuid] = null;
        }
        async _run(id, args) {
          await this._initWorkers();
          const promise2 = new Promise((resolve, reject) => {
            this._queue.push({ id, arguments: args, resolve, reject });
          });
          this._next();
          return promise2;
        }
        _next() {
          if (!this._queue.length)
            return;
          const worker = this._getWorker();
          if (!worker) {
            return;
          }
          const toDo = this._queue.pop();
          const id = toDo.id;
          this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
          worker.postMessage({
            data: toDo.arguments,
            uuid: UUID++,
            id
          });
        }
      };
      WorkerManager = new WorkerManagerClass();
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/textures/utils/createTexture.mjs
  function createTexture(source2, loader, url) {
    const texture = new Texture({
      source: source2,
      label: url
    });
    const unload = () => {
      delete loader.promiseCache[url];
      if (Cache.has(url)) {
        Cache.remove(url);
      }
    };
    texture.once("destroy", () => {
      if (url in loader.promiseCache) {
        warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture.");
        unload();
      }
    });
    texture.source.once("destroy", () => {
      if (!source2.destroyed) {
        warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
        unload();
      }
    });
    return texture;
  }
  var init_createTexture = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/textures/utils/createTexture.mjs"() {
      init_Texture();
      init_warn();
      init_Cache();
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadTextures.mjs
  async function loadImageBitmap(url) {
    const response = await settings.ADAPTER.fetch(url);
    if (!response.ok) {
      throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
    }
    const imageBlob = await response.blob();
    const imageBitmap = await createImageBitmap(imageBlob);
    return imageBitmap;
  }
  var validImageExtensions, validImageMIMEs, loadTextures;
  var init_loadTextures = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadTextures.mjs"() {
      init_Extensions();
      init_ImageSource();
      init_settings();
      init_getResolutionOfUrl();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      init_WorkerManager();
      init_createTexture();
      validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
      validImageMIMEs = [
        "image/jpeg",
        "image/png",
        "image/webp",
        "image/avif"
      ];
      loadTextures = {
        name: "loadTextures",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High
        },
        config: {
          preferWorkers: true,
          preferCreateImageBitmap: true,
          crossOrigin: "anonymous"
        },
        test(url) {
          return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
        },
        async load(url, asset, loader) {
          let src = null;
          if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
              src = await WorkerManager.loadImageBitmap(url);
            } else {
              src = await loadImageBitmap(url);
            }
          } else {
            src = await new Promise((resolve) => {
              src = new Image();
              src.crossOrigin = this.config.crossOrigin;
              src.src = url;
              if (src.complete) {
                resolve(src);
              } else {
                src.onload = () => {
                  resolve(src);
                };
              }
            });
          }
          const base = new ImageSource({
            resource: src,
            alphaMode: "premultiply-alpha-on-upload",
            resolution: asset.data?.resolution || getResolutionOfUrl(url),
            ...asset.data
          });
          return createTexture(base, loader, url);
        },
        unload(texture) {
          texture.destroy(true);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/detectVideoAlphaMode.mjs
  async function detectVideoAlphaMode() {
    promise ?? (promise = (async () => {
      const canvas2 = document.createElement("canvas");
      const gl = canvas2.getContext("webgl");
      if (!gl) {
        return "premultiply-alpha-on-upload";
      }
      const video = await new Promise((resolve) => {
        const video2 = document.createElement("video");
        video2.onloadeddata = () => resolve(video2);
        video2.onerror = () => resolve(null);
        video2.autoplay = false;
        video2.crossOrigin = "anonymous";
        video2.preload = "auto";
        video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
        video2.load();
      });
      if (!video) {
        return "premultiply-alpha-on-upload";
      }
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        texture,
        0
      );
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      const pixel = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
      gl.getExtension("WEBGL_lose_context")?.loseContext();
      return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })());
    return promise;
  }
  var promise;
  var init_detectVideoAlphaMode = __esm({
    "node_modules/pixi-v8/lib/utils/browser/detectVideoAlphaMode.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
  var _VideoSource, VideoSource;
  var init_VideoSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
      init_Ticker();
      init_detectVideoAlphaMode();
      init_TextureSource();
      _VideoSource = class extends TextureSource {
        constructor(options) {
          super(options);
          this.isReady = false;
          this.uploadMethodId = "video";
          options = {
            ..._VideoSource.defaultOptions,
            ...options
          };
          this._autoUpdate = true;
          this._isConnectedToTicker = false;
          this._updateFPS = options.updateFPS || 0;
          this._msToNextUpdate = 0;
          this.autoPlay = options.autoPlay !== false;
          this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
          this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
          this._videoFrameRequestCallbackHandle = null;
          this._load = null;
          this._resolve = null;
          this._reject = null;
          this._onCanPlay = this._onCanPlay.bind(this);
          this._onError = this._onError.bind(this);
          this._onPlayStart = this._onPlayStart.bind(this);
          this._onPlayStop = this._onPlayStop.bind(this);
          this._onSeeked = this._onSeeked.bind(this);
          if (options.autoLoad !== false) {
            void this.load();
          }
        }
        updateFrame() {
          if (this.destroyed) {
            return;
          }
          if (this._updateFPS) {
            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          }
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
          if (this.isValid) {
            this.update();
          }
        }
        _videoFrameRequestCallback() {
          this.updateFrame();
          if (this.destroyed) {
            this._videoFrameRequestCallbackHandle = null;
          } else {
            this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
              this._videoFrameRequestCallback
            );
          }
        }
        get isValid() {
          return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        async load() {
          if (this._load) {
            return this._load;
          }
          const source2 = this.resource;
          if ((source2.readyState === source2.HAVE_ENOUGH_DATA || source2.readyState === source2.HAVE_FUTURE_DATA) && source2.width && source2.height) {
            source2.complete = true;
          }
          source2.addEventListener("play", this._onPlayStart);
          source2.addEventListener("pause", this._onPlayStop);
          source2.addEventListener("seeked", this._onSeeked);
          if (!this._isSourceReady()) {
            const options = this.options;
            if (!options.preload) {
              source2.addEventListener("canplay", this._onCanPlay);
            }
            source2.addEventListener("canplaythrough", this._onCanPlay);
            source2.addEventListener("error", this._onError, true);
          } else {
            this._onCanPlay();
          }
          this.alphaMode = await detectVideoAlphaMode();
          this._load = new Promise((resolve, reject) => {
            if (this.isValid) {
              resolve(this);
            } else {
              this._resolve = resolve;
              this._reject = reject;
              source2.load();
            }
          });
          return this._load;
        }
        _onError(event) {
          this.resource.removeEventListener("error", this._onError, true);
          this.emit("error", event);
          if (this._reject) {
            this._reject(event);
            this._reject = null;
            this._resolve = null;
          }
        }
        _isSourcePlaying() {
          const source2 = this.resource;
          return !source2.paused && !source2.ended;
        }
        _isSourceReady() {
          const source2 = this.resource;
          return source2.readyState > 2;
        }
        _onPlayStart() {
          if (!this.isValid) {
            this._onCanPlay();
          }
          this._configureAutoUpdate();
        }
        _onPlayStop() {
          this._configureAutoUpdate();
        }
        _onSeeked() {
          if (this._autoUpdate && !this._isSourcePlaying()) {
            this._msToNextUpdate = 0;
            this.updateFrame();
            this._msToNextUpdate = 0;
          }
        }
        _onCanPlay() {
          const source2 = this.resource;
          source2.removeEventListener("canplay", this._onCanPlay);
          source2.removeEventListener("canplaythrough", this._onCanPlay);
          if (this.isValid) {
            this.isReady = true;
            this.resize(source2.videoWidth, source2.videoHeight);
          }
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
          if (this._resolve) {
            this._resolve(this);
            this._resolve = null;
            this._reject = null;
          }
          if (this._isSourcePlaying()) {
            this._onPlayStart();
          } else if (this.autoPlay) {
            void this.resource.play();
          }
        }
        destroy() {
          this._configureAutoUpdate();
          const source2 = this.resource;
          if (source2) {
            source2.removeEventListener("play", this._onPlayStart);
            source2.removeEventListener("pause", this._onPlayStop);
            source2.removeEventListener("seeked", this._onSeeked);
            source2.removeEventListener("canplay", this._onCanPlay);
            source2.removeEventListener("canplaythrough", this._onCanPlay);
            source2.removeEventListener("error", this._onError, true);
            source2.pause();
            source2.src = "";
            source2.load();
          }
          super.destroy();
        }
        get autoUpdate() {
          return this._autoUpdate;
        }
        set autoUpdate(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            this._configureAutoUpdate();
          }
        }
        get updateFPS() {
          return this._updateFPS;
        }
        set updateFPS(value) {
          if (value !== this._updateFPS) {
            this._updateFPS = value;
            this._configureAutoUpdate();
          }
        }
        _configureAutoUpdate() {
          if (this._autoUpdate && this._isSourcePlaying()) {
            if (!this._updateFPS && this.source.requestVideoFrameCallback) {
              if (this._isConnectedToTicker) {
                Ticker.shared.remove(this.updateFrame, this);
                this._isConnectedToTicker = false;
                this._msToNextUpdate = 0;
              }
              if (this._videoFrameRequestCallbackHandle === null) {
                this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
                  this._videoFrameRequestCallback
                );
              }
            } else {
              if (this._videoFrameRequestCallbackHandle !== null) {
                this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
                this._videoFrameRequestCallbackHandle = null;
              }
              if (!this._isConnectedToTicker) {
                Ticker.shared.add(this.updateFrame, this);
                this._isConnectedToTicker = true;
                this._msToNextUpdate = 0;
              }
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
          }
        }
      };
      VideoSource = _VideoSource;
      VideoSource.defaultOptions = {
        ...TextureSource.defaultOptions,
        autoLoad: true,
        autoPlay: true,
        updateFPS: 0,
        crossorigin: true,
        loop: false,
        muted: true,
        playsinline: true,
        preload: false
      };
      VideoSource.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
  function crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  function determineCrossOrigin(url, loc = globalThis.location) {
    if (url.startsWith("data:")) {
      return "";
    }
    loc = loc || globalThis.location;
    const parsedUrl = new URL(url, document.baseURI);
    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  var validVideoExtensions, validVideoMIMEs, loadVideoTextures;
  var init_loadVideoTextures = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadVideoTextures.mjs"() {
      init_Extensions();
      init_VideoSource();
      init_detectVideoAlphaMode();
      init_getResolutionOfUrl();
      init_checkDataUrl();
      init_checkExtension();
      init_createTexture();
      validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
      validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);
      loadVideoTextures = {
        name: "loadVideo",
        extension: {
          type: ExtensionType.LoadParser
        },
        config: null,
        test(url) {
          const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);
          const isValidExtension = checkExtension(url, validVideoExtensions);
          return isValidDataUrl || isValidExtension;
        },
        async load(url, asset, loader) {
          const options = {
            ...VideoSource.defaultOptions,
            resolution: asset.data?.resolution || getResolutionOfUrl(url),
            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),
            ...asset.data
          };
          const videoElement = document.createElement("video");
          const attributeMap = {
            preload: options.autoLoad !== false ? "auto" : void 0,
            "webkit-playsinline": options.playsinline !== false ? "" : void 0,
            playsinline: options.playsinline !== false ? "" : void 0,
            muted: options.muted === true ? "" : void 0,
            loop: options.loop === true ? "" : void 0,
            autoplay: options.autoPlay !== false ? "" : void 0
          };
          Object.keys(attributeMap).forEach((key) => {
            const value = attributeMap[key];
            if (value !== void 0)
              videoElement.setAttribute(key, value);
          });
          if (options.muted === true) {
            videoElement.muted = true;
          }
          crossOrigin(videoElement, url, options.crossorigin);
          const sourceElement = document.createElement("source");
          let mime;
          if (url.startsWith("data:")) {
            mime = url.slice(5, url.indexOf(";"));
          } else if (!url.startsWith("blob:")) {
            const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();
            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
          }
          sourceElement.src = url;
          if (mime) {
            sourceElement.type = mime;
          }
          videoElement.appendChild(sourceElement);
          const base = new VideoSource({ ...options, resource: videoElement });
          return createTexture(base, loader, url);
        },
        unload(texture) {
          texture.destroy(true);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/resolver/parsers/resolveTextureUrl.mjs
  var resolveTextureUrl;
  var init_resolveTextureUrl = __esm({
    "node_modules/pixi-v8/lib/assets/resolver/parsers/resolveTextureUrl.mjs"() {
      init_Extensions();
      init_settings();
      init_loadTextures();
      resolveTextureUrl = {
        extension: ExtensionType.ResolveParser,
        test: loadTextures.test,
        parse: (value) => ({
          resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: value.split(".").pop(),
          src: value
        })
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/init.mjs
  var assetKeyMap;
  var init_init3 = __esm({
    "node_modules/pixi-v8/lib/assets/init.mjs"() {
      init_Extensions();
      init_loadBitmapFont();
      init_cacheTextureArray();
      init_detectAvif();
      init_detectDefaults();
      init_detectMp4();
      init_detectOgv();
      init_detectWebm();
      init_detectWebp();
      init_loadJson();
      init_loadTxt();
      init_loadWebFont();
      init_loadSVG();
      init_loadTextures();
      init_loadVideoTextures();
      init_resolveTextureUrl();
      extensions.add(
        cacheTextureArray,
        detectDefaults,
        detectAvif,
        detectWebp,
        detectMp4,
        detectOgv,
        detectWebm,
        loadJson,
        loadTxt,
        loadWebFont,
        loadSvg,
        loadTextures,
        loadVideoTextures,
        resolveTextureUrl,
        xmlBitmapFontLoader,
        bitmapFontCachePlugin
      );
      assetKeyMap = {
        loader: ExtensionType.LoadParser,
        resolver: ExtensionType.ResolveParser,
        cache: ExtensionType.CacheParser,
        detection: ExtensionType.DetectionParser
      };
      extensions.handle(ExtensionType.Asset, (extension) => {
        const ref = extension.ref;
        Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(
          ref[key],
          { extension: ref[key].extension ?? type }
        )));
      }, (extension) => {
        const ref = extension.ref;
        Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
      });
    }
  });

  // node_modules/pixi-v8/lib/events/EventTicker.mjs
  var EventsTickerClass, EventsTicker;
  var init_EventTicker = __esm({
    "node_modules/pixi-v8/lib/events/EventTicker.mjs"() {
      init_const2();
      init_Ticker();
      EventsTickerClass = class {
        constructor() {
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        init(events) {
          this.removeTickerListener();
          this.events = events;
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        get pauseUpdate() {
          return this._pauseUpdate;
        }
        set pauseUpdate(paused) {
          this._pauseUpdate = paused;
        }
        addTickerListener() {
          if (this._tickerAdded || !this.domElement) {
            return;
          }
          Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
          this._tickerAdded = true;
        }
        removeTickerListener() {
          if (!this._tickerAdded) {
            return;
          }
          Ticker.system.remove(this._tickerUpdate, this);
          this._tickerAdded = false;
        }
        pointerMoved() {
          this._didMove = true;
        }
        _update() {
          if (!this.domElement || this._pauseUpdate) {
            return;
          }
          if (this._didMove) {
            this._didMove = false;
            return;
          }
          const rootPointerEvent = this.events["_rootPointerEvent"];
          if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
            return;
          }
          globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY
          }));
        }
        _tickerUpdate(ticker) {
          this._deltaTime += ticker.deltaTime;
          if (this._deltaTime < this.interactionFrequency) {
            return;
          }
          this._deltaTime = 0;
          this._update();
        }
      };
      EventsTicker = new EventsTickerClass();
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedMouseEvent.mjs
  var FederatedMouseEvent;
  var init_FederatedMouseEvent = __esm({
    "node_modules/pixi-v8/lib/events/FederatedMouseEvent.mjs"() {
      init_Point();
      init_FederatedEvent();
      FederatedMouseEvent = class extends FederatedEvent {
        constructor() {
          super(...arguments);
          this.client = new Point();
          this.movement = new Point();
          this.offset = new Point();
          this.global = new Point();
          this.screen = new Point();
        }
        get clientX() {
          return this.client.x;
        }
        get clientY() {
          return this.client.y;
        }
        get x() {
          return this.clientX;
        }
        get y() {
          return this.clientY;
        }
        get movementX() {
          return this.movement.x;
        }
        get movementY() {
          return this.movement.y;
        }
        get offsetX() {
          return this.offset.x;
        }
        get offsetY() {
          return this.offset.y;
        }
        get globalX() {
          return this.global.x;
        }
        get globalY() {
          return this.global.y;
        }
        get screenX() {
          return this.screen.x;
        }
        get screenY() {
          return this.screen.y;
        }
        getLocalPosition(container, point, globalPos) {
          return container.worldTransform.applyInverse(globalPos || this.global, point);
        }
        getModifierState(key) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
        }
        initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
          throw new Error("Method not implemented.");
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedPointerEvent.mjs
  var FederatedPointerEvent;
  var init_FederatedPointerEvent = __esm({
    "node_modules/pixi-v8/lib/events/FederatedPointerEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedPointerEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.width = 0;
          this.height = 0;
          this.isPrimary = false;
        }
        getCoalescedEvents() {
          if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [this];
          }
          return [];
        }
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!");
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedWheelEvent.mjs
  var FederatedWheelEvent;
  var init_FederatedWheelEvent = __esm({
    "node_modules/pixi-v8/lib/events/FederatedWheelEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedWheelEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.DOM_DELTA_PIXEL = 0;
          this.DOM_DELTA_LINE = 1;
          this.DOM_DELTA_PAGE = 2;
        }
      };
      FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
      FederatedWheelEvent.DOM_DELTA_LINE = 1;
      FederatedWheelEvent.DOM_DELTA_PAGE = 2;
    }
  });

  // node_modules/pixi-v8/lib/events/EventBoundary.mjs
  var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
  var init_EventBoundary = __esm({
    "node_modules/pixi-v8/lib/events/EventBoundary.mjs"() {
      init_eventemitter3();
      init_Point();
      init_warn();
      init_EventTicker();
      init_FederatedMouseEvent();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      PROPAGATION_LIMIT = 2048;
      tempHitLocation = new Point();
      tempLocalMapping = new Point();
      EventBoundary = class {
        constructor(rootTarget) {
          this.dispatch = new eventemitter3_default();
          this.moveOnAll = false;
          this.enableGlobalMoveEvents = true;
          this.mappingState = {
            trackingData: {}
          };
          this.eventPool = /* @__PURE__ */ new Map();
          this._allInteractiveElements = [];
          this._hitElements = [];
          this._isPointerMoveEvent = false;
          this.rootTarget = rootTarget;
          this.hitPruneFn = this.hitPruneFn.bind(this);
          this.hitTestFn = this.hitTestFn.bind(this);
          this.mapPointerDown = this.mapPointerDown.bind(this);
          this.mapPointerMove = this.mapPointerMove.bind(this);
          this.mapPointerOut = this.mapPointerOut.bind(this);
          this.mapPointerOver = this.mapPointerOver.bind(this);
          this.mapPointerUp = this.mapPointerUp.bind(this);
          this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
          this.mapWheel = this.mapWheel.bind(this);
          this.mappingTable = {};
          this.addEventMapping("pointerdown", this.mapPointerDown);
          this.addEventMapping("pointermove", this.mapPointerMove);
          this.addEventMapping("pointerout", this.mapPointerOut);
          this.addEventMapping("pointerleave", this.mapPointerOut);
          this.addEventMapping("pointerover", this.mapPointerOver);
          this.addEventMapping("pointerup", this.mapPointerUp);
          this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
          this.addEventMapping("wheel", this.mapWheel);
        }
        addEventMapping(type, fn) {
          if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
          }
          this.mappingTable[type].push({
            fn,
            priority: 0
          });
          this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
        }
        dispatchEvent(e2, type) {
          e2.propagationStopped = false;
          e2.propagationImmediatelyStopped = false;
          this.propagate(e2, type);
          this.dispatch.emit(type || e2.type, e2);
        }
        mapEvent(e2) {
          if (!this.rootTarget) {
            return;
          }
          const mappers = this.mappingTable[e2.type];
          if (mappers) {
            for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) {
              mappers[i2].fn(e2);
            }
          } else {
            warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
          }
        }
        hitTest(x2, y2) {
          EventsTicker.pauseUpdate = true;
          const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
          const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
          const invertedPath = this[fn](
            this.rootTarget,
            this.rootTarget.eventMode,
            tempHitLocation.set(x2, y2),
            this.hitTestFn,
            this.hitPruneFn
          );
          return invertedPath && invertedPath[0];
        }
        propagate(e2, type) {
          if (!e2.target) {
            return;
          }
          const composedPath = e2.composedPath();
          e2.eventPhase = e2.CAPTURING_PHASE;
          for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) {
            e2.currentTarget = composedPath[i2];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
          e2.eventPhase = e2.AT_TARGET;
          e2.currentTarget = e2.target;
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
            e2.currentTarget = composedPath[i2];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
        }
        all(e2, type, targets = this._allInteractiveElements) {
          if (targets.length === 0)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          const events = Array.isArray(type) ? type : [type];
          for (let i2 = targets.length - 1; i2 >= 0; i2--) {
            events.forEach((event) => {
              e2.currentTarget = targets[i2];
              this.notifyTarget(e2, event);
            });
          }
        }
        propagationPath(target) {
          const propagationPath = [target];
          for (let i2 = 0; i2 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i2++) {
            if (!target.parent) {
              throw new Error("Cannot find propagation path to disconnected target");
            }
            propagationPath.push(target.parent);
            target = target.parent;
          }
          propagationPath.reverse();
          return propagationPath;
        }
        hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
          let shouldReturn = false;
          if (this._interactivePrune(currentTarget))
            return null;
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            for (let i2 = children.length - 1; i2 >= 0; i2--) {
              const child = children[i2];
              const nestedHit = this.hitTestMoveRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                location,
                testFn,
                pruneFn,
                ignore || pruneFn(currentTarget, location)
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive) {
                  if (isInteractive)
                    this._allInteractiveElements.push(currentTarget);
                  nestedHit.push(currentTarget);
                }
                if (this._hitElements.length === 0)
                  this._hitElements = nestedHit;
                shouldReturn = true;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveTarget && isInteractiveTarget)
            this._allInteractiveElements.push(currentTarget);
          if (ignore || this._hitElements.length > 0)
            return null;
          if (shouldReturn)
            return this._hitElements;
          if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
          if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
            return null;
          }
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            const relativeLocation = location;
            for (let i2 = children.length - 1; i2 >= 0; i2--) {
              const child = children[i2];
              const nestedHit = this.hitTestRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                relativeLocation,
                testFn,
                pruneFn
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive)
                  nestedHit.push(currentTarget);
                return nestedHit;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveMode && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        _isInteractive(int) {
          return int === "static" || int === "dynamic";
        }
        _interactivePrune(container) {
          if (!container || !container.visible || !container.renderable) {
            return true;
          }
          if (container.eventMode === "none") {
            return true;
          }
          if (container.eventMode === "passive" && !container.interactiveChildren) {
            return true;
          }
          return false;
        }
        hitPruneFn(container, location) {
          if (container.hitArea) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
              return true;
            }
          }
          if (container.effects && container.effects.length) {
            for (let i2 = 0; i2 < container.effects.length; i2++) {
              const effect = container.effects[i2];
              if (effect.containsPoint) {
                const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
                if (!effectContainsPoint) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        hitTestFn(container, location) {
          if (container.hitArea) {
            return true;
          }
          if (container.view?.containsPoint) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            return container.view.containsPoint(tempLocalMapping);
          }
          return false;
        }
        notifyTarget(e2, type) {
          type = type ?? e2.type;
          const handlerKey = `on${type}`;
          e2.currentTarget[handlerKey]?.(e2);
          const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
          this._notifyListeners(e2, key);
          if (e2.eventPhase === e2.AT_TARGET) {
            this._notifyListeners(e2, type);
          }
        }
        mapPointerDown(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const e2 = this.createPointerEvent(from);
          this.dispatchEvent(e2, "pointerdown");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchstart");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
          }
          const trackingData = this.trackingData(from.pointerId);
          trackingData.pressTargetsByButton[from.button] = e2.composedPath();
          this.freeEvent(e2);
        }
        mapPointerMove(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          this._isPointerMoveEvent = true;
          const e2 = this.createPointerEvent(from);
          this._isPointerMoveEvent = false;
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          const trackingData = this.trackingData(from.pointerId);
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
            const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
            const outEvent = this.createPointerEvent(from, outType, outTarget);
            this.dispatchEvent(outEvent, "pointerout");
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            if (!e2.composedPath().includes(outTarget)) {
              const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse)
                  this.notifyTarget(leaveEvent, "mouseleave");
                leaveEvent.target = leaveEvent.target.parent;
              }
              this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
          }
          if (outTarget !== e2.target) {
            const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
            const overEvent = this.clonePointerEvent(e2, overType);
            this.dispatchEvent(overEvent, "pointerover");
            if (isMouse)
              this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget?.parent;
            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
              if (overTargetAncestor === e2.target)
                break;
              overTargetAncestor = overTargetAncestor.parent;
            }
            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
            if (didPointerEnter) {
              const enterEvent = this.clonePointerEvent(e2, "pointerenter");
              enterEvent.eventPhase = enterEvent.AT_TARGET;
              while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
                enterEvent.currentTarget = enterEvent.target;
                this.notifyTarget(enterEvent);
                if (isMouse)
                  this.notifyTarget(enterEvent, "mouseenter");
                enterEvent.target = enterEvent.target.parent;
              }
              this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
          }
          const allMethods = [];
          const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
          this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
          allowGlobalPointerEvents && allMethods.push("globalpointermove");
          if (e2.pointerType === "touch") {
            this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
            allowGlobalPointerEvents && allMethods.push("globaltouchmove");
          }
          if (isMouse) {
            this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
            allowGlobalPointerEvents && allMethods.push("globalmousemove");
            this.cursor = e2.target?.cursor;
          }
          if (allMethods.length > 0) {
            this.all(e2, allMethods);
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
        }
        mapPointerOver(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const e2 = this.createPointerEvent(from);
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          this.dispatchEvent(e2, "pointerover");
          if (isMouse)
            this.dispatchEvent(e2, "mouseover");
          if (e2.pointerType === "mouse")
            this.cursor = e2.target?.cursor;
          const enterEvent = this.clonePointerEvent(e2, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse)
              this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
          }
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
          this.freeEvent(enterEvent);
        }
        mapPointerOut(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          if (trackingData.overTargets) {
            const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
            this.dispatchEvent(outEvent);
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            trackingData.overTargets = null;
            this.freeEvent(outEvent);
            this.freeEvent(leaveEvent);
          }
          this.cursor = null;
        }
        mapPointerUp(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const now = performance.now();
          const e2 = this.createPointerEvent(from);
          this.dispatchEvent(e2, "pointerup");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchend");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e2.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            while (currentTarget && !e2.composedPath().includes(currentTarget)) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                const isRightButton = e2.button === 2;
                this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
            clickTarget = currentTarget;
          }
          if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e2, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = null;
            if (!trackingData.clicksByButton[from.button]) {
              trackingData.clicksByButton[from.button] = {
                clickCount: 0,
                target: clickEvent.target,
                timeStamp: now
              };
            }
            const clickHistory = trackingData.clicksByButton[from.button];
            if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
              ++clickHistory.clickCount;
            } else {
              clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now;
            clickEvent.detail = clickHistory.clickCount;
            if (clickEvent.pointerType === "mouse") {
              const isRightButton = clickEvent.button === 2;
              this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else if (clickEvent.pointerType === "touch") {
              this.dispatchEvent(clickEvent, "tap");
            }
            this.dispatchEvent(clickEvent, "pointertap");
            this.freeEvent(clickEvent);
          }
          this.freeEvent(e2);
        }
        mapPointerUpOutside(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          const e2 = this.createPointerEvent(from);
          if (pressTarget) {
            let currentTarget = pressTarget;
            while (currentTarget) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
          }
          this.freeEvent(e2);
        }
        mapWheel(from) {
          if (!(from instanceof FederatedWheelEvent)) {
            warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
          }
          const wheelEvent = this.createWheelEvent(from);
          this.dispatchEvent(wheelEvent);
          this.freeEvent(wheelEvent);
        }
        findMountedTarget(propagationPath) {
          if (!propagationPath) {
            return null;
          }
          let currentTarget = propagationPath[0];
          for (let i2 = 1; i2 < propagationPath.length; i2++) {
            if (propagationPath[i2].parent === currentTarget) {
              currentTarget = propagationPath[i2];
            } else {
              break;
            }
          }
          return currentTarget;
        }
        createPointerEvent(from, type, target) {
          const event = this.allocateEvent(FederatedPointerEvent);
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
          if (typeof type === "string") {
            event.type = type;
          }
          return event;
        }
        createWheelEvent(from) {
          const event = this.allocateEvent(FederatedWheelEvent);
          this.copyWheelData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = this.hitTest(event.global.x, event.global.y);
          return event;
        }
        clonePointerEvent(from, type) {
          const event = this.allocateEvent(FederatedPointerEvent);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from.originalEvent;
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.target = from.target;
          event.path = from.composedPath().slice();
          event.type = type ?? event.type;
          return event;
        }
        copyWheelData(from, to) {
          to.deltaMode = from.deltaMode;
          to.deltaX = from.deltaX;
          to.deltaY = from.deltaY;
          to.deltaZ = from.deltaZ;
        }
        copyPointerData(from, to) {
          if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
            return;
          to.pointerId = from.pointerId;
          to.width = from.width;
          to.height = from.height;
          to.isPrimary = from.isPrimary;
          to.pointerType = from.pointerType;
          to.pressure = from.pressure;
          to.tangentialPressure = from.tangentialPressure;
          to.tiltX = from.tiltX;
          to.tiltY = from.tiltY;
          to.twist = from.twist;
        }
        copyMouseData(from, to) {
          if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
            return;
          to.altKey = from.altKey;
          to.button = from.button;
          to.buttons = from.buttons;
          to.client.copyFrom(from.client);
          to.ctrlKey = from.ctrlKey;
          to.metaKey = from.metaKey;
          to.movement.copyFrom(from.movement);
          to.screen.copyFrom(from.screen);
          to.shiftKey = from.shiftKey;
          to.global.copyFrom(from.global);
        }
        copyData(from, to) {
          to.isTrusted = from.isTrusted;
          to.srcElement = from.srcElement;
          to.timeStamp = performance.now();
          to.type = from.type;
          to.detail = from.detail;
          to.view = from.view;
          to.which = from.which;
          to.layer.copyFrom(from.layer);
          to.page.copyFrom(from.page);
        }
        trackingData(id) {
          if (!this.mappingState.trackingData[id]) {
            this.mappingState.trackingData[id] = {
              pressTargetsByButton: {},
              clicksByButton: {},
              overTarget: null
            };
          }
          return this.mappingState.trackingData[id];
        }
        allocateEvent(constructor) {
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          const event = this.eventPool.get(constructor).pop() || new constructor(this);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.path = null;
          event.target = null;
          return event;
        }
        freeEvent(event) {
          if (event.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
          const constructor = event.constructor;
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          this.eventPool.get(constructor).push(event);
        }
        _notifyListeners(e2, type) {
          const listeners = e2.currentTarget._events[type];
          if (!listeners)
            return;
          if (!e2.currentTarget.isInteractive())
            return;
          if ("fn" in listeners) {
            if (listeners.once)
              e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
            listeners.fn.call(listeners.context, e2);
          } else {
            for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e2.propagationImmediatelyStopped; i2++) {
              if (listeners[i2].once)
                e2.currentTarget.removeListener(type, listeners[i2].fn, void 0, true);
              listeners[i2].fn.call(listeners[i2].context, e2);
            }
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/events/EventSystem.mjs
  var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
  var init_EventSystem = __esm({
    "node_modules/pixi-v8/lib/events/EventSystem.mjs"() {
      init_Extensions();
      init_EventBoundary();
      init_EventTicker();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      MOUSE_POINTER_ID = 1;
      TOUCH_TO_POINTER = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
      _EventSystem = class {
        constructor(renderer) {
          this.supportsTouchEvents = "ontouchstart" in globalThis;
          this.supportsPointerEvents = !!globalThis.PointerEvent;
          this.domElement = null;
          this.resolution = 1;
          this.renderer = renderer;
          this.rootBoundary = new EventBoundary(null);
          EventsTicker.init(this);
          this.autoPreventDefault = true;
          this._eventsAdded = false;
          this._rootPointerEvent = new FederatedPointerEvent(null);
          this._rootWheelEvent = new FederatedWheelEvent(null);
          this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
          };
          this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
            set: (target, key, value) => {
              if (key === "globalMove") {
                this.rootBoundary.enableGlobalMoveEvents = value;
              }
              target[key] = value;
              return true;
            }
          });
          this._onPointerDown = this._onPointerDown.bind(this);
          this._onPointerMove = this._onPointerMove.bind(this);
          this._onPointerUp = this._onPointerUp.bind(this);
          this._onPointerOverOut = this._onPointerOverOut.bind(this);
          this.onWheel = this.onWheel.bind(this);
        }
        static get defaultEventMode() {
          return this._defaultEventMode;
        }
        init(options) {
          const { canvas: canvas2, resolution } = this.renderer;
          this.setTargetElement(canvas2);
          this.resolution = resolution;
          _EventSystem._defaultEventMode = options.eventMode ?? "passive";
          Object.assign(this.features, options.eventFeatures ?? {});
          this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
        }
        resolutionChange(resolution) {
          this.resolution = resolution;
        }
        destroy() {
          this.setTargetElement(null);
          this.renderer = null;
          this._currentCursor = null;
        }
        setCursor(mode) {
          mode = mode || "default";
          let applyStyles = true;
          if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
            applyStyles = false;
          }
          if (this._currentCursor === mode) {
            return;
          }
          this._currentCursor = mode;
          const style = this.cursorStyles[mode];
          if (style) {
            switch (typeof style) {
              case "string":
                if (applyStyles) {
                  this.domElement.style.cursor = style;
                }
                break;
              case "function":
                style(mode);
                break;
              case "object":
                if (applyStyles) {
                  Object.assign(this.domElement.style, style);
                }
                break;
            }
          } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.domElement.style.cursor = mode;
          }
        }
        get pointer() {
          return this._rootPointerEvent;
        }
        _onPointerDown(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const events = this._normalizeToPointerData(nativeEvent);
          if (this.autoPreventDefault && events[0].isNormalized) {
            const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
            const nativeEvent2 = events[i2];
            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerMove(nativeEvent) {
          if (!this.features.move)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          EventsTicker.pointerMoved();
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerUp(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          let target = nativeEvent.target;
          if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target = nativeEvent.composedPath()[0];
          }
          const outside = target !== this.domElement ? "outside" : "";
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            event.type += outside;
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerOverOut(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        onWheel(nativeEvent) {
          if (!this.features.wheel)
            return;
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          this.rootBoundary.mapEvent(wheelEvent);
        }
        setTargetElement(element) {
          this._removeEvents();
          this.domElement = element;
          EventsTicker.domElement = element;
          this._addEvents();
        }
        _addEvents() {
          if (this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.addTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "none";
              style.msTouchAction = "none";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "none";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
            this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.addEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
            this.domElement.addEventListener("mousedown", this._onPointerDown, true);
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.addEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.addEventListener("touchstart", this._onPointerDown, true);
              this.domElement.addEventListener("touchend", this._onPointerUp, true);
              this.domElement.addEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
          });
          this._eventsAdded = true;
        }
        _removeEvents() {
          if (!this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.removeTickerListener();
          const style = this.domElement.style;
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "";
            style.msTouchAction = "";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "";
          }
          if (this.supportsPointerEvents) {
            globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.removeEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
            this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.removeEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
              this.domElement.removeEventListener("touchend", this._onPointerUp, true);
              this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.removeEventListener("wheel", this.onWheel, true);
          this.domElement = null;
          this._eventsAdded = false;
        }
        mapPositionToPoint(point, x2, y2) {
          const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
          };
          const resolutionMultiplier = 1 / this.resolution;
          point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
          point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
        }
        _normalizeToPointerData(event) {
          const normalizedEvents = [];
          if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
              const touch = event.changedTouches[i2];
              if (typeof touch.button === "undefined")
                touch.button = 0;
              if (typeof touch.buttons === "undefined")
                touch.buttons = 1;
              if (typeof touch.isPrimary === "undefined") {
                touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
              }
              if (typeof touch.width === "undefined")
                touch.width = touch.radiusX || 1;
              if (typeof touch.height === "undefined")
                touch.height = touch.radiusY || 1;
              if (typeof touch.tiltX === "undefined")
                touch.tiltX = 0;
              if (typeof touch.tiltY === "undefined")
                touch.tiltY = 0;
              if (typeof touch.pointerType === "undefined")
                touch.pointerType = "touch";
              if (typeof touch.pointerId === "undefined")
                touch.pointerId = touch.identifier || 0;
              if (typeof touch.pressure === "undefined")
                touch.pressure = touch.force || 0.5;
              if (typeof touch.twist === "undefined")
                touch.twist = 0;
              if (typeof touch.tangentialPressure === "undefined")
                touch.tangentialPressure = 0;
              if (typeof touch.layerX === "undefined")
                touch.layerX = touch.offsetX = touch.clientX;
              if (typeof touch.layerY === "undefined")
                touch.layerY = touch.offsetY = touch.clientY;
              touch.isNormalized = true;
              touch.type = event.type;
              normalizedEvents.push(touch);
            }
          } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            if (typeof tempEvent.isPrimary === "undefined")
              tempEvent.isPrimary = true;
            if (typeof tempEvent.width === "undefined")
              tempEvent.width = 1;
            if (typeof tempEvent.height === "undefined")
              tempEvent.height = 1;
            if (typeof tempEvent.tiltX === "undefined")
              tempEvent.tiltX = 0;
            if (typeof tempEvent.tiltY === "undefined")
              tempEvent.tiltY = 0;
            if (typeof tempEvent.pointerType === "undefined")
              tempEvent.pointerType = "mouse";
            if (typeof tempEvent.pointerId === "undefined")
              tempEvent.pointerId = MOUSE_POINTER_ID;
            if (typeof tempEvent.pressure === "undefined")
              tempEvent.pressure = 0.5;
            if (typeof tempEvent.twist === "undefined")
              tempEvent.twist = 0;
            if (typeof tempEvent.tangentialPressure === "undefined")
              tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
          } else {
            normalizedEvents.push(event);
          }
          return normalizedEvents;
        }
        normalizeWheelEvent(nativeEvent) {
          const event = this._rootWheelEvent;
          this._transferMouseData(event, nativeEvent);
          event.deltaX = nativeEvent.deltaX;
          event.deltaY = nativeEvent.deltaY;
          event.deltaZ = nativeEvent.deltaZ;
          event.deltaMode = nativeEvent.deltaMode;
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.nativeEvent = nativeEvent;
          event.type = nativeEvent.type;
          return event;
        }
        _bootstrapEvent(event, nativeEvent) {
          event.originalEvent = null;
          event.nativeEvent = nativeEvent;
          event.pointerId = nativeEvent.pointerId;
          event.width = nativeEvent.width;
          event.height = nativeEvent.height;
          event.isPrimary = nativeEvent.isPrimary;
          event.pointerType = nativeEvent.pointerType;
          event.pressure = nativeEvent.pressure;
          event.tangentialPressure = nativeEvent.tangentialPressure;
          event.tiltX = nativeEvent.tiltX;
          event.tiltY = nativeEvent.tiltY;
          event.twist = nativeEvent.twist;
          this._transferMouseData(event, nativeEvent);
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.isTrusted = nativeEvent.isTrusted;
          if (event.type === "pointerleave") {
            event.type = "pointerout";
          }
          if (event.type.startsWith("mouse")) {
            event.type = event.type.replace("mouse", "pointer");
          }
          if (event.type.startsWith("touch")) {
            event.type = TOUCH_TO_POINTER[event.type] || event.type;
          }
          return event;
        }
        _transferMouseData(event, nativeEvent) {
          event.isTrusted = nativeEvent.isTrusted;
          event.srcElement = nativeEvent.srcElement;
          event.timeStamp = performance.now();
          event.type = nativeEvent.type;
          event.altKey = nativeEvent.altKey;
          event.button = nativeEvent.button;
          event.buttons = nativeEvent.buttons;
          event.client.x = nativeEvent.clientX;
          event.client.y = nativeEvent.clientY;
          event.ctrlKey = nativeEvent.ctrlKey;
          event.metaKey = nativeEvent.metaKey;
          event.movement.x = nativeEvent.movementX;
          event.movement.y = nativeEvent.movementY;
          event.page.x = nativeEvent.pageX;
          event.page.y = nativeEvent.pageY;
          event.relatedTarget = null;
          event.shiftKey = nativeEvent.shiftKey;
        }
      };
      EventSystem = _EventSystem;
      EventSystem.extension = {
        name: "events",
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.CanvasSystem,
          ExtensionType.WebGPUSystem
        ],
        priority: -1
      };
      EventSystem.defaultEventFeatures = {
        move: true,
        globalMove: true,
        click: true,
        wheel: true
      };
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedEventTarget.mjs
  var FederatedContainer;
  var init_FederatedEventTarget = __esm({
    "node_modules/pixi-v8/lib/events/FederatedEventTarget.mjs"() {
      init_EventSystem();
      init_FederatedEvent();
      FederatedContainer = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
          return this.eventMode === "dynamic" || this.eventMode === "static";
        },
        set interactive(value) {
          this.eventMode = value ? "static" : "passive";
        },
        _internalEventMode: void 0,
        get eventMode() {
          return this._internalEventMode ?? EventSystem.defaultEventMode;
        },
        set eventMode(value) {
          this._internalEventMode = value;
        },
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic";
        },
        interactiveChildren: true,
        hitArea: null,
        addEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const context2 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          listener = typeof listener === "function" ? listener : listener.handleEvent;
          this.on(type, listener, context2);
        },
        removeEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const context2 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          listener = typeof listener === "function" ? listener : listener.handleEvent;
          this.off(type, listener, context2);
        },
        dispatchEvent(e2) {
          if (!(e2 instanceof FederatedEvent)) {
            throw new Error("Container cannot propagate events outside of the Federated Events API");
          }
          e2.defaultPrevented = false;
          e2.path = null;
          e2.target = this;
          e2.manager.dispatchEvent(e2);
          return !e2.defaultPrevented;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/events/init.mjs
  var init_init4 = __esm({
    "node_modules/pixi-v8/lib/events/init.mjs"() {
      init_Extensions();
      init_Container();
      init_EventSystem();
      init_FederatedEventTarget();
      extensions.add(EventSystem);
      Container.mixin(FederatedContainer);
    }
  });

  // node_modules/pixi-v8/lib/spritesheet/Spritesheet.mjs
  var _Spritesheet, Spritesheet;
  var init_Spritesheet = __esm({
    "node_modules/pixi-v8/lib/spritesheet/Spritesheet.mjs"() {
      init_Rectangle();
      init_Texture();
      _Spritesheet = class {
        constructor(texture, data) {
          this.linkedSheets = [];
          this._texture = texture instanceof Texture ? texture : null;
          this.textureSource = texture.source;
          this.textures = {};
          this.animations = {};
          this.data = data;
          const metaResolution = parseFloat(data.meta.scale);
          if (metaResolution) {
            this.resolution = metaResolution;
            texture.source.resolution = this.resolution;
          } else {
            this.resolution = texture.source._resolution;
          }
          this._frames = this.data.frames;
          this._frameKeys = Object.keys(this._frames);
          this._batchIndex = 0;
          this._callback = null;
        }
        parse() {
          return new Promise((resolve) => {
            this._callback = resolve;
            this._batchIndex = 0;
            if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
              this._processFrames(0);
              this._processAnimations();
              this._parseComplete();
            } else {
              this._nextBatch();
            }
          });
        }
        _processFrames(initialFrameIndex) {
          let frameIndex = initialFrameIndex;
          const maxFrames = _Spritesheet.BATCH_SIZE;
          while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            const i2 = this._frameKeys[frameIndex];
            const data = this._frames[i2];
            const rect = data.frame;
            if (rect) {
              let frame = null;
              let trim = null;
              const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
              const orig = new Rectangle(
                0,
                0,
                Math.floor(sourceSize.w) / this.resolution,
                Math.floor(sourceSize.h) / this.resolution
              );
              if (data.rotated) {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.h) / this.resolution,
                  Math.floor(rect.w) / this.resolution
                );
              } else {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              if (data.trimmed !== false && data.spriteSourceSize) {
                trim = new Rectangle(
                  Math.floor(data.spriteSourceSize.x) / this.resolution,
                  Math.floor(data.spriteSourceSize.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
                trim.x /= this.textureSource.width;
                trim.y /= this.textureSource.height;
                trim.width /= this.textureSource.width;
                trim.height /= this.textureSource.height;
              }
              frame.x /= this.textureSource.width;
              frame.y /= this.textureSource.height;
              frame.width /= this.textureSource.width;
              frame.height /= this.textureSource.height;
              orig.x /= this.textureSource.width;
              orig.y /= this.textureSource.height;
              orig.width /= this.textureSource.width;
              orig.height /= this.textureSource.height;
              this.textures[i2] = new Texture({
                source: this.textureSource,
                layout: {
                  frame,
                  orig,
                  trim,
                  rotate: data.rotated ? 2 : 0,
                  defaultAnchor: data.anchor,
                  defaultBorders: data.borders
                },
                label: i2.toString()
              });
            }
            frameIndex++;
          }
        }
        _processAnimations() {
          const animations = this.data.animations || {};
          for (const animName in animations) {
            this.animations[animName] = [];
            for (let i2 = 0; i2 < animations[animName].length; i2++) {
              const frameName = animations[animName][i2];
              this.animations[animName].push(this.textures[frameName]);
            }
          }
        }
        _parseComplete() {
          const callback = this._callback;
          this._callback = null;
          this._batchIndex = 0;
          callback.call(this, this.textures);
        }
        _nextBatch() {
          this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
          this._batchIndex++;
          setTimeout(() => {
            if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
              this._nextBatch();
            } else {
              this._processAnimations();
              this._parseComplete();
            }
          }, 0);
        }
        destroy(destroyBase = false) {
          for (const i2 in this.textures) {
            this.textures[i2].destroy();
          }
          this._frames = null;
          this._frameKeys = null;
          this.data = null;
          this.textures = null;
          if (destroyBase) {
            this._texture?.destroy();
            this.textureSource.destroy();
          }
          this._texture = null;
          this.textureSource = null;
          this.linkedSheets = [];
        }
      };
      Spritesheet = _Spritesheet;
      Spritesheet.BATCH_SIZE = 1e3;
    }
  });

  // node_modules/pixi-v8/lib/spritesheet/spritesheetAsset.mjs
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out2 = {};
    keys.forEach((key) => {
      out2[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out2[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i2) => {
        const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
        Object.assign(out2, out22);
      });
    }
    return out2;
  }
  var validImages, spritesheetAsset;
  var init_spritesheetAsset = __esm({
    "node_modules/pixi-v8/lib/spritesheet/spritesheetAsset.mjs"() {
      init_LoaderParser();
      init_copySearchParams();
      init_Extensions();
      init_settings();
      init_path();
      init_Spritesheet();
      validImages = ["jpg", "png", "jpeg", "avif", "webp"];
      spritesheetAsset = {
        extension: ExtensionType.Asset,
        cache: {
          test: (asset) => asset instanceof Spritesheet,
          getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
        },
        resolver: {
          test: (value) => {
            const tempURL = value.split("?")[0];
            const split = tempURL.split(".");
            const extension = split.pop();
            const format = split.pop();
            return extension === "json" && validImages.includes(format);
          },
          parse: (value) => {
            const split = value.split(".");
            return {
              resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
              format: split[split.length - 2],
              src: value
            };
          }
        },
        loader: {
          name: "spritesheetLoader",
          extension: {
            type: ExtensionType.LoadParser,
            priority: LoaderParserPriority.Normal
          },
          async testParse(asset, options) {
            return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
          },
          async parse(asset, options, loader) {
            let basePath = path.dirname(options.src);
            if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
              basePath += "/";
            }
            let imagePath = basePath + asset.meta.image;
            imagePath = copySearchParams(imagePath, options.src);
            const assets = await loader.load([imagePath]);
            const texture = assets[imagePath];
            const spritesheet = new Spritesheet(
              texture.source,
              asset
            );
            await spritesheet.parse();
            const multiPacks = asset?.meta?.related_multi_packs;
            if (Array.isArray(multiPacks)) {
              const promises = [];
              for (const item of multiPacks) {
                if (typeof item !== "string") {
                  continue;
                }
                let itemUrl = basePath + item;
                if (options.data?.ignoreMultiPack) {
                  continue;
                }
                itemUrl = copySearchParams(itemUrl, options.src);
                promises.push(loader.load({
                  src: itemUrl,
                  data: {
                    ignoreMultiPack: true
                  }
                }));
              }
              const res = await Promise.all(promises);
              spritesheet.linkedSheets = res;
              res.forEach((item) => {
                item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
              });
            }
            return spritesheet;
          },
          unload(spritesheet) {
            spritesheet.destroy(true);
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/spritesheet/init.mjs
  var init_init5 = __esm({
    "node_modules/pixi-v8/lib/spritesheet/init.mjs"() {
      init_Extensions();
      init_spritesheetAsset();
      extensions.add(spritesheetAsset);
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/view/View.mjs
  var emptyViewObserver;
  var init_View = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/view/View.mjs"() {
      emptyViewObserver = {
        onViewUpdate: () => {
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/updateQuadBounds.mjs
  function updateQuadBounds(bounds, anchor, texture, padding) {
    const textureSource = texture._source;
    const layout = texture.layout;
    const orig = layout.orig;
    const trim = layout.trim;
    const textureSourceWidth = textureSource.width;
    const textureSourceHeight = textureSource.height;
    const width = textureSourceWidth * orig.width;
    const height = textureSourceHeight * orig.height;
    if (trim) {
      const sourceWidth = textureSourceWidth * trim.width;
      const sourceHeight = textureSourceHeight * trim.height;
      bounds[0] = trim.x * textureSourceWidth - anchor._x * width - padding;
      bounds[1] = bounds[0] + sourceWidth;
      bounds[2] = trim.y * textureSourceHeight - anchor._y * height - padding;
      bounds[3] = bounds[2] + sourceHeight;
    } else {
      bounds[0] = -anchor._x * width - padding;
      bounds[1] = bounds[0] + width;
      bounds[2] = -anchor._y * height - padding;
      bounds[3] = bounds[2] + height;
    }
    return;
  }
  var init_updateQuadBounds = __esm({
    "node_modules/pixi-v8/lib/utils/updateQuadBounds.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite/SpriteView.mjs
  var SpriteView;
  var init_SpriteView = __esm({
    "node_modules/pixi-v8/lib/scene/sprite/SpriteView.mjs"() {
      init_ObservablePoint();
      init_Texture();
      init_View();
      init_uid();
      init_updateQuadBounds();
      SpriteView = class {
        constructor(texture) {
          this.renderPipeId = "sprite";
          this.owner = emptyViewObserver;
          this.uid = uid("spriteView");
          this.batched = true;
          this._didUpdate = false;
          this._bounds = [0, 1, 0, 0];
          this._sourceBounds = [0, 1, 0, 0];
          this._boundsDirty = true;
          this._sourceBoundsDirty = true;
          this.roundPixels = 0;
          this.anchor = new ObservablePoint(
            this,
            texture.layout.defaultAnchor?.x || 0,
            texture.layout.defaultAnchor?.y || 0
          );
          this.texture = texture;
        }
        set texture(value) {
          value || (value = Texture.EMPTY);
          if (this._texture === value)
            return;
          if (this._texture) {
            this._texture.off("update", this.onUpdate, this);
          }
          value.on("update", this.onUpdate, this);
          this._texture = value;
          this.onUpdate();
        }
        get texture() {
          return this._texture;
        }
        get bounds() {
          if (this._boundsDirty) {
            this._updateBounds();
            this._boundsDirty = false;
          }
          return this._bounds;
        }
        get sourceBounds() {
          if (this._sourceBoundsDirty) {
            this._updateSourceBounds();
            this._sourceBoundsDirty = false;
          }
          return this._sourceBounds;
        }
        containsPoint(point) {
          const width = this._texture.frameWidth;
          const height = this._texture.frameHeight;
          const x1 = -width * this.anchor.x;
          let y1 = 0;
          if (point.x >= x1 && point.x < x1 + width) {
            y1 = -height * this.anchor.y;
            if (point.y >= y1 && point.y < y1 + height) {
              return true;
            }
          }
          return false;
        }
        addBounds(bounds) {
          const trim = this._texture._layout.trim;
          if (trim) {
            const sourceBounds = this.sourceBounds;
            bounds.addFrame(sourceBounds[0], sourceBounds[2], sourceBounds[1], sourceBounds[3]);
          } else {
            const _bounds = this.bounds;
            bounds.addFrame(_bounds[0], _bounds[2], _bounds[1], _bounds[3]);
          }
        }
        onUpdate() {
          this._didUpdate = true;
          this._sourceBoundsDirty = this._boundsDirty = true;
          this.owner.onViewUpdate();
        }
        _updateBounds() {
          updateQuadBounds(this._bounds, this.anchor, this._texture, 0);
        }
        _updateSourceBounds() {
          const anchor = this.anchor;
          const texture = this._texture;
          const textureSource = texture._source;
          const layout = texture.layout;
          const orig = layout.orig;
          const sourceBounds = this._sourceBounds;
          const width = textureSource.width * orig.width;
          const height = textureSource.height * orig.height;
          sourceBounds[1] = -anchor._x * width;
          sourceBounds[0] = sourceBounds[1] + width;
          sourceBounds[3] = -anchor._y * height;
          sourceBounds[2] = sourceBounds[3] + height;
        }
        destroy(options = false) {
          this.anchor = null;
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
          this._bounds = null;
          this._sourceBounds = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite/Sprite.mjs
  var Sprite;
  var init_Sprite = __esm({
    "node_modules/pixi-v8/lib/scene/sprite/Sprite.mjs"() {
      init_Cache();
      init_Texture();
      init_Container();
      init_SpriteView();
      Sprite = class extends Container {
        static from(id) {
          if (typeof id === "string") {
            return new Sprite(Cache.get(id));
          }
          return new Sprite(id);
        }
        constructor(options = Texture.EMPTY) {
          if (options instanceof Texture) {
            options = { texture: options };
          }
          const { texture, ...rest } = options;
          super({
            view: new SpriteView(texture ?? Texture.EMPTY),
            label: "Sprite",
            ...rest
          });
          this.allowChildren = false;
        }
        get anchor() {
          return this.view.anchor;
        }
        set anchor(value) {
          this.view.anchor.x = value.x;
          this.view.anchor.y = value.y;
        }
        get texture() {
          return this.view.texture;
        }
        set texture(value) {
          this.view.texture = value;
        }
        get roundPixels() {
          return !!this.view.roundPixels;
        }
        set roundPixels(value) {
          this.view.roundPixels = value ? 1 : 0;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/utils/addMaskBounds.mjs
  function addMaskBounds(mask, bounds, skipUpdateTransform) {
    const boundsToMask = tempBounds2;
    mask.measurable = true;
    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
    bounds.addBoundsMask(boundsToMask);
    mask.measurable = false;
  }
  var tempBounds2;
  var init_addMaskBounds = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/utils/addMaskBounds.mjs"() {
      init_Bounds();
      init_getGlobalBounds();
      tempBounds2 = new Bounds();
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/utils/addMaskLocalBounds.mjs
  function addMaskLocalBounds(mask, bounds, localRoot) {
    const boundsToMask = new Bounds();
    mask.measurable = true;
    const relativeMask = getMatrixRelativeToParent(mask, localRoot, new Matrix());
    getLocalBounds(mask, boundsToMask, relativeMask);
    mask.measurable = false;
    bounds.addBoundsMask(boundsToMask);
  }
  function getMatrixRelativeToParent(target, root, matrix) {
    if (!target) {
      warn("Item is not inside the root container");
      return matrix;
    }
    if (target !== root) {
      getMatrixRelativeToParent(target.parent, root, matrix);
      if (target.didChange) {
        updateLocalTransform(target.localTransform, target);
      }
      matrix.append(target.localTransform);
    }
    return matrix;
  }
  var init_addMaskLocalBounds = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
      init_Matrix();
      init_Bounds();
      init_getLocalBounds();
      init_updateLocalTransform();
      init_warn();
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/alpha/AlphaMask.mjs
  var AlphaMask;
  var init_AlphaMask = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/alpha/AlphaMask.mjs"() {
      init_Extensions();
      init_Sprite();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      AlphaMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "alphaMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.renderMaskToTexture = !(mask instanceof Sprite);
          this.mask.renderable = this.renderMaskToTexture;
          this.mask.includeInBuild = !this.renderMaskToTexture;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Sprite;
        }
      };
      AlphaMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/color/ColorMask.mjs
  var ColorMask;
  var init_ColorMask = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/color/ColorMask.mjs"() {
      init_Extensions();
      ColorMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "colorMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
        }
        destroy() {
        }
        static test(mask) {
          return typeof mask === "number";
        }
      };
      ColorMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/stencil/StencilMask.mjs
  var StencilMask;
  var init_StencilMask = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/stencil/StencilMask.mjs"() {
      init_Extensions();
      init_Container();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      StencilMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "stencilMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.mask.includeInBuild = false;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask.includeInBuild = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Container;
        }
      };
      StencilMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi-v8/lib/rendering/init.mjs
  var init_init6 = __esm({
    "node_modules/pixi-v8/lib/rendering/init.mjs"() {
      init_Extensions();
      init_AlphaMask();
      init_ColorMask();
      init_StencilMask();
      extensions.add(AlphaMask, ColorMask, StencilMask);
    }
  });

  // node_modules/pixi-v8/lib/all.mjs
  var all_exports = {};
  var init_all = __esm({
    "node_modules/pixi-v8/lib/all.mjs"() {
      init_init2();
      init_init3();
      init_init4();
      init_init5();
      init_init6();
      init_init();
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/isWebGLSupported.mjs
  function isWebGLSupported() {
    if (typeof supported === "undefined") {
      supported = function supported2() {
        const contextOptions = {
          stencil: true,
          failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
          if (!settings.ADAPTER.getWebGLRenderingContext()) {
            return false;
          }
          const canvas2 = settings.ADAPTER.createCanvas();
          let gl = canvas2.getContext("webgl2", contextOptions);
          const success = !!gl?.getContextAttributes()?.stencil;
          if (gl) {
            const loseContext = gl.getExtension("WEBGL_lose_context");
            if (loseContext) {
              loseContext.loseContext();
            }
          }
          gl = null;
          return success;
        } catch (e2) {
          return false;
        }
      }();
    }
    return supported;
  }
  var supported;
  var init_isWebGLSupported = __esm({
    "node_modules/pixi-v8/lib/utils/browser/isWebGLSupported.mjs"() {
      init_settings();
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/isWebGPUSupported.mjs
  async function isWebGPUSupported(options = {}) {
    const gpu = settings.ADAPTER.getNavigator().gpu;
    if (!gpu)
      return false;
    try {
      const adapter = await navigator.gpu.requestAdapter(options);
      await adapter.requestDevice();
      return true;
    } catch (e2) {
      return false;
    }
  }
  var init_isWebGPUSupported = __esm({
    "node_modules/pixi-v8/lib/utils/browser/isWebGPUSupported.mjs"() {
      init_settings();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/BindGroup.mjs
  var BindGroup;
  var init_BindGroup = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
      BindGroup = class {
        constructor(resources) {
          this.resources = /* @__PURE__ */ Object.create(null);
          this._dirty = true;
          let index = 0;
          for (const i2 in resources) {
            const resource = resources[i2];
            this.setResource(resource, index++);
          }
          this.updateKey();
        }
        update() {
          this.updateKey();
        }
        updateKey() {
          if (!this._dirty)
            return;
          this._dirty = false;
          const keyParts = [];
          let index = 0;
          for (const i2 in this.resources) {
            keyParts[index++] = this.resources[i2].resourceId;
          }
          this.key = keyParts.join("|");
        }
        setResource(resource, index) {
          const currentResource = this.resources[index];
          if (resource === currentResource)
            return;
          if (currentResource) {
            resource.off?.("change", this.onResourceChange, this);
          }
          resource.on?.("change", this.onResourceChange, this);
          this.resources[index] = resource;
          this._dirty = true;
        }
        getResource(index) {
          return this.resources[index];
        }
        touch(tick) {
          const resources = this.resources;
          for (const i2 in resources) {
            resources[i2].touched = tick;
          }
        }
        destroy() {
          const resources = this.resources;
          for (const i2 in resources) {
            const resource = resources[i2];
            resource.off?.("change", this.onResourceChange, this);
          }
          this.resources = null;
        }
        onResourceChange() {
          this._dirty = true;
          this.update();
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/const.mjs
  var MAX_TEXTURES;
  var init_const3 = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/const.mjs"() {
      MAX_TEXTURES = 16;
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
  function getTextureBatchBindGroup(textures, size2) {
    let uid2 = 0;
    for (let i2 = 0; i2 < size2; i2++) {
      uid2 = uid2 * 31 + textures[i2].uid >>> 0;
    }
    return cachedGroups[uid2] || generateTextureBatchBindGroup(textures, uid2);
  }
  function generateTextureBatchBindGroup(textures, key) {
    const bindGroupResources = {};
    let bindIndex = 0;
    for (let i2 = 0; i2 < MAX_TEXTURES; i2++) {
      const texture = i2 < textures.length ? textures[i2] : Texture.EMPTY.source;
      bindGroupResources[bindIndex++] = texture.source;
      bindGroupResources[bindIndex++] = texture.style;
    }
    const bindGroup = new BindGroup(bindGroupResources);
    cachedGroups[key] = bindGroup;
    return bindGroup;
  }
  var cachedGroups;
  var init_getTextureBatchBindGroup = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
      init_BindGroup();
      init_Texture();
      init_const3();
      cachedGroups = {};
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs
  function ensurePrecision(src, options, isFragment) {
    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
    if (src.substring(0, 9) !== "precision") {
      let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
      if (precision === "highp" && maxSupportedPrecision !== "highp") {
        precision = "mediump";
      }
      if (src.substring(0, 8) !== "#version") {
        return `precision ${precision} float;
${src}`;
      }
      const firstLineBreak = src.indexOf("\n");
      return `${src.substring(0, firstLineBreak + 1)}precision ${precision} float;
${src.substring(firstLineBreak + 1)}`;
    } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }
  var init_ensurePrecision = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
  function getTestContext() {
    if (context === unknownContext || context?.isContextLost()) {
      const canvas2 = settings.ADAPTER.createCanvas();
      context = canvas2.getContext("webgl2", {});
    }
    return context;
  }
  var unknownContext, context;
  var init_getTestContext = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
      init_settings();
      unknownContext = {};
      context = unknownContext;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = "mediump";
      const gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
        }
      }
    }
    return maxFragmentPrecision;
  }
  var maxFragmentPrecision;
  var init_getMaxFragmentPrecision = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
      init_getTestContext();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/setProgramName.mjs
  function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
    name = name.replace(/\s+/g, "-");
    name += isFragment ? "-fragment" : "-vertex";
    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
    if (nameCache[name]) {
      nameCache[name]++;
      name += `-${nameCache[name]}`;
    } else {
      nameCache[name] = 1;
    }
    if (src.indexOf("#define SHADER_NAME") !== -1)
      return src;
    const shaderName = `#define SHADER_NAME ${name}`;
    if (src.substring(0, 8) !== "#version") {
      return `${shaderName}
${src}`;
    }
    const firstLineBreak = src.indexOf("\n");
    return `${src.substring(0, firstLineBreak + 1)}${shaderName}
${src.substring(firstLineBreak + 1)}`;
  }
  var fragmentNameCache, VertexNameCache;
  var init_setProgramName = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/setProgramName.mjs"() {
      fragmentNameCache = {};
      VertexNameCache = {};
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs
  function setProgramVersion(src, { version = "300 es" }) {
    if (src.substring(0, 8) === "#version")
      return src;
    return `#version ${version}
${src}`;
  }
  var init_setProgramVersion = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlProgram.mjs
  var processes, _GlProgram, GlProgram;
  var init_GlProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
      init_ensurePrecision();
      init_getMaxFragmentPrecision();
      init_setProgramName();
      init_setProgramVersion();
      processes = {
        ensurePrecision,
        setProgramName,
        setProgramVersion
      };
      _GlProgram = class {
        constructor(options) {
          options = { ..._GlProgram.defaultOptions, ...options };
          const preprocessorOptions = {
            ensurePrecision: {
              requestedFragmentPrecision: options.preferredFragmentPrecision,
              requestedVertexPrecision: options.preferredVertexPrecision,
              maxSupportedVertexPrecision: "highp",
              maxSupportedFragmentPrecision: getMaxFragmentPrecision()
            },
            setProgramName: {
              name: options.name
            },
            setProgramVersion: {
              version: "300 es"
            }
          };
          let fragment2 = options.fragment;
          let vertex2 = options.vertex;
          Object.keys(processes).forEach((processKey) => {
            const processOptions = preprocessorOptions[processKey] ?? {};
            fragment2 = processes[processKey](fragment2, processOptions, true);
            vertex2 = processes[processKey](vertex2, processOptions, false);
          });
          this.fragment = fragment2;
          this.vertex = vertex2;
          this.key = `${this.vertex}:${this.fragment}`;
        }
        destroy() {
          this.fragment = null;
          this.vertex = null;
          this.attributeData = null;
          this.uniformData = null;
          this.uniformBlockData = null;
          this.transformFeedbackVaryings = null;
        }
        static from(options) {
          const key = `${options.vertex}:${options.fragment}`;
          if (!_GlProgram.programCached[key]) {
            _GlProgram.programCached[key] = new _GlProgram(options);
          }
          return _GlProgram.programCached[key];
        }
      };
      GlProgram = _GlProgram;
      GlProgram.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
      };
      GlProgram.programCached = /* @__PURE__ */ Object.create(null);
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs
  function extractStructAndGroups(wgsl) {
    const linePattern = /(?<!\/\/.*)@(group|binding)\(\d+\)[^;]+;/g;
    const groupPattern = /@group\((\d+)\)/;
    const bindingPattern = /@binding\((\d+)\)/;
    const namePattern = /var(<[^>]+>)? (\w+)/;
    const typePattern = /:\s*(\w+)/;
    const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
    const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
    const structName = /struct\s+(\w+)/;
    const groups = wgsl.match(linePattern)?.map((item) => ({
      group: parseInt(item.match(groupPattern)[1], 10),
      binding: parseInt(item.match(bindingPattern)[1], 10),
      name: item.match(namePattern)[2],
      isUniform: item.match(namePattern)[1] === "<uniform>",
      type: item.match(typePattern)[1]
    }));
    if (!groups) {
      return {
        groups: [],
        structs: []
      };
    }
    const structs = wgsl.match(structPattern)?.map((struct) => {
      const name = struct.match(structName)[1];
      const members = struct.match(structMemberPattern).reduce((acc, member) => {
        const [name2, type] = member.split(":");
        acc[name2.trim()] = type.trim();
        return acc;
      }, {});
      if (!members) {
        return null;
      }
      return { name, members };
    }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
    return {
      groups,
      structs
    };
  }
  var init_extractStructAndGroups = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/const.mjs
  var ShaderStage;
  var init_const4 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/const.mjs"() {
      ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
        ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
        ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
        ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
        return ShaderStage2;
      })(ShaderStage || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs
  function generateGpuLayoutGroups({ groups }) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (!layout[group.group]) {
        layout[group.group] = [];
      }
      if (group.isUniform) {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
          buffer: {
            type: "uniform"
          }
        });
      } else if (group.type === "sampler") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        });
      } else if (group.type === "texture_2d") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          texture: {
            sampleType: "float",
            viewDimension: "2d",
            multisampled: false
          }
        });
      }
    }
    return layout;
  }
  var init_generateGpuLayoutGroups = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs"() {
      init_const4();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs
  function generateLayoutHash({ groups }) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (!layout[group.group]) {
        layout[group.group] = {};
      }
      layout[group.group][group.name] = group.binding;
    }
    return layout;
  }
  var init_generateLayoutHash = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/removeStructAndGroupDuplicates.mjs
  function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
    const structNameSet = /* @__PURE__ */ new Set();
    const dupeGroupKeySet = /* @__PURE__ */ new Set();
    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
      if (structNameSet.has(struct.name)) {
        return false;
      }
      structNameSet.add(struct.name);
      return true;
    });
    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
      const key = `${group.name}-${group.binding}`;
      if (dupeGroupKeySet.has(key)) {
        return false;
      }
      dupeGroupKeySet.add(key);
      return true;
    });
    return { structs, groups };
  }
  var init_removeStructAndGroupDuplicates = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/removeStructAndGroupDuplicates.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
  var _GpuProgram, GpuProgram;
  var init_GpuProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
      init_extractStructAndGroups();
      init_generateGpuLayoutGroups();
      init_generateLayoutHash();
      init_removeStructAndGroupDuplicates();
      _GpuProgram = class {
        constructor({ fragment: fragment2, vertex: vertex2, layout, gpuLayout, name }) {
          this._layoutKey = 0;
          this.name = name;
          this.fragment = fragment2;
          this.vertex = vertex2;
          if (fragment2.source === vertex2.source) {
            const structsAndGroups = extractStructAndGroups(fragment2.source);
            this.structsAndGroups = structsAndGroups;
          } else {
            const vertexStructsAndGroups = extractStructAndGroups(vertex2.source);
            const fragmentStructsAndGroups = extractStructAndGroups(fragment2.source);
            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
          }
          this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
          this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
        }
        destroy() {
          this._gpuLayout = null;
          this.gpuLayout = null;
          this.layout = null;
          this.structsAndGroups = null;
          this.fragment = null;
          this.vertex = null;
        }
        static from(options) {
          const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
          if (!_GpuProgram.programCached[key]) {
            _GpuProgram.programCached[key] = new _GpuProgram(options);
          }
          return _GpuProgram.programCached[key];
        }
      };
      GpuProgram = _GpuProgram;
      GpuProgram.programCached = /* @__PURE__ */ Object.create(null);
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/addBits.mjs
  function addBits(srcParts, parts, name) {
    if (srcParts) {
      for (const i2 in srcParts) {
        const id = i2.toLocaleLowerCase();
        const part = parts[id];
        if (part) {
          let sanitisedPart = srcParts[i2];
          if (i2 === "header") {
            sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
          }
          if (name) {
            part.push(`//----${name}----//`);
          }
          part.push(sanitisedPart);
        } else {
          warn(`${i2} placement hook does not exist in shader`);
        }
      }
    }
  }
  var init_addBits = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
      init_warn();
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
  function compileHooks(programSrc) {
    const parts = {};
    const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
    partMatches.forEach((hook) => {
      parts[hook] = [];
    });
    return parts;
  }
  var findHooksRx;
  var init_compileHooks = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
      findHooksRx = /\{\{(.*?)\}\}/g;
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
  function extractInputs(fragmentSource, out2) {
    let match;
    const regex = /@in\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function compileInputs(fragments, template, sort = false) {
    const results = [];
    extractInputs(template, results);
    fragments.forEach((fragment2) => {
      if (fragment2.header) {
        extractInputs(fragment2.header, results);
      }
    });
    const mainInput = results;
    if (sort) {
      mainInput.sort();
    }
    const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
    let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
    cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
    return cleanedString;
  }
  var init_compileInputs = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
  function extractOutputs(fragmentSource, out2) {
    let match;
    const regex = /@out\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function extractVariableName(value) {
    const regex = /\b(\w+)\s*:/g;
    const match = regex.exec(value);
    return match ? match[1] : "";
  }
  function stripVariable(value) {
    const regex = /@.*?\s+/g;
    return value.replace(regex, "");
  }
  function compileOutputs(fragments, template) {
    const results = [];
    extractOutputs(template, results);
    fragments.forEach((fragment2) => {
      if (fragment2.header) {
        extractOutputs(fragment2.header, results);
      }
    });
    let index = 0;
    const mainStruct = results.sort().map((inValue) => {
      if (inValue.indexOf("builtin") > -1) {
        return inValue;
      }
      return `@location(${index++}) ${inValue}`;
    }).join(",\n");
    const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
    const mainEnd = `return VSOutput(
                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
    let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
    compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
    compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
    compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
    return compiledCode;
  }
  var init_compileOutputs = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/injectBits.mjs
  function injectBits(templateSrc, fragmentParts) {
    let out2 = templateSrc;
    for (const i2 in fragmentParts) {
      const parts = fragmentParts[i2];
      const toInject = parts.join("\n");
      if (toInject.length) {
        out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
      } else {
        out2 = out2.replace(`{{${i2}}}`, "");
      }
    }
    return out2;
  }
  var init_injectBits = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/compileHighShader.mjs
  function compileHighShader({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    const { vertex: vertex2, fragment: fragment2 } = compileInputsAndOutputs(template, bits);
    cacheMap[cacheId] = compileBits(vertex2, fragment2, bits);
    return cacheMap[cacheId];
  }
  function compileHighShaderGl({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
    return cacheMap[cacheId];
  }
  function compileInputsAndOutputs(template, bits) {
    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
    let compiledVertex = compileInputs(vertexFragments, template.vertex);
    compiledVertex = compileOutputs(vertexFragments, compiledVertex);
    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
    return {
      vertex: compiledVertex,
      fragment: compiledFragment
    };
  }
  function generateCacheId(template, bits) {
    return bits.map((highFragment) => {
      if (!bitCacheMap.has(highFragment)) {
        bitCacheMap.set(highFragment, CACHE_UID++);
      }
      return bitCacheMap.get(highFragment);
    }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
  }
  function compileBits(vertex2, fragment2, bits) {
    const vertexParts = compileHooks(vertex2);
    const fragmentParts = compileHooks(fragment2);
    bits.forEach((shaderBit) => {
      addBits(shaderBit.vertex, vertexParts, shaderBit.name);
      addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
    });
    return {
      vertex: injectBits(vertex2, vertexParts),
      fragment: injectBits(fragment2, fragmentParts)
    };
  }
  var cacheMap, bitCacheMap, CACHE_UID;
  var init_compileHighShader = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
      init_addBits();
      init_compileHooks();
      init_compileInputs();
      init_compileOutputs();
      init_injectBits();
      cacheMap = /* @__PURE__ */ Object.create(null);
      bitCacheMap = /* @__PURE__ */ new Map();
      CACHE_UID = 0;
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/defaultProgramTemplate.mjs
  var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
  var init_defaultProgramTemplate = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
      vertexGPUTemplate = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.worldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);
        vUV = aUV;

        {{main}}

        var modelViewProjectionMatrix = globalUniforms.projectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.worldAlpha;

        {{end}}

        {{return}}
    };
`;
      fragmentGPUTemplate = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`;
      vertexGlTemplate = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = worldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;

        {{start}}
        
        vColor = vec4(1.);
        vUV = aUV;

        {{main}}

        mat3 modelViewProjectionMatrix = projectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= worldAlpha;

        {{end}}
    }
`;
      fragmentGlTemplate = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`;
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
  var globalUniformsBit, globalUniformsBitGl;
  var init_globalUniformsBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
      globalUniformsBit = {
        name: "global-uniforms-bit",
        vertex: {
          header: `
        struct GlobalUniforms {
            projectionMatrix:mat3x3<f32>,
            worldTransformMatrix:mat3x3<f32>,
            worldAlpha: f32,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
      };
      globalUniformsBitGl = {
        name: "global-uniforms-bit",
        vertex: {
          header: `
          uniform globalUniforms {
            mat3 projectionMatrix;
            mat3 worldTransformMatrix;
            float worldAlpha;
            vec2 uResolution;
          };
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compileHighShaderToProgram.mjs
  function compileHighShaderGpuProgram({ bits, name }) {
    const source2 = compileHighShader({
      template: {
        fragment: fragmentGPUTemplate,
        vertex: vertexGPUTemplate
      },
      bits: [
        globalUniformsBit,
        ...bits
      ]
    });
    return new GpuProgram({
      name,
      vertex: {
        source: source2.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: source2.fragment,
        entryPoint: "main"
      }
    });
  }
  function compileHighShaderGlProgram({ bits, name }) {
    return new GlProgram({
      name,
      ...compileHighShaderGl({
        template: {
          vertex: vertexGlTemplate,
          fragment: fragmentGlTemplate
        },
        bits: [
          globalUniformsBitGl,
          ...bits
        ]
      })
    });
  }
  var init_compileHighShaderToProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_compileHighShader();
      init_defaultProgramTemplate();
      init_globalUniformsBit();
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/colorBit.mjs
  var colorBit, colorBitGl;
  var init_colorBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
      colorBit = {
        name: "color-bit",
        vertex: {
          header: `
            @in aColor: vec4<f32>;
        `,
          main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
      };
      colorBitGl = {
        name: "color-bit",
        vertex: {
          header: `
            in vec4 aColor;
        `,
          main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
  function generateBindingSrc(maxTextures) {
    const src = [];
    if (maxTextures === 1) {
      src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
      src.push("@group(1) @binding(1) var textureSampler1: sampler;");
    } else {
      let bindingIndex = 0;
      for (let i2 = 0; i2 < maxTextures; i2++) {
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
      }
    }
    return src.join("\n");
  }
  function generateSampleSrc(maxTextures) {
    const src = [];
    if (maxTextures === 1) {
      src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    } else {
      src.push("switch vTextureId {");
      for (let i2 = 0; i2 < maxTextures; i2++) {
        if (i2 === maxTextures - 1) {
          src.push(`  default:{`);
        } else {
          src.push(`  case ${i2}:{`);
        }
        src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
        src.push(`      break;}`);
      }
      src.push(`}`);
    }
    return src.join("\n");
  }
  function generateTextureBatchBit(maxTextures) {
    if (!textureBatchBitCache[maxTextures]) {
      textureBatchBitCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;
    
                ${generateBindingSrc(16)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${generateSampleSrc(16)}
            `
        }
      };
    }
    return textureBatchBitCache[maxTextures];
  }
  function generateSampleGlSrc(maxTextures) {
    const src = [];
    for (let i2 = 0; i2 < maxTextures; i2++) {
      if (i2 > 0) {
        src.push("else");
      }
      if (i2 < maxTextures - 1) {
        src.push(`if(vTextureId < ${i2}.5)`);
      }
      src.push("{");
      src.push(`	outColor = texture(uSamplers[${i2}], vUV);`);
      src.push("}");
    }
    return src.join("\n");
  }
  function generateTextureBatchBitGl(maxTextures) {
    if (!textureBatchBitCache[maxTextures]) {
      textureBatchBitCache[maxTextures] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
          header: `
                in float vTextureId;
    
                uniform sampler2D uSamplers[${maxTextures}];
              
            `,
          main: `
    
                ${generateSampleGlSrc(16)}
            `
        }
      };
    }
    return textureBatchBitCache[maxTextures];
  }
  var textureBatchBitCache;
  var init_generateTextureBatchBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
      textureBatchBitCache = {};
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
  var roundPixelsBit, roundPixelsBitGl;
  var init_roundPixelsBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
      roundPixelsBit = {
        name: "round-pixels-bit",
        vertex: {
          header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `
        }
      };
      roundPixelsBitGl = {
        name: "round-pixels-bit",
        vertex: {
          header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/types.mjs
  var RendererType;
  var init_types = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/types.mjs"() {
      RendererType = /* @__PURE__ */ ((RendererType2) => {
        RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
        RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
        return RendererType2;
      })(RendererType || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/defaultUniformValue.mjs
  function defaultUniformValue(type, size2) {
    switch (type) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * size2);
      case "vec3<f32>":
        return new Float32Array(3 * size2);
      case "vec4<f32>":
        return new Float32Array(4 * size2);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_defaultUniformValue = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/defaultUniformValue.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/UniformGroup.mjs
  var _UniformGroup, UniformGroup;
  var init_UniformGroup = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
      init_uid();
      init_defaultUniformValue();
      _UniformGroup = class {
        constructor(uniformStructures, options) {
          this.touched = 0;
          this.uid = uid("uniform");
          this.resourceType = "uniformGroup";
          this.resourceId = this.uid;
          this.isUniformGroup = true;
          this.dirtyId = 0;
          options = { ..._UniformGroup.DEFAULT, ...options };
          this.uniformStructures = uniformStructures;
          const uniforms = {};
          for (const i2 in uniformStructures) {
            const uniformData = uniformStructures[i2];
            uniformData.name = i2;
            uniformData.size = uniformData.size ?? 1;
            uniformData.value ?? (uniformData.value = defaultUniformValue(uniformData.type, uniformData.size));
            uniforms[i2] = uniformData.value;
          }
          this.uniforms = uniforms;
          this.dirtyId = 1;
          this.ubo = options.ubo;
          this.isStatic = options.isStatic;
          this.signature = Object.keys(uniforms).map(
            (i2) => `${i2}-${uniformStructures[i2].type}`
          ).join("-");
        }
        update() {
          this.dirtyId++;
        }
      };
      UniformGroup = _UniformGroup;
      UniformGroup.DEFAULT = {
        ubo: false,
        isStatic: false
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/Shader.mjs
  var Shader;
  var init_Shader = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/Shader.mjs"() {
      init_eventemitter3();
      init_BindGroup();
      init_types();
      init_UniformGroup();
      Shader = class extends eventemitter3_default {
        constructor({ gpuProgram, glProgram, groups, resources, groupMap, compatibleRenderers }) {
          super();
          this.uniformBindMap = /* @__PURE__ */ Object.create(null);
          this.gpuProgram = gpuProgram;
          this.glProgram = glProgram;
          if (compatibleRenderers === void 0) {
            compatibleRenderers = 0;
            if (gpuProgram)
              compatibleRenderers |= RendererType.WEBGPU;
            if (glProgram)
              compatibleRenderers |= RendererType.WEBGL;
          }
          this.compatibleRenderers = compatibleRenderers;
          const nameHash = {};
          if (resources && groups) {
            throw new Error("[Shader] Cannot have both resources and groups");
          } else if (!resources && !groups) {
            throw new Error("[Shader] Must provide either resources or groups descriptor");
          } else if (!gpuProgram && groups && !groupMap) {
            throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
          } else if (!gpuProgram && groups && groupMap) {
            for (const i2 in groupMap) {
              for (const j2 in groupMap[i2]) {
                const uniformName = groupMap[i2][j2];
                nameHash[uniformName] = {
                  group: i2,
                  binding: j2,
                  name: uniformName
                };
              }
            }
          } else if (gpuProgram && groups && !groupMap) {
            const groupData = gpuProgram.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          } else if (resources) {
            if (!gpuProgram) {
              groupMap = {};
              groups = {
                99: new BindGroup()
              };
              let bindTick = 0;
              for (const i2 in resources) {
                nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
                groupMap[99] = groupMap[99] || {};
                groupMap[99][bindTick] = i2;
                bindTick++;
              }
            } else {
              const groupData = gpuProgram.structsAndGroups.groups;
              groupMap = {};
              groupData.forEach((data) => {
                groupMap[data.group] = groupMap[data.group] || {};
                groupMap[data.group][data.binding] = data.name;
                nameHash[data.name] = data;
              });
            }
            groups = {};
            for (const i2 in resources) {
              const name = i2;
              let value = resources[i2];
              if (!value.source && !value.resourceType) {
                value = new UniformGroup(value);
              }
              const data = nameHash[name];
              if (data) {
                groups[data.group] = groups[data.group] || new BindGroup();
                groups[data.group].setResource(value, data.binding);
              }
            }
          }
          this.groups = groups;
          this.uniformBindMap = groupMap;
          this.resources = this._buildResourceAccessor(groups, nameHash);
        }
        addResource(name, groupIndex, bindIndex) {
          var _a, _b;
          (_a = this.uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
          (_b = this.uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
        }
        _buildResourceAccessor(groups, nameHash) {
          const uniformsOut = {};
          for (const i2 in nameHash) {
            const data = nameHash[i2];
            Object.defineProperty(uniformsOut, data.name, {
              get() {
                return groups[data.group].getResource(data.binding);
              },
              set(value) {
                groups[data.group].setResource(value, data.binding);
              }
            });
          }
          return uniformsOut;
        }
        destroy(destroyProgram = false) {
          this.emit("destroy", this);
          if (destroyProgram) {
            this.gpuProgram?.destroy();
            this.glProgram?.destroy();
          }
          this.gpuProgram = null;
          this.glProgram = null;
          this.groups = null;
          this.removeAllListeners();
          this.uniformBindMap = null;
          this.resources = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
  var GpuGraphicsAdaptor;
  var init_GpuGraphicsAdaptor = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_getTextureBatchBindGroup();
      init_const3();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      GpuGraphicsAdaptor = class {
        init() {
          const localUniforms = new UniformGroup({
            transformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const localUniformBit2 = {
            name: "local-uniform-bit",
            vertex: {
              header: `
        
                    struct LocalUniforms {
                        uTransformMatrix:mat3x3<f32>,
                        uColor:vec4<f32>,
                        uRound:f32,
                    }
        
                    @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
                `,
              main: `
                    vColor *= localUniforms.uColor;
                    modelMatrix *= localUniforms.uTransformMatrix;
                `,
              end: `
                    if(localUniforms.uRound == 1)
                    {
                        vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                    }
                `
            }
          };
          const gpuProgram = compileHighShaderGpuProgram({
            name: "graphics",
            bits: [
              colorBit,
              generateTextureBatchBit(MAX_TEXTURES),
              localUniformBit2,
              roundPixelsBit
            ]
          });
          this.shader = new Shader({
            gpuProgram,
            resources: {
              localUniforms
            }
          });
          this.shader.addResource("globalUniforms", 0, 0);
        }
        execute(graphicsPipe, renderable) {
          const context2 = renderable.view.context;
          const shader = context2.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            geometry,
            instructions
          } = contextSystem.getContextRenderData(context2);
          const encoder = renderer.encoder;
          encoder.setPipelineFromGeometryProgramAndState(
            geometry,
            shader.gpuProgram,
            graphicsPipe.state
          );
          encoder.setGeometry(geometry);
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
          const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
          encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
          const batches = instructions.instructions;
          for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
            const batch = batches[i2];
            shader.groups[1] = batch.bindGroup;
            if (!batch.gpuBindGroup) {
              const textureBatch = batch.textures;
              batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
              batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
                batch.bindGroup,
                shader.gpuProgram,
                1
              );
            }
            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GpuGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
  var localUniformBit, localUniformBitGl;
  var init_localUniformBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
      localUniformBit = {
        name: "local-uniform-bit",
        vertex: {
          header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
          main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
          end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
      };
      localUniformBitGl = {
        name: "local-uniform-bit",
        vertex: {
          header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
          main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
          end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/textureBit.mjs
  var textureBit, textureBitGl;
  var init_textureBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
      textureBit = {
        name: "texture-bit",
        fragment: {
          header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,
          main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        }
      };
      textureBitGl = {
        name: "texture-bit",
        fragment: {
          header: `
        uniform sampler2D uTexture;

         
        `,
          main: `
            outColor = texture(uTexture, vUV);
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
  var GpuMeshAdapter;
  var init_GpuMeshAdapter = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
      init_Extensions();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      GpuMeshAdapter = class {
        init() {
          const gpuProgram = compileHighShaderGpuProgram({
            name: "mesh",
            bits: [
              localUniformBit,
              textureBit,
              roundPixelsBit
            ]
          });
          this._shader = new Shader({
            gpuProgram,
            resources: {
              uTexture: Texture.EMPTY._source,
              uSampler: Texture.EMPTY._source.style
            }
          });
        }
        execute(meshPipe, renderable) {
          const renderer = meshPipe.renderer;
          const view = renderable.view;
          let shader = view._shader;
          if (!shader) {
            shader = this._shader;
            shader.groups[2] = renderer.texture.getTextureBindGroup(view.texture);
          }
          shader.groups[0] = renderer.globalUniforms.bindGroup;
          const localUniforms = meshPipe.localUniforms;
          shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
          renderer.encoder.draw({
            geometry: view._geometry,
            shader,
            state: view.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GpuMeshAdapter.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/state/State.mjs
  var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, State;
  var init_State = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/state/State.mjs"() {
      blendModeIds = {
        normal: 0,
        additive: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5
      };
      BLEND = 0;
      OFFSET = 1;
      CULLING = 2;
      DEPTH_TEST = 3;
      WINDING = 4;
      DEPTH_MASK = 5;
      State = class {
        constructor() {
          this.data = 0;
          this.blendMode = "normal";
          this.polygonOffset = 0;
          this.blend = true;
          this.depthMask = true;
        }
        get blend() {
          return !!(this.data & 1 << BLEND);
        }
        set blend(value) {
          if (!!(this.data & 1 << BLEND) !== value) {
            this.data ^= 1 << BLEND;
          }
        }
        get offsets() {
          return !!(this.data & 1 << OFFSET);
        }
        set offsets(value) {
          if (!!(this.data & 1 << OFFSET) !== value) {
            this.data ^= 1 << OFFSET;
          }
        }
        set cullMode(value) {
          if (value === "none") {
            this.culling = false;
            return;
          }
          this.culling = true;
          this.clockwiseFrontFace = value === "front";
        }
        get cullMode() {
          if (!this.culling) {
            return "none";
          }
          return this.clockwiseFrontFace ? "front" : "back";
        }
        get culling() {
          return !!(this.data & 1 << CULLING);
        }
        set culling(value) {
          if (!!(this.data & 1 << CULLING) !== value) {
            this.data ^= 1 << CULLING;
          }
        }
        get depthTest() {
          return !!(this.data & 1 << DEPTH_TEST);
        }
        set depthTest(value) {
          if (!!(this.data & 1 << DEPTH_TEST) !== value) {
            this.data ^= 1 << DEPTH_TEST;
          }
        }
        get depthMask() {
          return !!(this.data & 1 << DEPTH_MASK);
        }
        set depthMask(value) {
          if (!!(this.data & 1 << DEPTH_MASK) !== value) {
            this.data ^= 1 << DEPTH_MASK;
          }
        }
        get clockwiseFrontFace() {
          return !!(this.data & 1 << WINDING);
        }
        set clockwiseFrontFace(value) {
          if (!!(this.data & 1 << WINDING) !== value) {
            this.data ^= 1 << WINDING;
          }
        }
        get blendMode() {
          return this._blendMode;
        }
        set blendMode(value) {
          this.blend = value !== "none";
          this._blendMode = value;
          this._blendModeId = blendModeIds[value] || 0;
        }
        get polygonOffset() {
          return this._polygonOffset;
        }
        set polygonOffset(value) {
          this.offsets = !!value;
          this._polygonOffset = value;
        }
        toString() {
          return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        static for2d() {
          const state = new State();
          state.depthTest = false;
          state.blend = true;
          return state;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
  var tempState, GpuBatchAdaptor;
  var init_GpuBatchAdaptor = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
      init_Extensions();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_Shader();
      init_State();
      init_const3();
      init_getTextureBatchBindGroup();
      tempState = State.for2d();
      GpuBatchAdaptor = class {
        init() {
          const gpuProgram = compileHighShaderGpuProgram({
            name: "batch",
            bits: [
              colorBit,
              generateTextureBatchBit(MAX_TEXTURES),
              roundPixelsBit
            ]
          });
          this._shader = new Shader({
            gpuProgram,
            groups: {}
          });
        }
        start(batchPipe, geometry) {
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          const program = this._shader.gpuProgram;
          this._geometry = geometry;
          encoder.setGeometry(geometry);
          tempState.blendMode = "normal";
          renderer.pipeline.getPipeline(
            geometry,
            program,
            tempState
          );
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.setBindGroup(0, globalUniformsBindGroup, program);
        }
        execute(batchPipe, batch) {
          const program = this._shader.gpuProgram;
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          if (!batch.bindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
          }
          tempState.blendMode = batch.blendMode;
          const gpuBindGroup = renderer.bindGroup.getBindGroup(
            batch.bindGroup,
            program,
            1
          );
          const pipeline = renderer.pipeline.getPipeline(
            this._geometry,
            program,
            tempState
          );
          batch.bindGroup.touch(renderer.textureGC.count);
          encoder.setPipeline(pipeline);
          encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GpuBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/system/SystemRunner.mjs
  var SystemRunner;
  var init_SystemRunner = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
      SystemRunner = class {
        constructor(name) {
          this.items = [];
          this._name = name;
        }
        emit(a0, a1, a2, a3, a4, a5, a6, a7) {
          const { name, items } = this;
          for (let i2 = 0, len = items.length; i2 < len; i2++) {
            items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
          }
          return this;
        }
        add(item) {
          if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
          }
          return this;
        }
        remove(item) {
          const index = this.items.indexOf(item);
          if (index !== -1) {
            this.items.splice(index, 1);
          }
          return this;
        }
        contains(item) {
          return this.items.indexOf(item) !== -1;
        }
        removeAll() {
          this.items.length = 0;
          return this;
        }
        destroy() {
          this.removeAll();
          this.items = null;
          this._name = null;
        }
        get empty() {
          return this.items.length === 0;
        }
        get name() {
          return this._name;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
  var defaultRunners, AbstractRenderer;
  var init_AbstractRenderer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
      init_Color();
      init_Container();
      init_deprecation();
      init_SystemRunner();
      defaultRunners = [
        "init",
        "destroy",
        "contextChange",
        "reset",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
      ];
      AbstractRenderer = class {
        constructor(config) {
          this.runners = /* @__PURE__ */ Object.create(null);
          this.renderPipes = /* @__PURE__ */ Object.create(null);
          this._systemsHash = /* @__PURE__ */ Object.create(null);
          this.type = config.type;
          this.name = config.name;
          const combinedRunners = [...defaultRunners, ...config.runners ?? []];
          this._addRunners(...combinedRunners);
          this._addSystems(config.systems);
          this._addPipes(config.renderPipes, config.renderPipeAdaptors);
        }
        async init(options = {}) {
          for (const systemName in this._systemsHash) {
            const system = this._systemsHash[systemName];
            const defaultSystemOptions = system.constructor.defaultOptions;
            options = { ...defaultSystemOptions, ...options };
            this._roundPixels = options.roundPixels ? 1 : 0;
          }
          for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
            await this.runners.init.items[i2].init(options);
          }
        }
        render(args, deprecated) {
          let options = args;
          if (options instanceof Container) {
            options = { container: options };
            if (deprecated) {
              deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
              options.target = deprecated.renderTexture;
            }
          }
          options.target || (options.target = this.view.texture);
          if (options.target === this.view.texture) {
            this._lastObjectRendered = options.container;
          }
          if (options.clearColor) {
            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
          }
          this.runners.prerender.emit(options);
          this.runners.renderStart.emit(options);
          this.runners.render.emit(options);
          this.runners.renderEnd.emit(options);
          this.runners.postrender.emit(options);
        }
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        }
        get resolution() {
          return this.view.resolution;
        }
        set resolution(value) {
          this.view.resolution = value;
        }
        get width() {
          return this.view.texture.frameWidth;
        }
        get height() {
          return this.view.texture.frameHeight;
        }
        get canvas() {
          return this.view.canvas;
        }
        get lastObjectRendered() {
          return this._lastObjectRendered;
        }
        get renderingToScreen() {
          const renderer = this;
          return renderer.renderTarget.renderingToScreen;
        }
        get screen() {
          return this.view.screen;
        }
        _addRunners(...runnerIds) {
          runnerIds.forEach((runnerId) => {
            this.runners[runnerId] = new SystemRunner(runnerId);
          });
        }
        _addSystems(systems3) {
          let i2;
          for (i2 in systems3) {
            const val = systems3[i2];
            this._addSystem(val.value, val.name);
          }
        }
        _addSystem(ClassRef, name) {
          const system = new ClassRef(this);
          if (this[name]) {
            throw new Error(`Whoops! The name "${name}" is already in use`);
          }
          this[name] = system;
          this._systemsHash[name] = system;
          for (const i2 in this.runners) {
            this.runners[i2].add(system);
          }
          return this;
        }
        _addPipes(pipes, pipeAdaptors) {
          const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
            acc[adaptor.name] = adaptor.value;
            return acc;
          }, {});
          pipes.forEach((pipe) => {
            const PipeClass = pipe.value;
            const name = pipe.name;
            const Adaptor = adaptors[name];
            this.renderPipes[name] = new PipeClass(
              this,
              Adaptor ? new Adaptor() : null
            );
          });
        }
        destroy(options = false) {
          const writeable = this;
          this.runners.destroy.items.reverse();
          this.runners.destroy.emit(options);
          Object.values(this.runners).forEach((runner) => {
            runner.destroy();
          });
          writeable.runners = null;
          this._systemsHash = null;
          writeable.renderPipes = null;
        }
        generateTexture(options) {
          return this.textureGenerator.generateTexture(options);
        }
        get roundPixels() {
          return !!this._roundPixels;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/FilterPipe.mjs
  var FilterPipe;
  var init_FilterPipe = __esm({
    "node_modules/pixi-v8/lib/filters/FilterPipe.mjs"() {
      init_Extensions();
      FilterPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        push(filterEffect, container, instructionSet) {
          const renderPipes3 = this._renderer.renderPipes;
          renderPipes3.batch.break(instructionSet);
          instructionSet.add({
            type: "filter",
            canBundle: false,
            action: "pushFilter",
            container,
            filterEffect
          });
        }
        pop(_filterEffect, _container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        execute(instruction) {
          if (instruction.action === "pushFilter") {
            this._renderer.filter.push(instruction);
          } else if (instruction.action === "popFilter") {
            this._renderer.filter.pop();
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      FilterPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "filter"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/Buffer.mjs
  var Buffer2;
  var init_Buffer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
      init_eventemitter3();
      init_uid();
      Buffer2 = class extends eventemitter3_default {
        constructor({ data, size: size2, usage, label }) {
          super();
          this.resourceType = "buffer";
          this.resourceId = uid("bufferResource");
          this.touched = 0;
          this.uid = uid("buffer");
          this._updateID = 1;
          if (data instanceof Array) {
            data = new Float32Array(data);
          }
          this._data = data;
          size2 = size2 ?? data?.byteLength;
          const mappedAtCreation = !!data;
          this.descriptor = {
            size: size2,
            usage,
            mappedAtCreation,
            label
          };
        }
        get data() {
          return this._data;
        }
        set data(value) {
          if (this._data !== value) {
            const oldData = this._data;
            this._data = value;
            if (oldData.length !== value.length) {
              this.descriptor.size = value.byteLength;
              this.resourceId = uid("bufferResource");
              this.emit("change", this);
            } else {
              this.emit("update", this);
            }
          }
        }
        update(sizeInBytes) {
          this._updateSize = sizeInBytes || this.descriptor.size;
          this._updateID++;
          this.emit("update", this);
        }
        destroy() {
          this.emit("destroy", this);
          this._data = null;
          this.descriptor = null;
          this.removeAllListeners();
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/const.mjs
  var BufferUsage;
  var init_const5 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/const.mjs"() {
      BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
        BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
        BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
        BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
        BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
        BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
        BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
        BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
        BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
        BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
        BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
        BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
        return BufferUsage2;
      })(BufferUsage || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
  function ensureIsBuffer(buffer, index) {
    if (!(buffer instanceof Buffer2)) {
      let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
      if (buffer instanceof Array) {
        if (index) {
          buffer = new Uint32Array(buffer);
          usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
        } else {
          buffer = new Float32Array(buffer);
          usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
        }
      }
      buffer = new Buffer2({
        data: buffer,
        label: "index-mesh-buffer",
        usage
      });
    }
    return buffer;
  }
  var init_ensureIsBuffer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
      init_Buffer();
      init_const5();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/Geometry.mjs
  var Geometry;
  var init_Geometry = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
      init_eventemitter3();
      init_uid();
      init_ensureIsBuffer();
      Geometry = class extends eventemitter3_default {
        constructor({ attributes, indexBuffer, topology }) {
          super();
          this.uid = uid("geometry");
          this._layoutKey = 0;
          this.attributes = attributes;
          this.buffers = [];
          for (const i2 in attributes) {
            const attribute = attributes[i2];
            attribute.buffer = ensureIsBuffer(attribute.buffer, false);
            const bufferIndex = this.buffers.indexOf(attribute.buffer);
            if (bufferIndex === -1) {
              this.buffers.push(attribute.buffer);
              attribute.buffer.on("update", this.onBufferUpdate, this);
            }
          }
          if (indexBuffer) {
            this.indexBuffer = ensureIsBuffer(indexBuffer, true);
            this.buffers.push(this.indexBuffer);
          }
          this.topology = topology || "triangle-list";
        }
        onBufferUpdate() {
          this.emit("update", this);
        }
        getAttribute(id) {
          return this.attributes[id];
        }
        getIndex() {
          return this.indexBuffer;
        }
        getBuffer(id) {
          return this.getAttribute(id).buffer;
        }
        getSize() {
          for (const i2 in this.attributes) {
            const attribute = this.attributes[i2];
            const buffer = this.getBuffer(i2);
            return buffer.data.length / (attribute.stride / 4 || attribute.size);
          }
          return 0;
        }
        destroy(destroyBuffers = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          if (destroyBuffers) {
            this.buffers.forEach((buffer) => buffer.destroy());
          }
          this.attributes = null;
          this.buffers = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/misc/pow2.mjs
  function nextPow2(v2) {
    v2 += v2 === 0 ? 1 : 0;
    --v2;
    v2 |= v2 >>> 1;
    v2 |= v2 >>> 2;
    v2 |= v2 >>> 4;
    v2 |= v2 >>> 8;
    v2 |= v2 >>> 16;
    return v2 + 1;
  }
  var init_pow2 = __esm({
    "node_modules/pixi-v8/lib/maths/misc/pow2.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TexturePool.mjs
  var count, TexturePoolClass, TexturePool;
  var init_TexturePool = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
      init_pow2();
      init_TextureSource();
      init_Texture();
      count = 0;
      TexturePoolClass = class {
        constructor(textureOptions) {
          this._poolKeyHash = /* @__PURE__ */ Object.create(null);
          this._texturePool = {};
          this.textureOptions = textureOptions || {};
          this.enableFullScreen = false;
        }
        createTexture(pixelWidth, pixelHeight, antialias) {
          const textureSource = new TextureSource({
            ...this.textureOptions,
            width: pixelWidth,
            height: pixelHeight,
            resolution: 1,
            antialias
          });
          return new Texture({
            source: textureSource,
            label: `texturePool_${count++}`
          });
        }
        getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
          let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
          let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
          po2Width = nextPow2(po2Width);
          po2Height = nextPow2(po2Height);
          const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
          if (!this._texturePool[key]) {
            this._texturePool[key] = [];
          }
          let texture = this._texturePool[key].pop();
          if (!texture) {
            texture = this.createTexture(po2Width, po2Height, antialias);
          }
          texture.source._resolution = resolution;
          texture.source.width = po2Width / resolution;
          texture.source.height = po2Height / resolution;
          texture.source.pixelWidth = po2Width;
          texture.source.pixelHeight = po2Height;
          texture.frameX = 0;
          texture.frameY = 0;
          texture.frameWidth = frameWidth;
          texture.frameHeight = frameHeight;
          texture.layout.update();
          this._poolKeyHash[texture.id] = key;
          return texture;
        }
        getSameSizeTexture(texture, antialias = false) {
          const source2 = texture.source;
          return this.getOptimalTexture(texture.width, texture.height, source2._resolution, antialias);
        }
        returnTexture(renderTexture) {
          const key = this._poolKeyHash[renderTexture.id];
          this._texturePool[key].push(renderTexture);
        }
        clear(destroyTextures) {
          destroyTextures = destroyTextures !== false;
          if (destroyTextures) {
            for (const i2 in this._texturePool) {
              const textures = this._texturePool[i2];
              if (textures) {
                for (let j2 = 0; j2 < textures.length; j2++) {
                  textures[j2].destroy(true);
                }
              }
            }
          }
          this._texturePool = {};
        }
      };
      TexturePool = new TexturePoolClass();
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/getRenderableBounds.mjs
  function getGlobalRenderableBounds(renderables, bounds) {
    bounds.clear();
    const tempMatrix4 = bounds.matrix;
    for (let i2 = 0; i2 < renderables.length; i2++) {
      const renderable = renderables[i2];
      if (renderable.layerVisibleRenderable < 3) {
        continue;
      }
      bounds.matrix = renderable.worldTransform;
      renderable.view.addBounds(bounds);
    }
    bounds.matrix = tempMatrix4;
    return bounds;
  }
  var init_getRenderableBounds = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/getRenderableBounds.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/filters/FilterSystem.mjs
  var quadGeometry, FilterSystem;
  var init_FilterSystem = __esm({
    "node_modules/pixi-v8/lib/filters/FilterSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_BindGroup();
      init_Geometry();
      init_UniformGroup();
      init_Texture();
      init_TexturePool();
      init_Bounds();
      init_getGlobalBounds();
      init_getRenderableBounds();
      init_warn();
      quadGeometry = new Geometry({
        attributes: {
          aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            shaderLocation: 0,
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
      FilterSystem = class {
        constructor(renderer) {
          this._filterStackIndex = 0;
          this._filterStack = [];
          this._filterGlobalUniforms = new UniformGroup({
            inputSize: { value: new Float32Array(4), type: "vec4<f32>" },
            inputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
            inputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
            outputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            globalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            outputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
          });
          this._globalFilterBindGroup = new BindGroup({});
          this.renderer = renderer;
        }
        push(instruction) {
          const renderer = this.renderer;
          const filters = instruction.filterEffect.filters;
          if (!this._filterStack[this._filterStackIndex]) {
            this._filterStack[this._filterStackIndex] = this._getFilterData();
          }
          const filterData = this._filterStack[this._filterStackIndex];
          this._filterStackIndex++;
          const bounds = filterData.bounds;
          if (instruction.renderables) {
            getGlobalRenderableBounds(instruction.renderables, bounds);
          } else {
            getGlobalBounds(instruction.container, true, bounds);
          }
          if (filters.length === 0) {
            filterData.skip = true;
            return;
          }
          let resolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
          let padding = 0;
          let antialias = renderer.renderTarget.rootRenderTarget.colorTexture.source.antialias;
          let blendRequired = false;
          let enabled = false;
          for (let i2 = 0; i2 < filters.length; i2++) {
            const filter = filters[i2];
            resolution = Math.min(resolution, filter.resolution);
            padding += filter.padding;
            if (filter.antialias !== "inherit") {
              if (filter.antialias === "on") {
                antialias = true;
              } else {
                antialias = false;
              }
            }
            const isCompatible = !!(filter.compatibleRenderers & renderer.type);
            if (!isCompatible) {
              enabled = false;
              break;
            }
            if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
              warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
              enabled = false;
              break;
            }
            enabled = filter.enabled || enabled;
            blendRequired = blendRequired || filter.blendRequired;
          }
          if (!enabled) {
            filterData.skip = true;
            return;
          }
          bounds.scale(resolution).fit(renderer.renderTarget.rootRenderTarget.viewport).scale(1 / resolution).pad(padding).ceil();
          if (!bounds.isPositive) {
            filterData.skip = true;
            return;
          }
          filterData.skip = false;
          filterData.bounds = bounds;
          filterData.blendRequired = blendRequired;
          filterData.container = instruction.container;
          filterData.filterEffect = instruction.filterEffect;
          filterData.previousRenderSurface = renderer.renderTarget.renderTarget;
          filterData.inputTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            resolution,
            antialias
          );
          renderer.renderTarget.bind(filterData.inputTexture, true);
          renderer.globalUniforms.push({
            offset: bounds
          });
        }
        pop() {
          const renderer = this.renderer;
          this._filterStackIndex--;
          const filterData = this._filterStack[this._filterStackIndex];
          if (filterData.skip) {
            return;
          }
          this._activeFilterData = filterData;
          const inputTexture = filterData.inputTexture;
          const bounds = filterData.bounds;
          let backTexture = Texture.EMPTY;
          renderer.renderTarget.finishRenderPass?.();
          if (filterData.blendRequired) {
            renderer.encoder.finishRenderPass();
            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
            backTexture = this.getBackTexture(filterData.previousRenderSurface, bounds, previousBounds);
          }
          filterData.backTexture = backTexture;
          const filters = filterData.filterEffect.filters;
          this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
          this._globalFilterBindGroup.setResource(backTexture.source, 3);
          renderer.globalUniforms.pop();
          if (filters.length === 1) {
            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(inputTexture);
          } else {
            let flip = filterData.inputTexture;
            let flop = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              flip.source._resolution,
              false
            );
            let i2 = 0;
            for (i2 = 0; i2 < filters.length - 1; ++i2) {
              const filter = filters[i2];
              filter.apply(this, flip, flop, true);
              const t2 = flip;
              flip = flop;
              flop = t2;
            }
            filters[i2].apply(this, flip, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(flip);
            TexturePool.returnTexture(flop);
          }
          if (filterData.blendRequired) {
            TexturePool.returnTexture(backTexture);
          }
        }
        getBackTexture(lastRenderSurface, bounds, previousBounds) {
          const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
          const backTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            backgroundResolution,
            false
          );
          let x2 = bounds.minX;
          let y2 = bounds.minY;
          if (previousBounds) {
            x2 -= previousBounds.minX;
            y2 -= previousBounds.minY;
          }
          x2 = Math.floor(x2 * backgroundResolution);
          y2 = Math.floor(y2 * backgroundResolution);
          const width = Math.ceil(bounds.width * backgroundResolution);
          const height = Math.ceil(bounds.height * backgroundResolution);
          this.renderer.renderTarget.copyToTexture(
            lastRenderSurface,
            backTexture,
            { x: x2, y: y2 },
            { width, height }
          );
          return backTexture;
        }
        applyFilter(filter, input, output, clear) {
          const renderer = this.renderer;
          const filterData = this._filterStack[this._filterStackIndex];
          const bounds = filterData.bounds;
          const offset = Point.shared;
          const previousRenderSurface = filterData.previousRenderSurface;
          const isFinalTarget = previousRenderSurface === this.renderer.renderTarget.getRenderTarget(output);
          let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
          if (this._filterStackIndex > 0) {
            resolution = this._filterStack[this._filterStackIndex - 1].inputTexture.source._resolution;
          }
          const filterUniforms = this._filterGlobalUniforms;
          const uniforms = filterUniforms.uniforms;
          const outputFrame = uniforms.outputFrame;
          const inputSize = uniforms.inputSize;
          const inputPixel = uniforms.inputPixel;
          const inputClamp = uniforms.inputClamp;
          const globalFrame = uniforms.globalFrame;
          const outputTexture = uniforms.outputTexture;
          if (isFinalTarget) {
            if (this._filterStackIndex > 0) {
              offset.x = this._filterStack[this._filterStackIndex - 1].bounds.minX;
              offset.y = this._filterStack[this._filterStackIndex - 1].bounds.minY;
            }
            outputFrame[0] = bounds.minX - offset.x;
            outputFrame[1] = bounds.minY - offset.y;
          } else {
            outputFrame[0] = 0;
            outputFrame[1] = 0;
          }
          outputFrame[2] = input.frameWidth;
          outputFrame[3] = input.frameHeight;
          inputSize[0] = input.source.width;
          inputSize[1] = input.source.height;
          inputSize[2] = 1 / inputSize[0];
          inputSize[3] = 1 / inputSize[1];
          inputPixel[0] = input.source.pixelWidth;
          inputPixel[1] = input.source.pixelHeight;
          inputPixel[2] = 1 / inputPixel[0];
          inputPixel[3] = 1 / inputPixel[1];
          inputClamp[0] = 0.5 * inputPixel[2];
          inputClamp[1] = 0.5 * inputPixel[3];
          inputClamp[2] = input.frameWidth * inputSize[2] - 0.5 * inputPixel[2];
          inputClamp[3] = input.frameHeight * inputSize[3] - 0.5 * inputPixel[3];
          const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
          globalFrame[0] = offset.x * resolution;
          globalFrame[1] = offset.y * resolution;
          globalFrame[2] = rootTexture.source.width * resolution;
          globalFrame[3] = rootTexture.source.height * resolution;
          const renderSurface = this.renderer.renderTarget.getRenderTarget(output);
          outputTexture[0] = renderSurface.colorTexture.frameWidth;
          outputTexture[1] = renderSurface.colorTexture.frameHeight;
          outputTexture[2] = renderSurface.isRoot ? -1 : 1;
          filterUniforms.update();
          if (renderer.renderPipes.uniformBatch) {
            const batchUniforms = renderer.renderPipes.uniformBatch.getUniformBufferResource(this._filterGlobalUniforms);
            this._globalFilterBindGroup.setResource(batchUniforms, 0);
          } else {
            this._globalFilterBindGroup.setResource(filterUniforms, 0);
          }
          this._globalFilterBindGroup.setResource(input.source, 1);
          this._globalFilterBindGroup.setResource(input.source.style, 2);
          renderer.renderTarget.bind(output, !!clear);
          filter.groups[0] = this._globalFilterBindGroup;
          renderer.encoder.draw({
            geometry: quadGeometry,
            shader: filter,
            state: filter._state,
            topology: "triangle-list"
          });
        }
        _getFilterData() {
          return {
            skip: false,
            inputTexture: null,
            bounds: new Bounds(),
            container: null,
            filterEffect: null,
            blendRequired: false,
            previousRenderSurface: null
          };
        }
        calculateSpriteMatrix(outputMatrix, sprite) {
          const data = this._activeFilterData;
          const mappedMatrix = outputMatrix.set(
            data.inputTexture._source.width,
            0,
            0,
            data.inputTexture._source.height,
            data.bounds.minX,
            data.bounds.minY
          );
          const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
          worldTransform.invert();
          mappedMatrix.prepend(worldTransform);
          mappedMatrix.scale(1 / sprite.texture.frameWidth, 1 / sprite.texture.frameHeight);
          mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
          return mappedMatrix;
        }
      };
      FilterSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "filter"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/executeInstructions.mjs
  function executeInstructions(layerGroup, renderer) {
    const instructionSet = layerGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for (let i2 = 0; i2 < instructionSet.instructionSize; i2++) {
      const instruction = instructions[i2];
      renderer[instruction.type].execute(instruction);
    }
  }
  var init_executeInstructions = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/executeInstructions.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/container/LayerPipe.mjs
  var LayerPipe;
  var init_LayerPipe = __esm({
    "node_modules/pixi-v8/lib/scene/container/LayerPipe.mjs"() {
      init_Extensions();
      init_executeInstructions();
      LayerPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addLayerGroup(layerGroup, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(layerGroup);
        }
        execute(layerGroup) {
          if (!layerGroup.isRenderable)
            return;
          this._renderer.globalUniforms.push({
            projectionData: this._renderer.renderTarget.renderTarget,
            worldTransformMatrix: layerGroup.worldTransform,
            worldColor: layerGroup.worldColor
          });
          executeInstructions(layerGroup, this._renderer.renderPipes);
          this._renderer.globalUniforms.pop();
        }
        destroy() {
          this._renderer = null;
        }
      };
      LayerPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "layer"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/LayerRenderable.mjs
  var LayerRenderable;
  var init_LayerRenderable = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/LayerRenderable.mjs"() {
      init_eventemitter3();
      init_Matrix();
      init_uid();
      LayerRenderable = class extends eventemitter3_default {
        constructor({ original, view }) {
          super();
          this.uid = uid("renderable");
          this.view = view;
          this._original = original;
          this.layerTransform = new Matrix();
          this.layerColor = 4294967295;
          this.layerVisibleRenderable = 3;
          this.view.owner = this;
        }
        get layerBlendMode() {
          return this._original.layerBlendMode;
        }
        onViewUpdate() {
          this.didViewUpdate = true;
          this._original.layerGroup.onChildViewUpdate(this);
        }
        get isRenderable() {
          return this._original.isRenderable;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/buildInstructions.mjs
  function buildInstructions(layerGroup, renderPipes3) {
    const root = layerGroup.root;
    const instructionSet = layerGroup.instructionSet;
    instructionSet.reset();
    renderPipes3.batch.buildStart(instructionSet);
    renderPipes3.blendMode.buildStart();
    renderPipes3.colorMask.buildStart();
    if (root.sortableChildren) {
      root.sortChildren();
    }
    collectAllRenderablesAdvanced(root, instructionSet, renderPipes3, true);
    renderPipes3.batch.buildEnd(instructionSet);
    renderPipes3.blendMode.buildEnd(instructionSet);
  }
  function collectAllRenderables(container, instructionSet, rendererPipes) {
    if (container.layerVisibleRenderable < 3 || !container.includeInBuild)
      return;
    if (container.sortableChildren) {
      container.sortChildren();
    }
    if (container.isSimple) {
      collectAllRenderablesSimple(container, instructionSet, rendererPipes);
    } else {
      collectAllRenderablesAdvanced(container, instructionSet, rendererPipes, false);
    }
  }
  function collectAllRenderablesSimple(container, instructionSet, renderPipes3) {
    const view = container.view;
    if (view) {
      renderPipes3.blendMode.setBlendMode(container, container.layerBlendMode, instructionSet);
      container.didViewUpdate = false;
      const rp = renderPipes3;
      rp[view.renderPipeId].addRenderable(container, instructionSet);
    }
    if (!container.isLayerRoot) {
      const children = container.children;
      const length = children.length;
      for (let i2 = 0; i2 < length; i2++) {
        collectAllRenderables(children[i2], instructionSet, renderPipes3);
      }
    }
  }
  function collectAllRenderablesAdvanced(container, instructionSet, renderPipes3, isRoot) {
    if (isRoot) {
      const layerGroup = container.layerGroup;
      if (layerGroup.root.view) {
        const proxyRenderable = layerGroup.proxyRenderable ?? initProxyRenderable(layerGroup);
        if (proxyRenderable) {
          renderPipes3.blendMode.setBlendMode(proxyRenderable, proxyRenderable.layerBlendMode, instructionSet);
          renderPipes3[proxyRenderable.view.renderPipeId].addRenderable(proxyRenderable, instructionSet);
        }
      }
    } else {
      for (let i2 = 0; i2 < container.effects.length; i2++) {
        const effect = container.effects[i2];
        const pipe = renderPipes3[effect.pipe];
        pipe.push(effect, container, instructionSet);
      }
    }
    if (!isRoot && container.isLayerRoot) {
      renderPipes3.layer.addLayerGroup(container.layerGroup, instructionSet);
    } else {
      const view = container.view;
      if (view) {
        renderPipes3.blendMode.setBlendMode(container, container.layerBlendMode, instructionSet);
        container.didViewUpdate = false;
        const pipe = renderPipes3[view.renderPipeId];
        pipe.addRenderable(container, instructionSet);
      }
      const children = container.children;
      if (children.length) {
        for (let i2 = 0; i2 < children.length; i2++) {
          collectAllRenderables(children[i2], instructionSet, renderPipes3);
        }
      }
    }
    if (!isRoot) {
      for (let i2 = container.effects.length - 1; i2 >= 0; i2--) {
        const effect = container.effects[i2];
        const pipe = renderPipes3[effect.pipe];
        pipe.pop(effect, container, instructionSet);
      }
    }
  }
  function initProxyRenderable(layerGroup) {
    const root = layerGroup.root;
    layerGroup.proxyRenderable = new LayerRenderable({
      original: root,
      view: root.view
    });
  }
  var init_buildInstructions = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/buildInstructions.mjs"() {
      init_LayerRenderable();
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/collectLayerGroups.mjs
  function collectLayerGroups(renderGroup, out2 = []) {
    out2.push(renderGroup);
    for (let i2 = 0; i2 < renderGroup.layerGroupChildren.length; i2++) {
      collectLayerGroups(renderGroup.layerGroupChildren[i2], out2);
    }
    return out2;
  }
  var init_collectLayerGroups = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/collectLayerGroups.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/mixHexColors.mjs
  function mixHexColors(color1, color2, ratio) {
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 + (r2 - r1) * ratio;
    const g3 = g1 + (g2 - g1) * ratio;
    const b3 = b1 + (b2 - b1) * ratio;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_mixHexColors = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/mixHexColors.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/mixColors.mjs
  function mixColors(localColor, parentColor) {
    const localAlpha = (localColor >> 24 & 255) / 255;
    const parentAlpha = (parentColor >> 24 & 255) / 255;
    const globalAlpha = localAlpha * parentAlpha * 255;
    const localBGRColor = localColor & 16777215;
    const parentBGRColor = parentColor & 16777215;
    let sharedBGRColor = 16777215;
    if (localBGRColor + (parentBGRColor << 32) !== WHITE_WHITE) {
      if (localBGRColor === 16777215) {
        sharedBGRColor = parentBGRColor;
      } else if (parentBGRColor === 16777215) {
        sharedBGRColor = localBGRColor;
      } else {
        sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);
      }
    }
    return sharedBGRColor + (globalAlpha << 24);
  }
  var WHITE_WHITE;
  var init_mixColors = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/mixColors.mjs"() {
      init_mixHexColors();
      WHITE_WHITE = 16777215 + (16777215 << 32);
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/updateLayerGroupTransforms.mjs
  function updateLayerGroupTransforms(layerGroup, updateChildRenderGroups = false) {
    updateLayerTransform(layerGroup);
    const childrenToUpdate = layerGroup.childrenToUpdate;
    const updateTick = layerGroup.updateTick;
    layerGroup.updateTick++;
    for (const j2 in childrenToUpdate) {
      const childrenAtDepth = childrenToUpdate[j2];
      const list = childrenAtDepth.list;
      const index = childrenAtDepth.index;
      for (let i2 = 0; i2 < index; i2++) {
        updateTransformAndChildren(list[i2], updateTick, 0);
      }
      childrenAtDepth.index = 0;
    }
    if (updateChildRenderGroups) {
      for (let i2 = 0; i2 < layerGroup.layerGroupChildren.length; i2++) {
        updateLayerGroupTransforms(layerGroup.layerGroupChildren[i2], updateChildRenderGroups);
      }
    }
  }
  function updateLayerTransform(layerGroup) {
    if (layerGroup.layerGroupParent) {
      layerGroup.worldTransform.appendFrom(
        layerGroup.root.layerTransform,
        layerGroup.layerGroupParent.worldTransform
      );
      layerGroup.worldColor = mixColors(
        layerGroup.root.layerColor,
        layerGroup.layerGroupParent.worldColor
      );
    } else {
      layerGroup.worldTransform.copyFrom(layerGroup.root.layerTransform);
      layerGroup.worldColor = layerGroup.root.localColor;
    }
  }
  function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick)
      return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    updateLocalTransform(localTransform, container);
    const parent = container.parent;
    if (parent && !parent.isLayerRoot) {
      updateFlags = updateFlags | container._updateFlags;
      container.layerTransform.appendFrom(
        localTransform,
        parent.layerTransform
      );
      if (updateFlags) {
        updateColorBlendVisibility(container, parent, updateFlags);
      }
    } else {
      updateFlags = container._updateFlags;
      container.layerTransform.copyFrom(localTransform);
      if (updateFlags) {
        updateColorBlendVisibility(container, tempContainer, updateFlags);
      }
    }
    if (!container.isLayerRoot) {
      const children = container.children;
      const length = children.length;
      for (let i2 = 0; i2 < length; i2++) {
        updateTransformAndChildren(children[i2], updateTick, updateFlags);
      }
      const layerGroup = container.layerGroup;
      if (container.view && !layerGroup.structureDidChange) {
        layerGroup.updateRenderable(container);
      }
    }
  }
  function updateColorBlendVisibility(container, parent, updateFlags) {
    if (updateFlags & UPDATE_COLOR) {
      container.layerColor = mixColors(container.localColor, parent.layerColor);
    }
    if (updateFlags & UPDATE_BLEND) {
      container.layerBlendMode = container.localBlendMode === "inherit" ? parent.layerBlendMode : container.localBlendMode;
    }
    if (updateFlags & UPDATE_VISIBLE) {
      container.layerVisibleRenderable = container.localVisibleRenderable & parent.layerVisibleRenderable;
    }
    container._updateFlags = 0;
  }
  var tempContainer;
  var init_updateLayerGroupTransforms = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/updateLayerGroupTransforms.mjs"() {
      init_Container();
      init_mixColors();
      init_updateLocalTransform();
      tempContainer = new Container();
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/validateRenderables.mjs
  function validateRenderables(layerGroup, renderPipes3) {
    const { list, index } = layerGroup.childrenRenderablesToUpdate;
    let rebuildRequired = false;
    for (let i2 = 0; i2 < index; i2++) {
      const container = list[i2];
      const renderable = container.view;
      const pipe = renderPipes3[renderable.renderPipeId];
      rebuildRequired = pipe.validateRenderable(container);
      if (rebuildRequired) {
        break;
      }
    }
    layerGroup.structureDidChange = rebuildRequired;
    if (rebuildRequired) {
      layerGroup.childrenRenderablesToUpdate.index = 0;
    }
    return rebuildRequired;
  }
  var init_validateRenderables = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/validateRenderables.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/container/LayerSystem.mjs
  function updateRenderables(layerGroup) {
    const { list, index } = layerGroup.childrenRenderablesToUpdate;
    for (let i2 = 0; i2 < index; i2++) {
      const container = list[i2];
      if (container.didViewUpdate) {
        layerGroup.updateRenderable(container);
      }
    }
    layerGroup.childrenRenderablesToUpdate.index = 0;
  }
  var LayerSystem;
  var init_LayerSystem = __esm({
    "node_modules/pixi-v8/lib/scene/container/LayerSystem.mjs"() {
      init_Extensions();
      init_buildInstructions();
      init_collectLayerGroups();
      init_executeInstructions();
      init_updateLayerGroupTransforms();
      init_validateRenderables();
      LayerSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        render({ container, transform }) {
          container.layer = true;
          const renderer = this._renderer;
          const layerGroups = collectLayerGroups(container.layerGroup, []);
          const renderPipes3 = renderer.renderPipes;
          for (let i2 = 0; i2 < layerGroups.length; i2++) {
            const layerGroup = layerGroups[i2];
            layerGroup.runOnRender();
            layerGroup.instructionSet.renderPipes = renderPipes3;
            if (!layerGroup.structureDidChange) {
              validateRenderables(layerGroup, renderPipes3);
            }
            updateLayerGroupTransforms(layerGroup);
            if (layerGroup.structureDidChange) {
              layerGroup.structureDidChange = false;
              buildInstructions(layerGroup, renderPipes3);
            } else {
              updateRenderables(layerGroup);
            }
            renderer.renderPipes.batch.upload(layerGroup.instructionSet);
          }
          if (transform) {
            container.layerGroup.worldTransform.copyFrom(transform);
          }
          renderer.globalUniforms.start(
            {
              projectionData: renderer.renderTarget.rootRenderTarget,
              worldTransformMatrix: container.layerGroup.worldTransform
            }
          );
          executeInstructions(container.layerGroup, renderPipes3);
          if (renderPipes3.uniformBatch) {
            renderPipes3.uniformBatch.renderEnd();
            renderPipes3.uniformBuffer.renderEnd();
          }
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
        }
      };
      LayerSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "layer"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gpu/BatchGeometry.mjs
  var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
  var init_BatchGeometry = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gpu/BatchGeometry.mjs"() {
      init_Buffer();
      init_const5();
      init_Geometry();
      placeHolderBufferData = new Float32Array(1);
      placeHolderIndexData = new Uint32Array(1);
      BatchGeometry = class extends Geometry {
        constructor() {
          const vertexSize = 6;
          const attributeBuffer = new Buffer2({
            data: placeHolderBufferData,
            label: "attribute-batch-buffer",
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const indexBuffer = new Buffer2({
            data: placeHolderIndexData,
            label: "index-batch-buffer",
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          });
          const stride = vertexSize * 4;
          super({
            attributes: {
              aPosition: {
                buffer: attributeBuffer,
                shaderLocation: 0,
                format: "float32x2",
                stride,
                offset: 0
              },
              aUV: {
                buffer: attributeBuffer,
                shaderLocation: 1,
                format: "float32x2",
                stride,
                offset: 2 * 4
              },
              aColor: {
                buffer: attributeBuffer,
                shaderLocation: 2,
                format: "unorm8x4",
                stride,
                offset: 4 * 4
              },
              aTextureIdAndRound: {
                buffer: attributeBuffer,
                shaderLocation: 3,
                format: "uint16x2",
                stride,
                offset: 5 * 4
              }
            },
            indexBuffer
          });
        }
        reset() {
          this.indexBuffer.data = placeHolderIndexData;
          this.buffers[0].data = placeHolderBufferData;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/ViewableBuffer.mjs
  var ViewableBuffer;
  var init_ViewableBuffer = __esm({
    "node_modules/pixi-v8/lib/utils/ViewableBuffer.mjs"() {
      ViewableBuffer = class {
        constructor(sizeOrBuffer) {
          if (typeof sizeOrBuffer === "number") {
            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
          } else if (sizeOrBuffer instanceof Uint8Array) {
            this.rawBinaryData = sizeOrBuffer.buffer;
          } else {
            this.rawBinaryData = sizeOrBuffer;
          }
          this.uint32View = new Uint32Array(this.rawBinaryData);
          this.float32View = new Float32Array(this.rawBinaryData);
          this.size = this.rawBinaryData.byteLength;
        }
        get int8View() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        }
        get uint8View() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        }
        get int16View() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        }
        get int32View() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        }
        get float64View() {
          if (!this._float64Array) {
            this._float64Array = new Float64Array(this.rawBinaryData);
          }
          return this._float64Array;
        }
        get bigUint64View() {
          if (!this._bigUint64Array) {
            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
          }
          return this._bigUint64Array;
        }
        view(type) {
          return this[`${type}View`];
        }
        destroy() {
          this.rawBinaryData = null;
          this._int8View = null;
          this._uint8View = null;
          this._int16View = null;
          this.uint16View = null;
          this._int32View = null;
          this.uint32View = null;
          this.float32View = null;
        }
        static sizeOf(type) {
          switch (type) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(`${type} isn't a valid view type`);
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
  function fastCopy(sourceBuffer, destinationBuffer) {
    const lengthDouble = sourceBuffer.byteLength / 8 | 0;
    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
    for (let i2 = 0; i2 < lengthDouble; i2++) {
      destinationFloat64View[i2] = sourceFloat64View[i2];
    }
    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8);
    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8);
    for (let i2 = 0; i2 < sourceUint8View.length; i2++) {
      destinationUint8View[i2] = sourceUint8View[i2];
    }
  }
  var init_fastCopy = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/BatchTextureArray.mjs
  var BatchTextureArray;
  var init_BatchTextureArray = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
      BatchTextureArray = class {
        constructor() {
          this.ids = /* @__PURE__ */ Object.create(null);
          this.textures = [];
          this.count = 0;
        }
        clear() {
          for (let i2 = 0; i2 < this.count; i2++) {
            const t2 = this.textures[i2];
            this.textures[i2] = null;
            this.ids[t2.uid] = null;
          }
          this.count = 0;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/Batcher.mjs
  var Batch, BATCH_TICK, Batcher;
  var init_Batcher = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/Batcher.mjs"() {
      init_uid();
      init_ViewableBuffer();
      init_fastCopy();
      init_BatchTextureArray();
      init_const3();
      Batch = class {
        constructor() {
          this.type = "batch";
          this.action = "startBatch";
          this.start = 0;
          this.size = 0;
          this.blendMode = "normal";
          this.canBundle = true;
        }
        destroy() {
          this.textures = null;
          this.gpuBindGroup = null;
          this.bindGroup = null;
          this.batcher = null;
        }
      };
      BATCH_TICK = 0;
      Batcher = class {
        constructor(vertexSize = 4, indexSize = 6) {
          this.uid = uid("batcher");
          this.dirty = true;
          this.batchIndex = 0;
          this.batches = [];
          this._vertexSize = 6;
          this._elements = [];
          this._batchPool = [];
          this._batchPoolIndex = 0;
          this._textureBatchPool = [];
          this._textureBatchPoolIndex = 0;
          this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);
          this.indexBuffer = new Uint32Array(indexSize);
        }
        begin() {
          this.batchIndex = 0;
          this.elementSize = 0;
          this.elementStart = 0;
          this.indexSize = 0;
          this.attributeSize = 0;
          this._batchPoolIndex = 0;
          this._textureBatchPoolIndex = 0;
          this._batchIndexStart = 0;
          this._batchIndexSize = 0;
          this.dirty = true;
        }
        add(batchableObject) {
          this._elements[this.elementSize++] = batchableObject;
          batchableObject.indexStart = this.indexSize;
          batchableObject.location = this.attributeSize;
          batchableObject.batcher = this;
          this.indexSize += batchableObject.indexSize;
          this.attributeSize += batchableObject.vertexSize * this._vertexSize;
        }
        checkAndUpdateTexture(batchableObject, texture) {
          const textureId = batchableObject.batch.textures.ids[texture._source.uid];
          if (!textureId && textureId !== 0)
            return false;
          batchableObject.textureId = textureId;
          batchableObject.texture = texture;
          return true;
        }
        updateElement(batchableObject) {
          this.dirty = true;
          batchableObject.packAttributes(
            this.attributeBuffer.float32View,
            this.attributeBuffer.uint32View,
            batchableObject.location,
            batchableObject.textureId
          );
        }
        break(instructionSet) {
          const elements = this._elements;
          let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();
          textureBatch.clear();
          if (!elements[this.elementStart])
            return;
          let blendMode = elements[this.elementStart].blendMode;
          if (this.attributeSize * 4 > this.attributeBuffer.size) {
            this._resizeAttributeBuffer(this.attributeSize * 4);
          }
          if (this.indexSize > this.indexBuffer.length) {
            this._resizeIndexBuffer(this.indexSize);
          }
          const f32 = this.attributeBuffer.float32View;
          const u32 = this.attributeBuffer.uint32View;
          const iBuffer = this.indexBuffer;
          let size2 = this._batchIndexSize;
          let start = this._batchIndexStart;
          let action = "startBatch";
          let batch = this._batchPool[this._batchPoolIndex++] || new Batch();
          for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
            const element = elements[i2];
            elements[i2] = null;
            const texture = element.texture;
            const source2 = texture._source;
            const blendModeChange = blendMode !== element.blendMode;
            if (source2._batchTick === BATCH_TICK && !blendModeChange) {
              element.textureId = source2._textureBindLocation;
              size2 += element.indexSize;
              element.packAttributes(f32, u32, element.location, element.textureId);
              element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);
              element.batch = batch;
              continue;
            }
            source2._batchTick = BATCH_TICK;
            if (textureBatch.count >= MAX_TEXTURES || blendModeChange) {
              this._finishBatch(
                batch,
                start,
                size2 - start,
                textureBatch,
                blendMode,
                instructionSet,
                action
              );
              action = "renderBatch";
              start = size2;
              blendMode = element.blendMode;
              textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();
              textureBatch.clear();
              batch = this._batchPool[this._batchPoolIndex++] || new Batch();
              ++BATCH_TICK;
            }
            element.textureId = source2._textureBindLocation = textureBatch.count;
            textureBatch.ids[source2.uid] = textureBatch.count;
            textureBatch.textures[textureBatch.count++] = source2;
            element.batch = batch;
            size2 += element.indexSize;
            element.packAttributes(f32, u32, element.location, element.textureId);
            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);
          }
          if (textureBatch.count > 0) {
            this._finishBatch(
              batch,
              start,
              size2 - start,
              textureBatch,
              blendMode,
              instructionSet,
              action
            );
            start = size2;
            ++BATCH_TICK;
          }
          this.elementStart = this.elementSize;
          this._batchIndexStart = start;
          this._batchIndexSize = size2;
        }
        _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {
          batch.gpuBindGroup = null;
          batch.action = action;
          batch.batcher = this;
          batch.textures = textureBatch;
          batch.blendMode = blendMode;
          batch.start = indexStart;
          batch.size = indexSize;
          ++BATCH_TICK;
          instructionSet.add(batch);
        }
        finish(instructionSet) {
          this.break(instructionSet);
        }
        ensureAttributeBuffer(size2) {
          if (size2 * 4 < this.attributeBuffer.size)
            return;
          this._resizeAttributeBuffer(size2 * 4);
        }
        ensureIndexBuffer(size2) {
          if (size2 < this.indexBuffer.length)
            return;
          this._resizeIndexBuffer(size2);
        }
        _resizeAttributeBuffer(size2) {
          const newSize = Math.max(size2, this.attributeBuffer.size * 2);
          const newArrayBuffer = new ViewableBuffer(newSize);
          fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
          this.attributeBuffer = newArrayBuffer;
        }
        _resizeIndexBuffer(size2) {
          const indexBuffer = this.indexBuffer;
          const newSize = Math.max(size2, indexBuffer.length * 2);
          const newIndexBuffer = new Uint32Array(newSize);
          fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
          this.indexBuffer = newIndexBuffer;
        }
        destroy() {
          for (let i2 = 0; i2 < this.batches.length; i2++) {
            this.batches[i2].destroy();
          }
          this.batches = null;
          for (let i2 = 0; i2 < this._elements.length; i2++) {
            this._elements[i2].batch = null;
          }
          this._elements = null;
          this.indexBuffer = null;
          this.attributeBuffer.destroy();
          this.attributeBuffer = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
  function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size2, matrix = null) {
    let index = 0;
    verticesOffset *= verticesStride;
    uvsOffset *= uvsStride;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    while (index < size2) {
      const x2 = vertices[verticesOffset];
      const y2 = vertices[verticesOffset + 1];
      uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
      uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
      uvsOffset += uvsStride;
      verticesOffset += verticesStride;
      index++;
    }
  }
  function buildSimpleUvs(uvs, uvsOffset, uvsStride, size2) {
    let index = 0;
    uvsOffset *= uvsStride;
    while (index < size2) {
      uvs[uvsOffset] = 0;
      uvs[uvsOffset + 1] = 0;
      uvsOffset += uvsStride;
      index++;
    }
  }
  var init_buildUvs = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
  function transformVertices(vertices, m2, offset, stride, size2) {
    const a2 = m2.a;
    const b2 = m2.b;
    const c2 = m2.c;
    const d2 = m2.d;
    const tx = m2.tx;
    const ty = m2.ty;
    offset = offset || 0;
    stride = stride || 2;
    size2 = size2 || vertices.length / stride - offset;
    let index = offset * stride;
    for (let i2 = 0; i2 < size2; i2++) {
      const x2 = vertices[index];
      const y2 = vertices[index + 1];
      vertices[index] = a2 * x2 + c2 * y2 + tx;
      vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
      index += stride;
    }
  }
  var init_transformVertices = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/BatchableGraphics.mjs
  var BatchableGraphics;
  var init_BatchableGraphics = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
      init_mixColors();
      BatchableGraphics = class {
        constructor() {
          this.batcher = null;
          this.batch = null;
          this.applyTransform = true;
          this.roundPixels = 0;
        }
        get blendMode() {
          if (this.applyTransform) {
            return this.renderable.layerBlendMode;
          }
          return "normal";
        }
        packIndex(indexBuffer, index, indicesOffset) {
          const indices = this.geometryData.indices;
          for (let i2 = 0; i2 < this.indexSize; i2++) {
            indexBuffer[index++] = indices[i2 + this.indexOffset] + indicesOffset - this.vertexOffset;
          }
        }
        packAttributes(float32View, uint32View, index, textureId) {
          const geometry = this.geometryData;
          const graphics = this.renderable;
          const positions = geometry.vertices;
          const uvs = geometry.uvs;
          const offset = this.vertexOffset * 2;
          const vertSize = (this.vertexOffset + this.vertexSize) * 2;
          const rgb = this.color;
          const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
          if (this.applyTransform) {
            const argb = mixColors(bgr + (this.alpha * 255 << 24), graphics.layerColor);
            const wt = graphics.layerTransform;
            const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
            const a2 = wt.a;
            const b2 = wt.b;
            const c2 = wt.c;
            const d2 = wt.d;
            const tx = wt.tx;
            const ty = wt.ty;
            for (let i2 = offset; i2 < vertSize; i2 += 2) {
              const x2 = positions[i2];
              const y2 = positions[i2 + 1];
              float32View[index] = a2 * x2 + c2 * y2 + tx;
              float32View[index + 1] = b2 * x2 + d2 * y2 + ty;
              float32View[index + 2] = uvs[i2];
              float32View[index + 3] = uvs[i2 + 1];
              uint32View[index + 4] = argb;
              uint32View[index + 5] = textureIdAndRound;
              index += 6;
            }
          } else {
            const argb = bgr + (this.alpha * 255 << 24);
            for (let i2 = offset; i2 < vertSize; i2 += 2) {
              float32View[index] = positions[i2];
              float32View[index + 1] = positions[i2 + 1];
              float32View[index + 2] = uvs[i2];
              float32View[index + 3] = uvs[i2 + 1];
              uint32View[index + 4] = argb;
              uint32View[index + 5] = textureId;
              index += 6;
            }
          }
        }
        get vertSize() {
          return this.vertexSize;
        }
        copyTo(gpuBuffer) {
          gpuBuffer.indexOffset = this.indexOffset;
          gpuBuffer.indexSize = this.indexSize;
          gpuBuffer.vertexOffset = this.vertexOffset;
          gpuBuffer.vertexSize = this.vertexSize;
          gpuBuffer.color = this.color;
          gpuBuffer.alpha = this.alpha;
          gpuBuffer.texture = this.texture;
          gpuBuffer.geometryData = this.geometryData;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
  var buildCircle;
  var init_buildCircle = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
      buildCircle = {
        build(shape, points) {
          let x2;
          let y2;
          let dx;
          let dy;
          let rx;
          let ry;
          if (shape.type === "circle") {
            const circle = shape;
            x2 = circle.x;
            y2 = circle.y;
            rx = ry = circle.radius;
            dx = dy = 0;
          } else if (shape.type === "ellipse") {
            const ellipse = shape;
            x2 = ellipse.x;
            y2 = ellipse.y;
            rx = ellipse.halfWidth;
            ry = ellipse.halfHeight;
            dx = dy = 0;
          } else {
            const roundedRect = shape;
            const halfWidth = roundedRect.width / 2;
            const halfHeight = roundedRect.height / 2;
            x2 = roundedRect.x + halfWidth;
            y2 = roundedRect.y + halfHeight;
            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
            dx = halfWidth - rx;
            dy = halfHeight - ry;
          }
          if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
            return points;
          }
          const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
          const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
          if (m2 === 0) {
            return points;
          }
          if (n2 === 0) {
            points[0] = points[6] = x2 + dx;
            points[1] = points[3] = y2 + dy;
            points[2] = points[4] = x2 - dx;
            points[5] = points[7] = y2 - dy;
            return points;
          }
          let j1 = 0;
          let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
          let j3 = j2;
          let j4 = m2;
          let x0 = dx + rx;
          let y0 = dy;
          let x1 = x2 + x0;
          let x22 = x2 - x0;
          let y1 = y2 + y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j2] = y1;
          points[--j2] = x22;
          if (dy) {
            const y222 = y2 - y0;
            points[j3++] = x22;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x1;
          }
          for (let i2 = 1; i2 < n2; i2++) {
            const a2 = Math.PI / 2 * (i2 / n2);
            const x02 = dx + Math.cos(a2) * rx;
            const y02 = dy + Math.sin(a2) * ry;
            const x12 = x2 + x02;
            const x222 = x2 - x02;
            const y12 = y2 + y02;
            const y222 = y2 - y02;
            points[j1++] = x12;
            points[j1++] = y12;
            points[--j2] = y12;
            points[--j2] = x222;
            points[j3++] = x222;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x12;
          }
          x0 = dx;
          y0 = dy + ry;
          x1 = x2 + x0;
          x22 = x2 - x0;
          y1 = y2 + y0;
          const y22 = y2 - y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x1;
          if (dx) {
            points[j1++] = x22;
            points[j1++] = y1;
            points[--j4] = y22;
            points[--j4] = x22;
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          if (points.length === 0) {
            return;
          }
          let x2 = 0;
          let y2 = 0;
          const div = points.length / 4;
          x2 += points[0];
          y2 += points[1];
          x2 += points[div | 0];
          y2 += points[(div | 0) + 1];
          x2 += points[div * 2 | 0];
          y2 += points[(div * 2 | 0) + 1];
          x2 += points[div * 3 | 0];
          y2 += points[(div * 3 | 0) + 1];
          x2 /= 4;
          y2 /= 4;
          let count2 = verticesOffset;
          vertices[count2 * verticesStride] = x2;
          vertices[count2 * verticesStride + 1] = y2;
          count2++;
          const center = verticesOffset;
          vertices[count2 * verticesStride] = points[0];
          vertices[count2 * verticesStride + 1] = points[1];
          count2++;
          for (let i2 = 2; i2 < points.length; i2 += 2) {
            vertices[count2 * verticesStride] = points[i2];
            vertices[count2 * verticesStride + 1] = points[i2 + 1];
            indices[indicesOffset++] = count2;
            indices[indicesOffset++] = center;
            indices[indicesOffset++] = count2 - 1;
            count2++;
          }
          indices[indicesOffset++] = count2 - 1;
          indices[indicesOffset++] = center;
          indices[indicesOffset++] = center + 1;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/const.mjs
  var closePointEps, curveEps;
  var init_const6 = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/const.mjs"() {
      closePointEps = 1e-4;
      curveEps = 1e-4;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
  function getOrientationOfPoints(points) {
    const m2 = points.length;
    if (m2 < 6) {
      return 1;
    }
    let area = 0;
    for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      area += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (area < 0) {
      return -1;
    }
    return 1;
  }
  var init_getOrientationOfPoints = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildLine.mjs
  function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x2 - nx * innerWeight;
    const iy = y2 - ny * innerWeight;
    const ox = x2 + nx * outerWeight;
    const oy = y2 + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = lineStyle;
    let alignment = style.alignment;
    if (lineStyle.alignment !== 0.5) {
      let orientation = getOrientationOfPoints(points);
      if (flipAlignment)
        orientation *= -1;
      alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = closed;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x0 - perpX * (innerWeight - outerWeight) * 0.5,
          y0 - perpY * (innerWeight - outerWeight) * 0.5,
          x0 - perpX * innerWeight,
          y0 - perpY * innerWeight,
          x0 + perpX * outerWeight,
          y0 + perpY * outerWeight,
          verts,
          true
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(
      x0 - perpX * innerWeight,
      y0 - perpY * innerWeight
    );
    verts.push(
      x0 + perpX * outerWeight,
      y0 + perpY * outerWeight
    );
    for (let i2 = 1; i2 < length - 1; ++i2) {
      x0 = points[(i2 - 1) * 2];
      y0 = points[(i2 - 1) * 2 + 1];
      x1 = points[i2 * 2];
      y1 = points[i2 * 2 + 1];
      x2 = points[(i2 + 1) * 2];
      y2 = points[(i2 + 1) * 2 + 1];
      perpX = -(y0 - y1);
      perpY = x0 - x1;
      dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX /= dist;
      perpY /= dist;
      perpX *= width;
      perpY *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight
        );
        verts.push(
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight
        );
        if (dot >= 0) {
          if (style.join === "round") {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(
            x1 - perp1x * outerWeight,
            y1 - perp1y * outerWeight
          );
          verts.push(
            x1 + perp1x * innerWeight,
            y1 + perp1y * innerWeight
          );
        }
        continue;
      }
      const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pDist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === "round") {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (style.join === "round") {
          if (clockwise) {
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 2;
          } else {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 2;
          }
        } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x1 - perpX * (innerWeight - outerWeight) * 0.5,
          y1 - perpY * (innerWeight - outerWeight) * 0.5,
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight,
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight,
          verts,
          false
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
      }
    }
    const eps2 = curveEps * curveEps;
    for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
      x0 = verts[i2 * 2];
      y0 = verts[i2 * 2 + 1];
      x1 = verts[(i2 + 1) * 2];
      y1 = verts[(i2 + 1) * 2 + 1];
      x2 = verts[(i2 + 2) * 2];
      y2 = verts[(i2 + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices.push(i2, i2 + 1, i2 + 2);
    }
  }
  var init_buildLine = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
      init_Point();
      init_const6();
      init_getOrientationOfPoints();
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i2 = dim; i2 < outerLen; i2 += dim) {
            x2 = data[i2];
            y2 = data[i2 + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i2, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i2 = start; i2 < end; i2 += dim)
            last = insertNode(i2, data[i2], data[i2 + 1], last);
        } else {
          for (i2 = end - dim; i2 >= start; i2 -= dim)
            last = insertNode(i2, data[i2], data[i2 + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p2 = start, again;
        do {
          again = false;
          if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
            removeNode(p2);
            p2 = end = p2.prev;
            if (p2 === p2.next)
              break;
            again = true;
          } else {
            p2 = p2.next;
          }
        } while (again || p2 !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p2 = c2.next;
        while (p2 !== a2) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p2 = ear.prevZ, n2 = ear.nextZ;
        while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        while (p2 && p2.z >= minZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
        }
        while (n2 && n2.z <= maxZ) {
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p2 = start;
        do {
          var a2 = p2.prev, b2 = p2.next.next;
          if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
            triangles.push(a2.i / dim | 0);
            triangles.push(p2.i / dim | 0);
            triangles.push(b2.i / dim | 0);
            removeNode(p2);
            removeNode(p2.next);
            p2 = start = b2;
          }
          p2 = p2.next;
        } while (p2 !== start);
        return filterPoints(p2);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a2 = start;
        do {
          var b2 = a2.next.next;
          while (b2 !== a2.prev) {
            if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
              var c2 = splitPolygon(a2, b2);
              a2 = filterPoints(a2, a2.next);
              c2 = filterPoints(c2, c2.next);
              earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b2 = b2.next;
          }
          a2 = a2.next;
        } while (a2 !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i2, len, start, end, list;
        for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          start = holeIndices[i2] * dim;
          end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i2 = 0; i2 < queue.length; i2++) {
          outerNode = eliminateHole(queue[i2], outerNode);
        }
        return outerNode;
      }
      function compareX(a2, b2) {
        return a2.x - b2.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
        do {
          if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
            var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              m2 = p2.x < p2.next.x ? p2 : p2.next;
              if (x2 === hx)
                return m2;
            }
          }
          p2 = p2.next;
        } while (p2 !== outerNode);
        if (!m2)
          return null;
        var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
        p2 = m2;
        do {
          if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
            tan = Math.abs(hy - p2.y) / (hx - p2.x);
            if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
              m2 = p2;
              tanMin = tan;
            }
          }
          p2 = p2.next;
        } while (p2 !== stop);
        return m2;
      }
      function sectorContainsSector(m2, p2) {
        return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p2 = start;
        do {
          if (p2.z === 0)
            p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
          p2.prevZ = p2.prev;
          p2.nextZ = p2.next;
          p2 = p2.next;
        } while (p2 !== start);
        p2.prevZ.nextZ = null;
        p2.prevZ = null;
        sortLinked(p2);
      }
      function sortLinked(list) {
        var i2, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p2 = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p2) {
            numMerges++;
            q = p2;
            pSize = 0;
            for (i2 = 0; i2 < inSize; i2++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
                e2 = p2;
                p2 = p2.nextZ;
                pSize--;
              } else {
                e2 = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e2;
              else
                list = e2;
              e2.prevZ = tail;
              tail = e2;
            }
            p2 = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = (x2 - minX) * invSize | 0;
        y2 = (y2 - minY) * invSize | 0;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        var p2 = start, leftmost = start;
        do {
          if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
            leftmost = p2;
          p2 = p2.next;
        } while (p2 !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a2, b2) {
        return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
      }
      function area(p2, q, r2) {
        return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p2, q, r2) {
        return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a2, b2) {
        var p2 = a2;
        do {
          if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
            return true;
          p2 = p2.next;
        } while (p2 !== a2);
        return false;
      }
      function locallyInside(a2, b2) {
        return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
      }
      function middleInside(a2, b2) {
        var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
        do {
          if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
            inside = !inside;
          p2 = p2.next;
        } while (p2 !== a2);
        return inside;
      }
      function splitPolygon(a2, b2) {
        var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
        a2.next = b2;
        b2.prev = a2;
        a22.next = an;
        an.prev = a22;
        b22.next = a22;
        a22.prev = b22;
        bp.next = b22;
        b22.prev = bp;
        return b22;
      }
      function insertNode(i2, x2, y2, last) {
        var p2 = new Node(i2, x2, y2);
        if (!last) {
          p2.prev = p2;
          p2.next = p2;
        } else {
          p2.next = last.next;
          p2.prev = last;
          last.next.prev = p2;
          last.next = p2;
        }
        return p2;
      }
      function removeNode(p2) {
        p2.next.prev = p2.prev;
        p2.prev.next = p2.next;
        if (p2.prevZ)
          p2.prevZ.nextZ = p2.nextZ;
        if (p2.nextZ)
          p2.nextZ.prevZ = p2.prevZ;
      }
      function Node(i2, x2, y2) {
        this.i = i2;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
            var start = holeIndices[i2] * dim;
            var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i2 = 0; i2 < triangles.length; i2 += 3) {
          var a2 = triangles[i2] * dim;
          var b2 = triangles[i2 + 1] * dim;
          var c2 = triangles[i2 + 2] * dim;
          trianglesArea += Math.abs(
            (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
          sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
          j2 = i2;
        }
        return sum;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i2 = 0; i2 < data.length; i2++) {
          for (var j2 = 0; j2 < data[i2].length; j2++) {
            for (var d2 = 0; d2 < dim; d2++)
              result.vertices.push(data[i2][j2][d2]);
          }
          if (i2 > 0) {
            holeIndex += data[i2 - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
  function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    const triangles = (0, import_earcut.default)(points, holes, 2);
    if (!triangles) {
      return;
    }
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      indices[indicesOffset++] = triangles[i2] + verticesOffset;
      indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
      indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
    }
    let index = verticesOffset * verticesStride;
    for (let i2 = 0; i2 < points.length; i2 += 2) {
      vertices[index] = points[i2];
      vertices[index + 1] = points[i2 + 1];
      index += verticesStride;
    }
  }
  var import_earcut;
  var init_triangulateWithHoles = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
      import_earcut = __toESM(require_earcut(), 1);
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
  var emptyArray, buildPolygon;
  var init_buildPolygon = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
      init_triangulateWithHoles();
      emptyArray = [];
      buildPolygon = {
        build(shape, points) {
          for (let i2 = 0; i2 < shape.points.length; i2++) {
            points[i2] = shape.points[i2];
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
  var buildRectangle;
  var init_buildRectangle = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
      buildRectangle = {
        build(shape, points) {
          const rectData = shape;
          const x2 = rectData.x;
          const y2 = rectData.y;
          const width = rectData.width;
          const height = rectData.height;
          if (!(width >= 0 && height >= 0)) {
            return points;
          }
          points[0] = x2;
          points[1] = y2;
          points[2] = x2 + width;
          points[3] = y2;
          points[4] = x2 + width;
          points[5] = y2 + height;
          points[6] = x2;
          points[7] = y2 + height;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[6];
          vertices[verticesOffset + count2 + 1] = points[7];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          count2 += verticesStride;
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 3;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
  var buildTriangle;
  var init_buildTriangle = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
      buildTriangle = {
        build(shape, points) {
          points[0] = shape.x;
          points[1] = shape.y;
          points[2] = shape.x2;
          points[3] = shape.y2;
          points[4] = shape.x3;
          points[5] = shape.y3;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/utils/buildContextBatches.mjs
  function buildContextBatches(context2) {
    const vertices = [];
    const uvs = [];
    const indices = [];
    const geometryData = {
      vertices,
      uvs,
      indices
    };
    const batches = [];
    for (let i2 = 0; i2 < context2.instructions.length; i2++) {
      const instruction = context2.instructions[i2];
      if (instruction.action === "texture") {
        addTextureToGeometryData(instruction.data, batches, geometryData);
      } else if (instruction.action === "fill" || instruction.action === "stroke") {
        const isStroke = instruction.action === "stroke";
        const shapePath = instruction.data.path.shapePath;
        const style = instruction.data.style;
        const hole = instruction.data.hole;
        if (isStroke && hole) {
          addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
        }
        addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
      }
    }
    return batches;
  }
  function addTextureToGeometryData(data, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = buildMap.rectangle;
    const rect = tempRect;
    const texture = data.image;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    build.build(rect, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const textureUvs = texture.layout.uvs;
    uvs.push(
      textureUvs.x0,
      textureUvs.y0,
      textureUvs.x1,
      textureUvs.y1,
      textureUvs.x3,
      textureUvs.y3,
      textureUvs.x2,
      textureUvs.y2
    );
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.vertexOffset = vertOffset;
    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
    graphicsBatch.color = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  }
  function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const lastIndex = shapePath.shapePrimitives.length - 1;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i2) => {
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const build = buildMap[shape.type];
      build.build(shape, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      if (!isStroke) {
        if (hole && lastIndex === i2) {
          if (lastIndex !== 0) {
            console.warn("[Pixi Graphics] only the last shape have be cut out");
          }
          const holeIndices = [];
          const otherPoints = points.slice();
          const holeArrays = getHoleArrays(hole.shapePath);
          holeArrays.forEach((holePoints) => {
            holeIndices.push(otherPoints.length / 2);
            otherPoints.push(...holePoints);
          });
          triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
        } else {
          build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        }
      } else {
        const close = shape.closePath ?? true;
        const lineStyle = style;
        buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);
      }
      const uvsOffset = uvs.length / 2;
      const texture = style.texture;
      if (texture !== Texture.WHITE) {
        const textureMatrix = style.matrix;
        if (matrix) {
          textureMatrix.append(matrix.clone().invert());
        }
        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
      const graphicsBatch = BigPool.get(BatchableGraphics);
      graphicsBatch.indexOffset = indexOffset;
      graphicsBatch.indexSize = indices.length - indexOffset;
      graphicsBatch.vertexOffset = vertOffset;
      graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
      graphicsBatch.color = style.color;
      graphicsBatch.alpha = style.alpha;
      graphicsBatch.texture = texture;
      graphicsBatch.geometryData = geometryData;
      batches.push(graphicsBatch);
    });
  }
  function getHoleArrays(shape) {
    if (!shape)
      return [];
    const holePrimitives = shape.shapePrimitives;
    const holeArrays = [];
    for (let k2 = 0; k2 < holePrimitives.length; k2++) {
      const holePrimitive = holePrimitives[k2].shape;
      const holePoints = [];
      const holeBuilder = buildMap[holePrimitive.type];
      holeBuilder.build(holePrimitive, holePoints);
      holeArrays.push(holePoints);
    }
    return holeArrays;
  }
  var buildMap, tempRect;
  var init_buildContextBatches = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
      init_Rectangle();
      init_buildUvs();
      init_transformVertices();
      init_Texture();
      init_PoolGroup();
      init_BatchableGraphics();
      init_buildCircle();
      init_buildLine();
      init_buildPolygon();
      init_buildRectangle();
      init_buildTriangle();
      init_triangulateWithHoles();
      buildMap = {
        rectangle: buildRectangle,
        polygon: buildPolygon,
        triangle: buildTriangle,
        circle: buildCircle,
        ellipse: buildCircle,
        roundedRectangle: buildCircle
      };
      tempRect = new Rectangle();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsContextSystem.mjs
  var GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem;
  var init_GraphicsContextSystem = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
      init_Extensions();
      init_BatchGeometry();
      init_getTextureBatchBindGroup();
      init_Batcher();
      init_InstructionSet();
      init_PoolGroup();
      init_buildContextBatches();
      GpuGraphicsContext = class {
      };
      GraphicsContextRenderData = class {
        constructor() {
          this.geometry = new BatchGeometry();
          this.instructions = new InstructionSet();
        }
        init() {
          this.geometry.reset();
          this.instructions.reset();
        }
      };
      GraphicsContextSystem = class {
        constructor() {
          this._activeBatchers = [];
          this._gpuContextHash = {};
          this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
          this._needsContextNeedsRebuild = [];
        }
        prerender() {
          this._returnActiveBatchers();
        }
        getContextRenderData(context2) {
          return this._graphicsDataContextHash[context2.uid] || this._initContextRenderData(context2);
        }
        updateGpuContext(context2) {
          let gpuContext = this._gpuContextHash[context2.uid] || this._initContext(context2);
          if (context2.dirty) {
            if (gpuContext) {
              this._cleanGraphicsContextData(context2);
            } else {
              gpuContext = this._initContext(context2);
            }
            const contextBatches = buildContextBatches(context2);
            let size2 = 0;
            const batchMode = context2.batchMode;
            let isBatchable = true;
            if (context2.customShader || batchMode === "no-batch") {
              isBatchable = false;
            } else if (batchMode === "auto") {
              for (let i2 = 0; i2 < contextBatches.length; i2++) {
                size2 += contextBatches[i2].vertexSize;
                if (size2 > 400) {
                  isBatchable = false;
                  break;
                }
              }
            }
            gpuContext = this._gpuContextHash[context2.uid] = {
              isBatchable,
              batches: contextBatches
            };
            context2.dirty = false;
          }
          return gpuContext;
        }
        getGpuContext(context2) {
          return this._gpuContextHash[context2.uid] || this._initContext(context2);
        }
        _returnActiveBatchers() {
          for (let i2 = 0; i2 < this._activeBatchers.length; i2++) {
            BigPool.return(this._activeBatchers[i2]);
          }
          this._activeBatchers.length = 0;
        }
        _initContextRenderData(context2) {
          const graphicsData = BigPool.get(GraphicsContextRenderData);
          const batches = this._gpuContextHash[context2.uid].batches;
          let vertexSize = 0;
          let indexSize = 0;
          batches.forEach((batch) => {
            batch.applyTransform = false;
            vertexSize += batch.geometryData.vertices.length;
            indexSize += batch.geometryData.indices.length;
          });
          const batcher = BigPool.get(Batcher);
          this._activeBatchers.push(batcher);
          batcher.ensureAttributeBuffer(vertexSize);
          batcher.ensureIndexBuffer(indexSize);
          batcher.begin();
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batcher.add(batch);
          }
          batcher.finish(graphicsData.instructions);
          const geometry = graphicsData.geometry;
          geometry.indexBuffer.data = batcher.indexBuffer;
          geometry.buffers[0].data = batcher.attributeBuffer.float32View;
          geometry.indexBuffer.update(batcher.indexSize * 4);
          geometry.buffers[0].update(batcher.attributeSize * 4);
          const drawBatches = batcher.batches;
          for (let i2 = 0; i2 < drawBatches.length; i2++) {
            const batch = drawBatches[i2];
            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
          }
          this._graphicsDataContextHash[context2.uid] = graphicsData;
          return graphicsData;
        }
        _initContext(context2) {
          const gpuContext = new GpuGraphicsContext();
          this._gpuContextHash[context2.uid] = gpuContext;
          context2.on("update", this.onGraphicsContextUpdate, this);
          context2.on("destroy", this.onGraphicsContextDestroy, this);
          return this._gpuContextHash[context2.uid];
        }
        onGraphicsContextUpdate(context2) {
          this._needsContextNeedsRebuild.push(context2);
        }
        onGraphicsContextDestroy(context2) {
          this._cleanGraphicsContextData(context2);
          this._gpuContextHash[context2.uid] = null;
        }
        _cleanGraphicsContextData(context2) {
          const gpuContext = this._gpuContextHash[context2.uid];
          if (!gpuContext.isBatchable) {
            if (this._graphicsDataContextHash[context2.uid]) {
              BigPool.return(this.getContextRenderData(context2));
              this._graphicsDataContextHash[context2.uid] = null;
            }
          }
          if (gpuContext.batches) {
            gpuContext.batches.forEach((batch) => {
              BigPool.return(batch);
            });
          }
        }
        destroy() {
          for (const context2 of this._needsContextNeedsRebuild) {
            this._cleanGraphicsContextData(context2);
            this._gpuContextHash[context2.uid] = null;
          }
          this._needsContextNeedsRebuild.length = 0;
        }
      };
      GraphicsContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "graphicsContext"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/gpu/colorToUniform.mjs
  function color32BitToUniform(abgr, out2, offset) {
    out2[offset++] = (abgr & 255) / 255;
    out2[offset++] = (abgr >> 8 & 255) / 255;
    out2[offset++] = (abgr >> 16 & 255) / 255;
    out2[offset++] = (abgr >> 24 & 255) / 255;
  }
  var init_colorToUniform = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/gpu/colorToUniform.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsPipe.mjs
  var GraphicsPipe;
  var init_GraphicsPipe = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
      init_Extensions();
      init_State();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableGraphics();
      GraphicsPipe = class {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._renderableBatchesHash = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
        }
        validateRenderable(renderable) {
          const context2 = renderable.view.context;
          const wasBatched = !!this._renderableBatchesHash[renderable.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(context2);
          if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
            return true;
          }
          return false;
        }
        addRenderable(renderable, instructionSet) {
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(renderable.view.context);
          if (renderable.view._didUpdate) {
            renderable.view._didUpdate = false;
            this._rebuild(renderable);
          }
          if (gpuContext.isBatchable) {
            this._addToBatcher(renderable, instructionSet);
          } else {
            this.renderer.renderPipes.batch.break(instructionSet);
            instructionSet.add({
              type: "graphics",
              renderable
            });
          }
        }
        updateRenderable(renderable) {
          const batches = this._renderableBatchesHash[renderable.uid];
          if (batches) {
            for (let i2 = 0; i2 < batches.length; i2++) {
              const batch = batches[i2];
              batch.batcher.updateElement(batch);
            }
          }
        }
        destroyRenderable(renderable) {
          this._removeBatchForRenderable(renderable.uid);
        }
        execute({ renderable }) {
          if (!renderable.isRenderable)
            return;
          const renderer = this.renderer;
          const context2 = renderable.view.context;
          const contextSystem = renderer.graphicsContext;
          if (!contextSystem.getGpuContext(context2).batches.length) {
            return;
          }
          const shader = context2.customShader || this._adaptor.shader;
          this.state.blendMode = renderable.layerBlendMode;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = renderable.layerTransform;
          localUniforms.uRound = renderer._roundPixels | renderable.view.roundPixels;
          color32BitToUniform(
            renderable.layerColor,
            localUniforms.uColor,
            0
          );
          this._adaptor.execute(this, renderable);
        }
        _rebuild(renderable) {
          const wasBatched = !!this._renderableBatchesHash[renderable.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(renderable.view.context);
          if (wasBatched) {
            this._removeBatchForRenderable(renderable.uid);
          }
          if (gpuContext.isBatchable) {
            this._initBatchesForRenderable(renderable);
          }
          renderable.view.batched = gpuContext.isBatchable;
        }
        _addToBatcher(renderable, instructionSet) {
          const batchPipe = this.renderer.renderPipes.batch;
          const batches = this._getBatchesForRenderable(renderable);
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batchPipe.addToBatch(batch, instructionSet);
          }
        }
        _getBatchesForRenderable(renderable) {
          return this._renderableBatchesHash[renderable.uid] || this._initBatchesForRenderable(renderable);
        }
        _initBatchesForRenderable(renderable) {
          const context2 = renderable.view.context;
          const gpuContext = this.renderer.graphicsContext.getGpuContext(context2);
          const roundPixels = this.renderer._roundPixels | renderable.view.roundPixels;
          const batches = gpuContext.batches.map((batch) => {
            const batchClone = BigPool.get(BatchableGraphics);
            batch.copyTo(batchClone);
            batchClone.renderable = renderable;
            batchClone.roundPixels = roundPixels;
            return batchClone;
          });
          this._renderableBatchesHash[renderable.uid] = batches;
          renderable.on("destroyed", () => {
            this.destroyRenderable(renderable);
          });
          return batches;
        }
        _removeBatchForRenderable(renderableUid) {
          this._renderableBatchesHash[renderableUid].forEach((batch) => {
            BigPool.return(batch);
          });
          this._renderableBatchesHash[renderableUid] = null;
        }
        destroy() {
          this.renderer = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.state = null;
          for (const i2 in this._renderableBatchesHash) {
            this._removeBatchForRenderable(i2);
          }
          this._renderableBatchesHash = null;
        }
      };
      GraphicsPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/shared/BatchableMesh.mjs
  var BatchableMesh;
  var init_BatchableMesh = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/shared/BatchableMesh.mjs"() {
      BatchableMesh = class {
        constructor() {
          this.batcher = null;
          this.batch = null;
          this.roundPixels = 0;
        }
        get blendMode() {
          return this.renderable.layerBlendMode;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this.batcher = null;
          this.batch = null;
        }
        packIndex(indexBuffer, index, indicesOffset) {
          const indices = this.renderable.view.geometry.indices;
          for (let i2 = 0; i2 < indices.length; i2++) {
            indexBuffer[index++] = indices[i2] + indicesOffset;
          }
        }
        packAttributes(float32View, uint32View, index, textureId) {
          const renderable = this.renderable;
          const view = this.renderable.view;
          const geometry = view.geometry;
          const wt = renderable.layerTransform;
          const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const positions = geometry.positions;
          const uvs = geometry.uvs;
          const abgr = renderable.layerColor;
          for (let i2 = 0; i2 < positions.length; i2 += 2) {
            const x2 = positions[i2];
            const y2 = positions[i2 + 1];
            float32View[index] = a2 * x2 + c2 * y2 + tx;
            float32View[index + 1] = b2 * x2 + d2 * y2 + ty;
            float32View[index + 2] = uvs[i2];
            float32View[index + 3] = uvs[i2 + 1];
            uint32View[index + 4] = abgr;
            uint32View[index + 5] = textureIdAndRound;
            index += 6;
          }
        }
        get vertexSize() {
          return this.renderable.view.geometry.positions.length / 2;
        }
        get indexSize() {
          return this.renderable.view.geometry.indices.length;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/shared/MeshPipe.mjs
  var MeshPipe;
  var init_MeshPipe = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/shared/MeshPipe.mjs"() {
      init_Extensions();
      init_Matrix();
      init_BindGroup();
      init_UniformGroup();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableMesh();
      MeshPipe = class {
        constructor(renderer, adaptor) {
          this.localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          this.localUniformsBindGroup = new BindGroup({
            0: this.localUniforms
          });
          this._renderableHash = /* @__PURE__ */ Object.create(null);
          this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
        }
        validateRenderable(renderable) {
          const renderableData = this._getRenderableData(renderable);
          const wasBatched = renderableData.batched;
          const isBatched = renderable.view.batched;
          renderableData.batched = isBatched;
          if (wasBatched !== isBatched) {
            return true;
          } else if (isBatched) {
            const geometry = renderable.view._geometry;
            if (geometry.indices.length !== renderableData.indexSize || geometry.positions.length !== renderableData.vertexSize) {
              renderableData.indexSize = geometry.indices.length;
              renderableData.vertexSize = geometry.positions.length;
              return true;
            }
            const batchableMesh = this._getBatchableMesh(renderable);
            const texture = renderable.view.texture;
            if (batchableMesh.texture._source !== texture._source) {
              if (batchableMesh.texture._source !== texture._source) {
                return batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);
              }
            }
          }
          return false;
        }
        addRenderable(renderable, instructionSet) {
          const batcher = this.renderer.renderPipes.batch;
          const { batched } = this._getRenderableData(renderable);
          if (batched) {
            const gpuBatchableMesh = this._getBatchableMesh(renderable);
            gpuBatchableMesh.texture = renderable.view._texture;
            batcher.addToBatch(gpuBatchableMesh);
          } else {
            batcher.break(instructionSet);
            instructionSet.add({
              type: "mesh",
              renderable
            });
          }
        }
        updateRenderable(renderable) {
          if (renderable.view.batched) {
            const gpuBatchableMesh = this._gpuBatchableMeshHash[renderable.uid];
            gpuBatchableMesh.texture = renderable.view._texture;
            gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);
          }
        }
        destroyRenderable(renderable) {
          this._renderableHash[renderable.uid] = null;
          const gpuMesh = this._gpuBatchableMeshHash[renderable.uid];
          BigPool.return(gpuMesh);
          this._gpuBatchableMeshHash[renderable.uid] = null;
        }
        execute({ renderable }) {
          if (!renderable.isRenderable)
            return;
          const view = renderable.view;
          view.state.blendMode = renderable.layerBlendMode;
          const localUniforms = this.localUniforms;
          localUniforms.uniforms.uTransformMatrix = renderable.layerTransform;
          localUniforms.uniforms.uRound = this.renderer._roundPixels | renderable.view.roundPixels;
          localUniforms.update();
          color32BitToUniform(
            renderable.layerColor,
            localUniforms.uniforms.uColor,
            0
          );
          this._adaptor.execute(this, renderable);
        }
        _getRenderableData(renderable) {
          return this._renderableHash[renderable.uid] || this._initRenderableData(renderable);
        }
        _initRenderableData(renderable) {
          const view = renderable.view;
          this._renderableHash[renderable.uid] = {
            batched: view.batched,
            indexSize: view._geometry.indices.length,
            vertexSize: view._geometry.positions.length
          };
          renderable.on("destroyed", () => {
            this.destroyRenderable(renderable);
          });
          return this._renderableHash[renderable.uid];
        }
        _getBatchableMesh(renderable) {
          return this._gpuBatchableMeshHash[renderable.uid] || this._initBatchableMesh(renderable);
        }
        _initBatchableMesh(renderable) {
          const gpuMesh = BigPool.get(BatchableMesh);
          gpuMesh.renderable = renderable;
          gpuMesh.texture = renderable.view._texture;
          gpuMesh.roundPixels = this.renderer._roundPixels | renderable.view.roundPixels;
          this._gpuBatchableMeshHash[renderable.uid] = gpuMesh;
          gpuMesh.renderable = renderable;
          return gpuMesh;
        }
        destroy() {
          for (const i2 in this._gpuBatchableMeshHash) {
            if (this._gpuBatchableMeshHash[i2]) {
              BigPool.return(this._gpuBatchableMeshHash[i2]);
            }
          }
          this._gpuBatchableMeshHash = null;
          this._renderableHash = null;
          this.localUniforms = null;
          this.localUniformsBindGroup = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.renderer = null;
        }
      };
      MeshPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite/BatchableSprite.mjs
  var BatchableSprite;
  var init_BatchableSprite = __esm({
    "node_modules/pixi-v8/lib/scene/sprite/BatchableSprite.mjs"() {
      BatchableSprite = class {
        constructor() {
          this.vertexSize = 4;
          this.indexSize = 6;
          this.location = 0;
          this.batcher = null;
          this.batch = null;
          this.roundPixels = 0;
        }
        get blendMode() {
          return this.renderable.layerBlendMode;
        }
        packAttributes(float32View, uint32View, index, textureId) {
          const sprite = this.renderable;
          const texture = this.texture;
          const wt = sprite.layerTransform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const bounds = this.bounds;
          const w0 = bounds[1];
          const w1 = bounds[0];
          const h0 = bounds[3];
          const h1 = bounds[2];
          const uvs = texture._layout.uvs;
          const argb = sprite.layerColor;
          const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
          float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
          float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
          float32View[index + 2] = uvs.x0;
          float32View[index + 3] = uvs.y0;
          uint32View[index + 4] = argb;
          uint32View[index + 5] = textureIdAndRound;
          float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
          float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
          float32View[index + 8] = uvs.x1;
          float32View[index + 9] = uvs.y1;
          uint32View[index + 10] = argb;
          uint32View[index + 11] = textureIdAndRound;
          float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
          float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
          float32View[index + 14] = uvs.x2;
          float32View[index + 15] = uvs.y2;
          uint32View[index + 16] = argb;
          uint32View[index + 17] = textureIdAndRound;
          float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
          float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
          float32View[index + 20] = uvs.x3;
          float32View[index + 21] = uvs.y3;
          uint32View[index + 22] = argb;
          uint32View[index + 23] = textureIdAndRound;
        }
        packIndex(indexBuffer, index, indicesOffset) {
          indexBuffer[index] = indicesOffset + 0;
          indexBuffer[index + 1] = indicesOffset + 1;
          indexBuffer[index + 2] = indicesOffset + 2;
          indexBuffer[index + 3] = indicesOffset + 0;
          indexBuffer[index + 4] = indicesOffset + 2;
          indexBuffer[index + 5] = indicesOffset + 3;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this.batcher = null;
          this.batch = null;
          this.bounds = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite/SpritePipe.mjs
  var gpuSpriteHash, SpritePipe;
  var init_SpritePipe = __esm({
    "node_modules/pixi-v8/lib/scene/sprite/SpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableSprite();
      SpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          gpuSpriteHash = this._gpuSpriteHash;
        }
        addRenderable(renderable, _instructionSet) {
          const gpuSprite = this._getGpuSprite(renderable);
          if (renderable.view._didUpdate)
            this._updateBatchableSprite(renderable, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite);
        }
        updateRenderable(renderable) {
          const gpuSprite = gpuSpriteHash[renderable.uid];
          if (renderable.view._didUpdate)
            this._updateBatchableSprite(renderable, gpuSprite);
          gpuSprite.batcher.updateElement(gpuSprite);
        }
        validateRenderable(renderable) {
          const texture = renderable.view._texture;
          const gpuSprite = this._getGpuSprite(renderable);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(renderable) {
          const batchableSprite = gpuSpriteHash[renderable.uid];
          BigPool.return(batchableSprite);
          gpuSpriteHash[renderable.uid] = null;
        }
        _updateBatchableSprite(renderable, batchableSprite) {
          const view = renderable.view;
          view._didUpdate = false;
          batchableSprite.bounds = view.bounds;
          batchableSprite.texture = view._texture;
        }
        _getGpuSprite(renderable) {
          return gpuSpriteHash[renderable.uid] || this._initGPUSprite(renderable);
        }
        _initGPUSprite(renderable) {
          const batchableSprite = BigPool.get(BatchableSprite);
          batchableSprite.renderable = renderable;
          const view = renderable.view;
          batchableSprite.texture = view._texture;
          batchableSprite.bounds = view.bounds;
          batchableSprite.roundPixels = this._renderer._roundPixels | view.roundPixels;
          gpuSpriteHash[renderable.uid] = batchableSprite;
          renderable.view._didUpdate = false;
          renderable.on("destroyed", () => {
            this.destroyRenderable(renderable);
          });
          return batchableSprite;
        }
        destroy() {
          for (const i2 in this._gpuSpriteHash) {
            BigPool.return(this._gpuSpriteHash[i2]);
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      SpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "sprite"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/ProxyRenderable.mjs
  var ProxyRenderable;
  var init_ProxyRenderable = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/ProxyRenderable.mjs"() {
      init_eventemitter3();
      init_uid();
      ProxyRenderable = class extends eventemitter3_default {
        constructor({ original, view }) {
          super();
          this.uid = uid("renderable");
          this.didViewUpdate = false;
          this.view = view;
          if (original) {
            this.init(original);
          }
        }
        init(original) {
          this._original = original;
          this.layerTransform = original.layerTransform;
        }
        get layerColor() {
          return this._original.layerColor;
        }
        get layerBlendMode() {
          return this._original.layerBlendMode;
        }
        get layerVisibleRenderable() {
          return this._original.layerVisibleRenderable;
        }
        get isRenderable() {
          return this._original.isRenderable;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/shared/MeshView.mjs
  var tempPolygon, MeshView;
  var init_MeshView = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/shared/MeshView.mjs"() {
      init_Polygon();
      init_State();
      init_Texture();
      init_View();
      init_uid();
      tempPolygon = new Polygon();
      MeshView = class {
        constructor(options) {
          this.uid = uid("meshView");
          this.renderPipeId = "mesh";
          this.canBundle = true;
          this.owner = emptyViewObserver;
          this.state = State.for2d();
          this.roundPixels = 0;
          this.shader = options.shader;
          this.texture = options.texture ?? this.shader?.texture ?? Texture.WHITE;
          this._geometry = options.geometry;
          this._geometry.on("update", this.onUpdate, this);
        }
        set shader(value) {
          if (this._shader === value)
            return;
          this._shader = value;
          this.onUpdate();
        }
        get shader() {
          return this._shader;
        }
        set geometry(value) {
          if (this._geometry === value)
            return;
          this._geometry?.off("update", this.onUpdate, this);
          value.on("update", this.onUpdate, this);
          this._geometry = value;
          this.onUpdate();
        }
        get geometry() {
          return this._geometry;
        }
        set texture(value) {
          if (this._texture === value)
            return;
          if (this.shader) {
            this.shader.texture = value;
          }
          this._texture = value;
          this.onUpdate();
        }
        get texture() {
          return this._texture;
        }
        get batched() {
          if (this._shader)
            return false;
          if (this._geometry.batchMode === "auto") {
            return this._geometry.positions.length / 2 <= 100;
          }
          return this._geometry.batchMode === "batch";
        }
        addBounds(bounds) {
          bounds.addVertexData(this.geometry.positions, 0, this.geometry.positions.length);
        }
        containsPoint(point) {
          const { x: x2, y: y2 } = point;
          const vertices = this.geometry.getBuffer("aPosition").data;
          const points = tempPolygon.points;
          const indices = this.geometry.getIndex().data;
          const len = indices.length;
          const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
          for (let i2 = 0; i2 + 2 < len; i2 += step) {
            const ind0 = indices[i2] * 2;
            const ind1 = indices[i2 + 1] * 2;
            const ind2 = indices[i2 + 2] * 2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];
            if (tempPolygon.contains(x2, y2)) {
              return true;
            }
          }
          return false;
        }
        onUpdate() {
          this.owner.onViewUpdate();
        }
        destroy(options = false) {
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
          this._geometry = null;
          this._shader = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/shared/MeshGeometry.mjs
  var _MeshGeometry, MeshGeometry;
  var init_MeshGeometry = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/shared/MeshGeometry.mjs"() {
      init_Buffer();
      init_const5();
      init_Geometry();
      init_deprecation();
      _MeshGeometry = class extends Geometry {
        constructor(...args) {
          let options = args[0] ?? {};
          if (options instanceof Float32Array) {
            deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
            options = {
              positions: options,
              uvs: args[1],
              indices: args[2]
            };
          }
          options = { ..._MeshGeometry.defaultOptions, ...options };
          const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
          const positionBuffer = new Buffer2({
            data: positions,
            label: "attribute-mesh-positions",
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const uvBuffer = new Buffer2({
            data: uvs,
            label: "attribute-mesh-uvs",
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const indexBuffer = new Buffer2({
            data: indices,
            label: "index-mesh-buffer",
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          });
          super({
            attributes: {
              aPosition: {
                buffer: positionBuffer,
                shaderLocation: 0,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              },
              aUV: {
                buffer: uvBuffer,
                shaderLocation: 1,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              }
            },
            indexBuffer,
            topology: options.topology
          });
          this.batchMode = "auto";
        }
        get positions() {
          return this.attributes.aPosition.buffer.data;
        }
        set positions(value) {
          this.attributes.aPosition.buffer.data = value;
        }
        get uvs() {
          return this.attributes.aUV.buffer.data;
        }
        set uvs(value) {
          this.attributes.aUV.buffer.data = value;
        }
        get indices() {
          return this.indexBuffer.data;
        }
        set indices(value) {
          this.indexBuffer.data = value;
        }
      };
      MeshGeometry = _MeshGeometry;
      MeshGeometry.defaultOptions = {
        topology: "triangle-list"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/QuadGeometry.mjs
  var QuadGeometry;
  var init_QuadGeometry = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/QuadGeometry.mjs"() {
      init_MeshGeometry();
      QuadGeometry = class extends MeshGeometry {
        constructor() {
          super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3])
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/shader/tilingBit.mjs
  var tilingBit, tilingBitGl;
  var init_tilingBit = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
      tilingBit = {
        name: "tiling-bit",
        vertex: {
          header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
          main: `
            vUV = (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        },
        fragment: {
          header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
          main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        }
      };
      tilingBitGl = {
        name: "tiling-bit",
        vertex: {
          header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,
          main: `
            vUV = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        },
        fragment: {
          header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
          main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0
    
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
  var TilingSpriteShader;
  var init_TilingSpriteShader = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      init_tilingBit();
      TilingSpriteShader = class extends Shader {
        constructor(options) {
          const gpuProgram = compileHighShaderGpuProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBit,
              tilingBit,
              roundPixelsBit
            ]
          });
          const glProgram = compileHighShaderGlProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBitGl,
              tilingBitGl,
              roundPixelsBitGl
            ]
          });
          const tilingUniforms = new UniformGroup({
            uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
            uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
            uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
            uSizeAnchor: { value: new Float32Array([100, 200, 0.5, 0.5]), type: "vec4<f32>" }
          });
          super({
            glProgram,
            gpuProgram,
            resources: {
              tilingUniforms,
              uTexture: options.texture.source,
              uSampler: options.texture.source.style
            }
          });
        }
        get texture() {
          return this._texture;
        }
        set texture(value) {
          if (this._texture === value)
            return;
          this._texture = value;
          this.resources.uTexture = value.source;
          this.resources.uSampler = value.source.style;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/TilingSpritePipe.mjs
  function applyMatrix(array, stride, offset, matrix) {
    let index = 0;
    const size2 = array.length / (stride || 2);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    while (index < size2) {
      const x2 = array[offset];
      const y2 = array[offset + 1];
      array[offset] = a2 * x2 + c2 * y2 + tx;
      array[offset + 1] = b2 * x2 + d2 * y2 + ty;
      offset += stride;
      index++;
    }
  }
  var sharedQuad, TilingSpritePipe;
  var init_TilingSpritePipe = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
      init_Extensions();
      init_Matrix();
      init_ProxyRenderable();
      init_MeshView();
      init_QuadGeometry();
      init_TilingSpriteShader();
      sharedQuad = new QuadGeometry();
      TilingSpritePipe = class {
        constructor(renderer) {
          this._renderableHash = /* @__PURE__ */ Object.create(null);
          this._gpuBatchedTilingSprite = /* @__PURE__ */ Object.create(null);
          this._gpuTilingSprite = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        validateRenderable(renderable) {
          const textureMatrix = renderable.view.texture.textureMatrix;
          let rebuild = false;
          const renderableData = this._getRenderableData(renderable);
          if (renderableData.batched !== textureMatrix.isSimple) {
            renderableData.batched = textureMatrix.isSimple;
            rebuild = true;
          }
          return rebuild;
        }
        addRenderable(renderable, instructionSet) {
          if (renderable.view._didUpdate) {
            renderable.view._didUpdate = false;
            this._rebuild(renderable);
          }
          const { batched } = this._getRenderableData(renderable);
          if (batched) {
            const batchableTilingSprite = this._getBatchedTilingSprite(renderable);
            this._renderer.renderPipes.mesh.addRenderable(batchableTilingSprite, instructionSet);
          } else {
            const gpuTilingSprite = this._getGpuTilingSprite(renderable);
            this._renderer.renderPipes.mesh.addRenderable(gpuTilingSprite.meshRenderable, instructionSet);
          }
        }
        updateRenderable(renderable) {
          if (renderable.view._didUpdate) {
            renderable.view._didUpdate = false;
            this._rebuild(renderable);
          }
          const { batched } = this._getRenderableData(renderable);
          if (batched) {
            const batchableTilingSprite = this._getBatchedTilingSprite(renderable);
            this._renderer.renderPipes.mesh.updateRenderable(batchableTilingSprite);
          } else {
            const gpuTilingSprite = this._getGpuTilingSprite(renderable);
            this._renderer.renderPipes.mesh.updateRenderable(gpuTilingSprite.meshRenderable);
          }
        }
        destroyRenderable(renderable) {
          this._renderableHash[renderable.uid] = null;
          this._gpuTilingSprite[renderable.uid] = null;
          this._gpuBatchedTilingSprite[renderable.uid] = null;
        }
        _getRenderableData(renderable) {
          return this._renderableHash[renderable.uid] || this._initRenderableData(renderable);
        }
        _initRenderableData(renderable) {
          const renderableData = {
            batched: true
          };
          this._renderableHash[renderable.uid] = renderableData;
          this.validateRenderable(renderable);
          renderable.on("destroyed", () => {
            this.destroyRenderable(renderable);
          });
          return renderableData;
        }
        _rebuild(renderable) {
          const renderableData = this._getRenderableData(renderable);
          const view = renderable.view;
          const textureMatrix = view.texture.textureMatrix;
          if (renderableData.batched) {
            const batchedMesh = this._getBatchedTilingSprite(renderable);
            batchedMesh.view.texture = view.texture;
            const style = view.texture.source.style;
            if (style.addressMode !== "repeat") {
              style.addressMode = "repeat";
              style.update();
            }
            this._updateBatchPositions(renderable);
            this._updateBatchUvs(renderable);
          } else {
            const gpuTilingSprite = this._getGpuTilingSprite(renderable);
            const { meshRenderable } = gpuTilingSprite;
            const meshView = meshRenderable.view;
            meshView.shader.texture = view.texture;
            const tilingUniforms = meshView.shader.resources.tilingUniforms;
            const originalWidth = view.width;
            const originalHeight = view.height;
            const tilingSpriteWidth = view.texture.width;
            const tilingSpriteHeight = view.texture.height;
            const matrix = view._tileTransform.matrix;
            const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
            uTextureTransform.set(
              matrix.a * tilingSpriteWidth / originalWidth,
              matrix.b * tilingSpriteWidth / originalHeight,
              matrix.c * tilingSpriteHeight / originalWidth,
              matrix.d * tilingSpriteHeight / originalHeight,
              matrix.tx / originalWidth,
              matrix.ty / originalHeight
            );
            uTextureTransform.invert();
            tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
            tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
            tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
            tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
            tilingUniforms.uniforms.uSizeAnchor[0] = originalWidth;
            tilingUniforms.uniforms.uSizeAnchor[1] = originalHeight;
            tilingUniforms.uniforms.uSizeAnchor[2] = renderable.view.anchor.x;
            tilingUniforms.uniforms.uSizeAnchor[3] = renderable.view.anchor.y;
            tilingUniforms.update();
          }
        }
        _getGpuTilingSprite(renderable) {
          return this._gpuTilingSprite[renderable.uid] || this._initGpuTilingSprite(renderable);
        }
        _initGpuTilingSprite(renderable) {
          const view = renderable.view;
          const style = view.texture.source.style;
          style.addressMode = "repeat";
          style.update();
          const meshView = new MeshView({
            geometry: sharedQuad,
            shader: new TilingSpriteShader({
              texture: view.texture
            })
          });
          const meshRenderable = new ProxyRenderable({
            original: renderable,
            view: meshView
          });
          const textureMatrix = new Matrix();
          const gpuTilingSpriteData = {
            meshRenderable,
            textureMatrix
          };
          this._gpuTilingSprite[renderable.uid] = gpuTilingSpriteData;
          return gpuTilingSpriteData;
        }
        _getBatchedTilingSprite(renderable) {
          return this._gpuBatchedTilingSprite[renderable.uid] || this._initBatchedTilingSprite(renderable);
        }
        _initBatchedTilingSprite(renderable) {
          const meshView = new MeshView({
            geometry: new QuadGeometry(),
            texture: renderable.view.texture
          });
          meshView.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
          const batchableMeshRenderable = new ProxyRenderable({
            original: renderable,
            view: meshView
          });
          this._gpuBatchedTilingSprite[renderable.uid] = batchableMeshRenderable;
          return batchableMeshRenderable;
        }
        _updateBatchPositions(renderable) {
          const meshRenderable = this._getBatchedTilingSprite(renderable);
          const view = renderable.view;
          const positionBuffer = meshRenderable.view.geometry.getBuffer("aPosition");
          const positions = positionBuffer.data;
          const anchorX = view.anchor.x;
          const anchorY = view.anchor.y;
          positions[0] = -anchorX * view.width;
          positions[1] = -anchorY * view.height;
          positions[2] = (1 - anchorX) * view.width;
          positions[3] = -anchorY * view.height;
          positions[4] = (1 - anchorX) * view.width;
          positions[5] = (1 - anchorY) * view.height;
          positions[6] = -anchorX * view.width;
          positions[7] = (1 - anchorY) * view.height;
        }
        _updateBatchUvs(renderable) {
          const view = renderable.view;
          const width = view.texture.frameWidth;
          const height = view.texture.frameHeight;
          const meshRenderable = this._getBatchedTilingSprite(renderable);
          const uvBuffer = meshRenderable.view.geometry.getBuffer("aUV");
          const uvs = uvBuffer.data;
          let anchorX = 0;
          let anchorY = 0;
          if (view._applyAnchorToTexture) {
            anchorX = view.anchor.x;
            anchorY = view.anchor.y;
          }
          uvs[0] = uvs[6] = -anchorX;
          uvs[2] = uvs[4] = 1 - anchorX;
          uvs[1] = uvs[3] = -anchorY;
          uvs[5] = uvs[7] = 1 - anchorY;
          const textureMatrix = Matrix.shared;
          textureMatrix.copyFrom(view._tileTransform.matrix);
          textureMatrix.tx /= view.width;
          textureMatrix.ty /= view.height;
          textureMatrix.invert();
          textureMatrix.scale(view.width / width, view.height / height);
          applyMatrix(uvs, 2, 0, textureMatrix);
        }
        destroy() {
          this._renderableHash = null;
          this._gpuTilingSprite = null;
          this._gpuBatchedTilingSprite = null;
          this._renderer = null;
        }
      };
      TilingSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "tilingSprite"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsView.mjs
  var GraphicsView;
  var init_GraphicsView = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsView.mjs"() {
      init_View();
      init_uid();
      init_GraphicsContext();
      GraphicsView = class {
        constructor(graphicsContext) {
          this.uid = uid("graphicsView");
          this.canBundle = true;
          this.owner = emptyViewObserver;
          this.renderPipeId = "graphics";
          this.roundPixels = 0;
          this._context = graphicsContext || new GraphicsContext();
          this._context.on("update", this.onGraphicsContextUpdate, this);
        }
        set context(context2) {
          if (context2 === this._context)
            return;
          this._context.off("update", this.onGraphicsContextUpdate, this);
          this._context = context2;
          this._context.on("update", this.onGraphicsContextUpdate, this);
          this.onGraphicsContextUpdate();
        }
        get context() {
          return this._context;
        }
        addBounds(bounds) {
          bounds.addBounds(this._context.bounds);
        }
        containsPoint(point) {
          return this._context.containsPoint(point);
        }
        onGraphicsContextUpdate() {
          this._didUpdate = true;
          this.owner.onViewUpdate();
        }
        destroy(options = false) {
          this.owner = null;
          const destroyContext = typeof options === "boolean" ? options : options?.context;
          if (destroyContext) {
            this._context.destroy(options);
          }
          this._context = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs
  var sampleValues, batchSamplersUniformGroup;
  var init_batchSamplersUniformGroup = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs"() {
      init_const3();
      init_UniformGroup();
      sampleValues = new Int32Array(MAX_TEXTURES);
      for (let i2 = 0; i2 < MAX_TEXTURES; i2++) {
        sampleValues[i2] = i2;
      }
      batchSamplersUniformGroup = new UniformGroup({
        uSamplers: { value: sampleValues, type: `u32`, size: MAX_TEXTURES }
      }, { isStatic: true });
    }
  });

  // node_modules/pixi-v8/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
  var localUniformMSDFBit;
  var init_localUniformMSDFBit = __esm({
    "node_modules/pixi-v8/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
      localUniformMSDFBit = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
          main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
          end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        },
        fragment: {
          header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
          main: ` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
  var mSDFBit, mSDFBitGl;
  var init_mSDFBit = __esm({
    "node_modules/pixi-v8/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
      mSDFBit = {
        name: "msdf-bit",
        fragment: {
          header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `
        }
      };
      mSDFBitGl = {
        name: "msdf-bit",
        fragment: {
          header: `
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }

            uniform float uDistance;
        `,
          main: `

            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/sdfShader/SdfShader.mjs
  var SdfShader;
  var init_SdfShader = __esm({
    "node_modules/pixi-v8/lib/scene/text/sdfShader/SdfShader.mjs"() {
      init_Matrix();
      init_const3();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_batchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      init_localUniformMSDFBit();
      init_mSDFBit();
      SdfShader = class extends Shader {
        constructor() {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uDistance: { value: 4, type: "f32" },
            uRound: { value: 0, type: "f32" }
          });
          const gpuProgram = compileHighShaderGpuProgram({
            name: "sdf-shader",
            bits: [
              colorBit,
              generateTextureBatchBit(MAX_TEXTURES),
              localUniformMSDFBit,
              mSDFBit,
              roundPixelsBit
            ]
          });
          const glProgram = compileHighShaderGlProgram({
            name: "sdf-shader",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(MAX_TEXTURES),
              localUniformBitGl,
              mSDFBitGl,
              roundPixelsBitGl
            ]
          });
          super({
            glProgram,
            gpuProgram,
            resources: {
              localUniforms: uniforms,
              batchSamplers: batchSamplersUniformGroup
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/utils/generateTextStyleKey.mjs
  function generateTextStyleKey(style) {
    const key = [];
    let index = 0;
    for (let i2 = 0; i2 < valuesToIterateForKeys.length; i2++) {
      const prop = valuesToIterateForKeys[i2];
      key[index++] = style[prop];
    }
    index = addFillStyleKey(style._fill, key, index);
    index = addStokeStyleKey(style._stroke, key, index);
    return key.join("-");
  }
  function addFillStyleKey(fillStyle, key, index) {
    if (!fillStyle)
      return index;
    key[index++] = fillStyle.color;
    key[index++] = fillStyle.alpha;
    key[index++] = fillStyle.fill?.uid;
    return index;
  }
  function addStokeStyleKey(strokeStyle, key, index) {
    if (!strokeStyle)
      return index;
    index = addFillStyleKey(strokeStyle, key, index);
    key[index++] = strokeStyle.width;
    key[index++] = strokeStyle.alignment;
    key[index++] = strokeStyle.cap;
    key[index++] = strokeStyle.join;
    key[index++] = strokeStyle.miterLimit;
    return index;
  }
  var valuesToIterateForKeys;
  var init_generateTextStyleKey = __esm({
    "node_modules/pixi-v8/lib/scene/text/utils/generateTextStyleKey.mjs"() {
      valuesToIterateForKeys = [
        "_fontFamily",
        "_fontStyle",
        "_fontVariant",
        "_fontWeight",
        "_breakWords",
        "_align",
        "_leading",
        "_letterSpacing",
        "_lineHeight",
        "_textBaseline",
        "_whiteSpace",
        "_wordWrap",
        "_wordWrapWidth",
        "_padding",
        "_cssOverrides"
      ];
    }
  });

  // node_modules/pixi-v8/lib/scene/text/TextStyle.mjs
  function convertV7Tov8Style(style) {
    const oldStyle = style;
    if (typeof oldStyle.dropShadow === "boolean") {
      deprecation(v8_0_0, "dropShadow is now an object, not a boolean");
      style.dropShadow = {
        alpha: oldStyle.dropShadowAlpha ?? 1,
        angle: oldStyle.dropShadowAngle,
        blur: oldStyle.dropShadowBlur ?? 0,
        color: oldStyle.dropShadowColor,
        distance: oldStyle.dropShadowDistance
      };
    }
    if (oldStyle.strokeThickness) {
      deprecation(v8_0_0, "strokeThickness is now a part of stroke");
      const color = oldStyle.stroke;
      style.stroke = {
        color,
        width: oldStyle.strokeThickness
      };
    }
    if (Array.isArray(oldStyle.fill)) {
      deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      const gradientFill = new FillGradient(0, 0, 0, style.fontSize * 1.7);
      const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());
      fills.forEach((number, index) => {
        const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;
        gradientFill.addColorStop(ratio, number);
      });
      style.fill = {
        fill: gradientFill
      };
    }
  }
  var _TextStyle, TextStyle;
  var init_TextStyle = __esm({
    "node_modules/pixi-v8/lib/scene/text/TextStyle.mjs"() {
      init_eventemitter3();
      init_Color();
      init_deprecation();
      init_FillGradient();
      init_GraphicsContext();
      init_convertFillInputToFillStyle();
      init_generateTextStyleKey();
      _TextStyle = class extends eventemitter3_default {
        constructor(style = {}) {
          super();
          convertV7Tov8Style(style);
          const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };
          for (const key in _TextStyle.defaultTextStyle) {
            const thisKey = key;
            this[thisKey] = fullStyle[key];
          }
          this.dropShadow = null;
          if (typeof fullStyle.fill === "string") {
            this.fontSize = parseInt(fullStyle.fontSize, 10);
          } else {
            this.fontSize = fullStyle.fontSize;
          }
          if (style.dropShadow) {
            if (style.dropShadow instanceof Boolean) {
              if (style.dropShadow === true) {
                this.dropShadow = {
                  ..._TextStyle.defaultTextStyle.dropShadow
                };
              }
            } else {
              this.dropShadow = {
                ..._TextStyle.defaultTextStyle.dropShadow,
                ...style.dropShadow
              };
            }
          }
          this.update();
        }
        get align() {
          return this._align;
        }
        set align(value) {
          this._align = value;
          this.update();
        }
        get breakWords() {
          return this._breakWords;
        }
        set breakWords(value) {
          this._breakWords = value;
          this.update();
        }
        get dropShadow() {
          return this._dropShadow;
        }
        set dropShadow(value) {
          this._dropShadow = value;
          this.update();
        }
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          this._fontFamily = value;
          this.update();
        }
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          this._fontSize = value;
          this.update();
        }
        get fontStyle() {
          return this._fontStyle;
        }
        set fontStyle(value) {
          this._fontStyle = value;
          this.update();
        }
        get fontVariant() {
          return this._fontVariant;
        }
        set fontVariant(value) {
          this._fontVariant = value;
          this.update();
        }
        get fontWeight() {
          return this._fontWeight;
        }
        set fontWeight(value) {
          this._fontWeight = value;
          this.update();
        }
        get leading() {
          return this._leading;
        }
        set leading(value) {
          this._leading = value;
          this.update();
        }
        get letterSpacing() {
          return this._letterSpacing;
        }
        set letterSpacing(value) {
          this._letterSpacing = value;
          this.update();
        }
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          this._lineHeight = value;
          this.update();
        }
        get padding() {
          return this._padding;
        }
        set padding(value) {
          this._padding = value;
          this.update();
        }
        get textBaseline() {
          return this._textBaseline;
        }
        set textBaseline(value) {
          this._textBaseline = value;
          this.update();
        }
        get whiteSpace() {
          return this._whiteSpace;
        }
        set whiteSpace(value) {
          this._whiteSpace = value;
          this.update();
        }
        get wordWrap() {
          return this._wordWrap;
        }
        set wordWrap(value) {
          this._wordWrap = value;
          this.update();
        }
        get wordWrapWidth() {
          return this._wordWrapWidth;
        }
        set wordWrapWidth(value) {
          this._wordWrapWidth = value;
          this.update();
        }
        get fill() {
          return this._originalFill;
        }
        set fill(value) {
          if (value === this._originalFill)
            return;
          this._originalFill = value;
          this._fill = convertFillInputToFillStyle(value, GraphicsContext.defaultFillStyle);
          this.update();
        }
        get stroke() {
          return this._originalStroke;
        }
        set stroke(value) {
          if (value === this._originalFill)
            return;
          this._originalFill = value;
          this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);
          this.update();
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this);
          return this._styleKey;
        }
        update() {
          this._styleKey = null;
          this.emit("update", this);
        }
        get styleKey() {
          return this._styleKey || this._generateKey();
        }
        clone() {
          return new _TextStyle({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth
          });
        }
        destroy(options = false) {
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fill?.texture) {
              this._fill.texture.destroy(destroyTextureSource);
            }
            if (this._originalFill?.texture) {
              this._originalFill.texture.destroy(destroyTextureSource);
            }
            if (this._stroke?.texture) {
              this._stroke.texture.destroy(destroyTextureSource);
            }
            if (this._originalStroke?.texture) {
              this._originalStroke.texture.destroy(destroyTextureSource);
            }
          }
          this._fill = null;
          this._stroke = null;
          this.dropShadow = null;
          this._originalStroke = null;
          this._originalFill = null;
        }
      };
      TextStyle = _TextStyle;
      TextStyle.defaultTextStyle = {
        align: "left",
        breakWords: false,
        dropShadow: {
          alpha: 1,
          angle: Math.PI / 6,
          blur: 0,
          color: "black",
          distance: 5
        },
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: false,
        whiteSpace: "pre",
        wordWrap: false,
        wordWrapWidth: 100
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/CanvasPool.mjs
  var CanvasPoolClass, CanvasPool;
  var init_CanvasPool = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
      init_pow2();
      init_settings();
      CanvasPoolClass = class {
        constructor(canvasOptions) {
          this._canvasPool = /* @__PURE__ */ Object.create(null);
          this.canvasOptions = canvasOptions || {};
          this.enableFullScreen = false;
        }
        _createCanvasAndContext(pixelWidth, pixelHeight) {
          const canvas2 = settings.ADAPTER.createCanvas();
          canvas2.width = pixelWidth;
          canvas2.height = pixelHeight;
          const context2 = canvas2.getContext("2d");
          return { canvas: canvas2, context: context2 };
        }
        getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
          minWidth = Math.ceil(minWidth * resolution - 1e-6);
          minHeight = Math.ceil(minHeight * resolution - 1e-6);
          minWidth = nextPow2(minWidth);
          minHeight = nextPow2(minHeight);
          const key = (minWidth << 17) + (minHeight << 1);
          if (!this._canvasPool[key]) {
            this._canvasPool[key] = [];
          }
          let canvasAndContext = this._canvasPool[key].pop();
          if (!canvasAndContext) {
            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
          }
          return canvasAndContext;
        }
        returnCanvasAndContext(canvasAndContext) {
          const { width, height } = canvasAndContext.canvas;
          const key = (width << 17) + (height << 1);
          this._canvasPool[key].push(canvasAndContext);
        }
        clear() {
          this._canvasPool = {};
        }
      };
      CanvasPool = new CanvasPoolClass();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
  function fontStringFromTextStyle(style) {
    const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
    let fontFamilies = style.fontFamily;
    if (!Array.isArray(style.fontFamily)) {
      fontFamilies = style.fontFamily.split(",");
    }
    for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      let fontFamily = fontFamilies[i2].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i2] = fontFamily;
    }
    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
  var genericFontFamilies;
  var init_fontStringFromTextStyle = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
      genericFontFamilies = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
      ];
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextMetrics.mjs
  var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
  var init_CanvasTextMetrics = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
      init_settings();
      init_fontStringFromTextStyle();
      contextSettings = {
        willReadFrequently: true
      };
      _CanvasTextMetrics = class {
        static get experimentalLetterSpacingSupported() {
          let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;
          if (result !== void 0) {
            const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
            result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
          }
          return result;
        }
        constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
          this.text = text;
          this.style = style;
          this.width = width;
          this.height = height;
          this.lines = lines;
          this.lineWidths = lineWidths;
          this.lineHeight = lineHeight;
          this.maxLineWidth = maxLineWidth;
          this.fontProperties = fontProperties;
        }
        static measureText(text = " ", style, canvas2 = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {
          const textKey = `${text}:${style.styleKey}`;
          if (_CanvasTextMetrics._measurementCache[textKey])
            return _CanvasTextMetrics._measurementCache[textKey];
          const font = fontStringFromTextStyle(style);
          const fontProperties = _CanvasTextMetrics.measureFont(font);
          if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
          }
          const context2 = _CanvasTextMetrics.__context;
          context2.font = font;
          const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas2) : text;
          const lines = outputText.split(/(?:\r\n|\r|\n)/);
          const lineWidths = new Array(lines.length);
          let maxLineWidth = 0;
          for (let i2 = 0; i2 < lines.length; i2++) {
            const lineWidth = _CanvasTextMetrics._measureText(lines[i2], style.letterSpacing, context2);
            lineWidths[i2] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
          }
          const strokeWidth = style._stroke?.width || 0;
          let width = maxLineWidth + strokeWidth;
          if (style.dropShadow) {
            width += style.dropShadow.distance;
          }
          const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;
          let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);
          if (style.dropShadow) {
            height += style.dropShadow.distance;
          }
          const measurements = new _CanvasTextMetrics(
            text,
            style,
            width,
            height,
            lines,
            lineWidths,
            lineHeight + style.leading,
            maxLineWidth,
            fontProperties
          );
          return measurements;
        }
        static _measureText(text, letterSpacing, context2) {
          let useExperimentalLetterSpacing = false;
          if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {
            if (_CanvasTextMetrics.experimentalLetterSpacing) {
              context2.letterSpacing = `${letterSpacing}px`;
              context2.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context2.letterSpacing = "0px";
              context2.textLetterSpacing = "0px";
            }
          }
          let width = context2.measureText(text).width;
          if (width > 0) {
            if (useExperimentalLetterSpacing) {
              width -= letterSpacing;
            } else {
              width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
            }
          }
          return width;
        }
        static _wordWrap(text, style, canvas2 = _CanvasTextMetrics._canvas) {
          const context2 = canvas2.getContext("2d", contextSettings);
          let width = 0;
          let line = "";
          let lines = "";
          const cache = /* @__PURE__ */ Object.create(null);
          const { letterSpacing, whiteSpace } = style;
          const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);
          const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);
          let canPrependSpaces = !collapseSpaces;
          const wordWrapWidth = style.wordWrapWidth + letterSpacing;
          const tokens = _CanvasTextMetrics._tokenize(text);
          for (let i2 = 0; i2 < tokens.length; i2++) {
            let token = tokens[i2];
            if (_CanvasTextMetrics._isNewline(token)) {
              if (!collapseNewlines) {
                lines += _CanvasTextMetrics._addLine(line);
                canPrependSpaces = !collapseSpaces;
                line = "";
                width = 0;
                continue;
              }
              token = " ";
            }
            if (collapseSpaces) {
              const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);
              const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);
              if (currIsBreakingSpace && lastIsBreakingSpace) {
                continue;
              }
            }
            const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context2);
            if (tokenWidth > wordWrapWidth) {
              if (line !== "") {
                lines += _CanvasTextMetrics._addLine(line);
                line = "";
                width = 0;
              }
              if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {
                const characters = _CanvasTextMetrics.wordWrapSplit(token);
                for (let j2 = 0; j2 < characters.length; j2++) {
                  let char = characters[j2];
                  let lastChar = char;
                  let k2 = 1;
                  while (characters[j2 + k2]) {
                    const nextChar = characters[j2 + k2];
                    if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                      char += nextChar;
                    } else {
                      break;
                    }
                    lastChar = nextChar;
                    k2++;
                  }
                  j2 += k2 - 1;
                  const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context2);
                  if (characterWidth + width > wordWrapWidth) {
                    lines += _CanvasTextMetrics._addLine(line);
                    canPrependSpaces = false;
                    line = "";
                    width = 0;
                  }
                  line += char;
                  width += characterWidth;
                }
              } else {
                if (line.length > 0) {
                  lines += _CanvasTextMetrics._addLine(line);
                  line = "";
                  width = 0;
                }
                const isLastToken = i2 === tokens.length - 1;
                lines += _CanvasTextMetrics._addLine(token, !isLastToken);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
            } else {
              if (tokenWidth + width > wordWrapWidth) {
                canPrependSpaces = false;
                lines += _CanvasTextMetrics._addLine(line);
                line = "";
                width = 0;
              }
              if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                line += token;
                width += tokenWidth;
              }
            }
          }
          lines += _CanvasTextMetrics._addLine(line, false);
          return lines;
        }
        static _addLine(line, newLine = true) {
          line = _CanvasTextMetrics._trimRight(line);
          line = newLine ? `${line}
` : line;
          return line;
        }
        static _getFromCache(key, letterSpacing, cache, context2) {
          let width = cache[key];
          if (typeof width !== "number") {
            width = _CanvasTextMetrics._measureText(key, letterSpacing, context2) + letterSpacing;
            cache[key] = width;
          }
          return width;
        }
        static _collapseSpaces(whiteSpace) {
          return whiteSpace === "normal" || whiteSpace === "pre-line";
        }
        static _collapseNewlines(whiteSpace) {
          return whiteSpace === "normal";
        }
        static _trimRight(text) {
          if (typeof text !== "string") {
            return "";
          }
          for (let i2 = text.length - 1; i2 >= 0; i2--) {
            const char = text[i2];
            if (!_CanvasTextMetrics.isBreakingSpace(char)) {
              break;
            }
            text = text.slice(0, -1);
          }
          return text;
        }
        static _isNewline(char) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));
        }
        static isBreakingSpace(char, _nextChar) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));
        }
        static _tokenize(text) {
          const tokens = [];
          let token = "";
          if (typeof text !== "string") {
            return tokens;
          }
          for (let i2 = 0; i2 < text.length; i2++) {
            const char = text[i2];
            const nextChar = text[i2 + 1];
            if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {
              if (token !== "") {
                tokens.push(token);
                token = "";
              }
              tokens.push(char);
              continue;
            }
            token += char;
          }
          if (token !== "") {
            tokens.push(token);
          }
          return tokens;
        }
        static canBreakWords(_token, breakWords) {
          return breakWords;
        }
        static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
          return true;
        }
        static wordWrapSplit(token) {
          return _CanvasTextMetrics.graphemeSegmenter(token);
        }
        static measureFont(font) {
          if (_CanvasTextMetrics._fonts[font]) {
            return _CanvasTextMetrics._fonts[font];
          }
          const context2 = _CanvasTextMetrics._context;
          context2.font = font;
          const metrics = context2.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);
          const properties = {
            ascent: metrics.actualBoundingBoxAscent,
            descent: metrics.actualBoundingBoxDescent,
            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
          };
          _CanvasTextMetrics._fonts[font] = properties;
          return properties;
        }
        static clearMetrics(font = "") {
          if (font) {
            delete _CanvasTextMetrics._fonts[font];
          } else {
            _CanvasTextMetrics._fonts = {};
          }
        }
        static get _canvas() {
          if (!_CanvasTextMetrics.__canvas) {
            let canvas2;
            try {
              const c2 = new OffscreenCanvas(0, 0);
              const context2 = c2.getContext("2d", contextSettings);
              if (context2?.measureText) {
                _CanvasTextMetrics.__canvas = c2;
                return c2;
              }
              canvas2 = settings.ADAPTER.createCanvas();
            } catch (ex) {
              canvas2 = settings.ADAPTER.createCanvas();
            }
            canvas2.width = canvas2.height = 10;
            _CanvasTextMetrics.__canvas = canvas2;
          }
          return _CanvasTextMetrics.__canvas;
        }
        static get _context() {
          if (!_CanvasTextMetrics.__context) {
            _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);
          }
          return _CanvasTextMetrics.__context;
        }
      };
      CanvasTextMetrics = _CanvasTextMetrics;
      CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
      CanvasTextMetrics.BASELINE_SYMBOL = "M";
      CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
      CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
      CanvasTextMetrics.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter === "function") {
          const segmenter = new Intl.Segmenter();
          return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
        }
        return (s2) => [...s2];
      })();
      CanvasTextMetrics.experimentalLetterSpacing = false;
      CanvasTextMetrics._fonts = {};
      CanvasTextMetrics._newlines = [
        10,
        13
      ];
      CanvasTextMetrics._breakingSpaces = [
        9,
        32,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8200,
        8201,
        8202,
        8287,
        12288
      ];
      CanvasTextMetrics._measurementCache = {};
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
  function getCanvasFillStyle(fillStyle, context2) {
    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
      return Color.shared.setValue(fillStyle.color).toHex();
    } else if (!fillStyle.fill) {
      const pattern = context2.createPattern(fillStyle.texture.source.resource, "repeat");
      const tempMatrix4 = fillStyle.matrix.copyTo(Matrix.shared);
      tempMatrix4.scale(fillStyle.texture.frameWidth, fillStyle.texture.frameHeight);
      pattern.setTransform(tempMatrix4);
      return pattern;
    } else if (fillStyle.fill instanceof FillPattern) {
      const fillPattern = fillStyle.fill;
      const pattern = context2.createPattern(fillPattern.texture.source.resource, "repeat");
      const tempMatrix4 = fillPattern.transform.copyTo(Matrix.shared);
      tempMatrix4.scale(fillPattern.texture.frameWidth, fillPattern.texture.frameHeight);
      pattern.setTransform(tempMatrix4);
      return pattern;
    } else if (fillStyle.fill instanceof FillGradient) {
      const fillGradient = fillStyle.fill;
      if (fillGradient.type === "linear") {
        const gradient = context2.createLinearGradient(
          fillGradient.x0,
          fillGradient.y0,
          fillGradient.x1,
          fillGradient.y1
        );
        fillGradient.gradientStops.forEach((stop) => {
          gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
        });
        return gradient;
      }
    }
    warn("FillStyle not recognised", fillStyle);
    return "red";
  }
  var init_getCanvasFillStyle = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_warn();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/utils/resolveCharacters.mjs
  function resolveCharacters(chars) {
    if (chars === "") {
      return [];
    }
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result = [];
    for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
      const item = chars[i2];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        }
        if (item[0].length === 0 || item[1].length === 0) {
          throw new Error("[BitmapFont]: Invalid character delimiter.");
        }
        const startCode = item[0].charCodeAt(0);
        const endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
          result.push(String.fromCharCode(i22));
        }
      } else {
        result.push(...Array.from(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }
  var init_resolveCharacters = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/utils/resolveCharacters.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/DynamicBitmapFont.mjs
  var DynamicBitmapFont;
  var init_DynamicBitmapFont = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/DynamicBitmapFont.mjs"() {
      init_Color();
      init_Rectangle();
      init_CanvasPool();
      init_ImageSource();
      init_Texture();
      init_deprecation();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      init_AbstractBitmapFont();
      init_resolveCharacters();
      DynamicBitmapFont = class extends AbstractBitmapFont {
        constructor(options) {
          super();
          this.resolution = 1;
          this.pages = [];
          this._padding = 4;
          this._measureCache = /* @__PURE__ */ Object.create(null);
          this._currentChars = [];
          this._currentX = 0;
          this._currentY = 0;
          this._currentPageIndex = -1;
          this._skipKerning = false;
          const dynamicOptions = options;
          const style = dynamicOptions.style.clone();
          style.fontSize = this.baseMeasurementFontSize;
          if (dynamicOptions.overrideFill) {
            style._fill.color = 16777215;
            style._fill.alpha = 1;
            style._fill.texture = Texture.WHITE;
            style._fill.fill = null;
          }
          this._style = style;
          this._skipKerning = dynamicOptions.skipKerning ?? false;
          this.resolution = dynamicOptions.resolution ?? 1;
          this._padding = dynamicOptions.padding ?? 4;
          const font = fontStringFromTextStyle(style);
          const writable = this;
          writable.fontMetrics = CanvasTextMetrics.measureFont(font);
          writable.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
        }
        ensureCharacters(chars) {
          const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);
          if (!charList.length)
            return;
          this._currentChars = [...this._currentChars, ...charList];
          let pageData;
          if (this._currentPageIndex === -1) {
            pageData = this._nextPage();
          } else {
            pageData = this.pages[this._currentPageIndex];
          }
          let { canvas: canvas2, context: context2 } = pageData.canvasAndContext;
          let textureSource = pageData.texture.source;
          const style = this._style;
          let currentX = this._currentX;
          let currentY = this._currentY;
          const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
          const padding = this._padding * fontScale;
          const widthScale = style.fontStyle === "italic" ? 2 : 1;
          let maxCharHeight = 0;
          let skipTexture = false;
          for (let i2 = 0; i2 < charList.length; i2++) {
            const char = charList[i2];
            const metrics = CanvasTextMetrics.measureText(char, style, canvas2, false);
            const width = widthScale * metrics.width * fontScale;
            const height = metrics.height * fontScale;
            const paddedWidth = width + padding * 2;
            const paddedHeight = height + padding * 2;
            skipTexture = false;
            if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
              skipTexture = true;
              maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
            }
            if (currentX + paddedWidth > 512) {
              currentY += maxCharHeight;
              maxCharHeight = paddedHeight;
              currentX = 0;
              if (currentY + maxCharHeight > 512) {
                textureSource.update();
                const pageData2 = this._nextPage();
                canvas2 = pageData2.canvasAndContext.canvas;
                context2 = pageData2.canvasAndContext.context;
                textureSource = pageData2.texture.source;
                currentY = 0;
              }
            }
            const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
            this.chars[char] = {
              id: char.codePointAt(0),
              xOffset: -this._padding,
              yOffset: -this._padding,
              xAdvance,
              kerning: {}
            };
            if (skipTexture) {
              this._drawGlyph(
                context2,
                metrics,
                currentX + padding,
                currentY + padding,
                fontScale,
                style
              );
              const px = textureSource.width * fontScale;
              const py = textureSource.height * fontScale;
              const frame = new Rectangle(
                currentX / px,
                currentY / py,
                paddedWidth / px,
                paddedHeight / py
              );
              this.chars[char].texture = new Texture({
                source: textureSource,
                layout: {
                  frame
                }
              });
              currentX += Math.ceil(paddedWidth);
            }
          }
          textureSource.update();
          this._currentX = currentX;
          this._currentY = currentY;
          this._skipKerning && this._applyKerning(charList, context2);
        }
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        _applyKerning(newChars, context2) {
          const measureCache = this._measureCache;
          for (let i2 = 0; i2 < newChars.length; i2++) {
            const first = newChars[i2];
            for (let j2 = 0; j2 < this._currentChars.length; j2++) {
              const second = this._currentChars[j2];
              let c1 = measureCache[first];
              if (!c1)
                c1 = measureCache[first] = context2.measureText(first).width;
              let c2 = measureCache[second];
              if (!c2)
                c2 = measureCache[second] = context2.measureText(second).width;
              let total = context2.measureText(first + second).width;
              let amount = total - (c1 + c2);
              if (amount) {
                this.chars[first].kerning[second] = amount;
              }
              total = context2.measureText(first + second).width;
              amount = total - (c1 + c2);
              if (amount) {
                this.chars[second].kerning[first] = amount;
              }
            }
          }
        }
        _nextPage() {
          this._currentPageIndex++;
          const textureResolution = this.resolution;
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);
          this._setupContext(canvasAndContext.context, this._style, textureResolution);
          const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
          const texture = new Texture({
            source: new ImageSource({
              resource: canvasAndContext.canvas,
              resolution,
              alphaMode: "premultiply-alpha-on-upload"
            })
          });
          const pageData = {
            canvasAndContext,
            texture
          };
          this.pages[this._currentPageIndex] = pageData;
          return pageData;
        }
        _setupContext(context2, style, resolution) {
          style.fontSize = this.baseRenderedFontSize;
          context2.scale(resolution, resolution);
          context2.font = fontStringFromTextStyle(style);
          style.fontSize = this.baseMeasurementFontSize;
          context2.textBaseline = style.textBaseline;
          const stroke = style._stroke;
          const strokeThickness = stroke?.width ?? 0;
          if (stroke) {
            context2.lineWidth = strokeThickness;
            context2.lineJoin = stroke.join;
            context2.miterLimit = stroke.miterLimit;
            context2.strokeStyle = getCanvasFillStyle(stroke, context2);
          }
          if (style._fill) {
            context2.fillStyle = getCanvasFillStyle(style._fill, context2);
          }
          if (style.dropShadow) {
            const shadowOptions = style.dropShadow;
            const rgb = Color.shared.setValue(shadowOptions.color).toArray();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context2.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
            context2.shadowBlur = dropShadowBlur;
            context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
          } else {
            context2.shadowColor = "black";
            context2.shadowBlur = 0;
            context2.shadowOffsetX = 0;
            context2.shadowOffsetY = 0;
          }
        }
        _drawGlyph(context2, metrics, x2, y2, fontScale, style) {
          const char = metrics.text;
          const fontProperties = metrics.fontProperties;
          const stroke = style._stroke;
          const strokeThickness = (stroke?.width ?? 0) * fontScale;
          const tx = x2 + strokeThickness / 2;
          const ty = y2 - strokeThickness / 2;
          const descent = fontProperties.descent * fontScale;
          const lineHeight = metrics.lineHeight * fontScale;
          if (style.stroke && strokeThickness) {
            context2.strokeText(char, tx, ty + lineHeight - descent);
          }
          if (style._fill) {
            context2.fillText(char, tx, ty + lineHeight - descent);
          }
        }
        destroy() {
          super.destroy();
          for (let i2 = 0; i2 < this.pages.length; i2++) {
            const { canvasAndContext, texture } = this.pages[i2];
            CanvasPool.returnCanvasAndContext(canvasAndContext);
            texture.destroy(true);
          }
          this.pages = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/utils/getBitmapTextLayout.mjs
  function getBitmapTextLayout(chars, style, font) {
    const layoutData = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: style.fontSize / font.baseMeasurementFontSize,
      lines: [{
        width: 0,
        charPositions: [],
        spaceWidth: 0,
        spacesIndex: [],
        chars: []
      }]
    };
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    let previousChar = null;
    let firstWord = true;
    const currentWord = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      positions: [],
      chars: []
    };
    const nextWord = (word) => {
      const start = currentLine.width;
      for (let j2 = 0; j2 < currentWord.index; j2++) {
        const position = word.positions[j2];
        currentLine.chars.push(word.chars[j2]);
        currentLine.charPositions.push(position + start);
      }
      currentLine.width += word.width;
      firstWord = false;
      currentWord.width = 0;
      currentWord.index = 0;
      currentWord.chars.length = 0;
    };
    const nextLine = () => {
      let index = currentLine.chars.length - 1;
      let lastChar = currentLine.chars[index];
      while (lastChar === " ") {
        currentLine.width -= font.chars[lastChar].xAdvance;
        lastChar = currentLine.chars[--index];
      }
      layoutData.width = Math.max(layoutData.width, currentLine.width);
      currentLine = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      };
      firstWord = true;
      layoutData.lines.push(currentLine);
      layoutData.height += font.lineHeight;
    };
    const scale = font.baseMeasurementFontSize / style.fontSize;
    const adjustedLetterSpacing = style.letterSpacing * scale;
    const adjustedWordWrapWidth = style.wordWrapWidth * scale;
    for (let i2 = 0; i2 < chars.length + 1; i2++) {
      let char;
      const isEnd = i2 === chars.length;
      if (!isEnd) {
        char = chars[i2];
      }
      const charData = font.chars[char];
      const isSpace = /(?:\s)/.test(char);
      const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
      if (isWordBreak) {
        const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
        if (addWordToNextLine) {
          nextLine();
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        } else {
          currentWord.start = currentLine.width;
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        }
        if (char === "\r" || char === "\n") {
          if (currentLine.width !== 0) {
            nextLine();
          }
        } else if (!isEnd) {
          const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
          currentLine.width += spaceWidth;
          currentLine.spaceWidth = spaceWidth;
          currentLine.spacesIndex.push(currentLine.charPositions.length);
          currentLine.chars.push(char);
        }
      } else {
        const kerning = charData.kerning[previousChar] || 0;
        const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
        currentWord.positions[currentWord.index++] = currentWord.width + kerning;
        currentWord.chars.push(char);
        currentWord.width += nextCharWidth;
      }
      previousChar = char;
    }
    nextLine();
    if (style.align === "center") {
      alignCenter(layoutData);
    } else if (style.align === "right") {
      alignRight(layoutData);
    } else if (style.align === "justify") {
      alignJustify(layoutData);
    }
    return layoutData;
  }
  function alignCenter(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width / 2 - line.width / 2;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignRight(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width - line.width;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignJustify(measurementData) {
    const width = measurementData.width;
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      let indy = 0;
      let spaceIndex = line.spacesIndex[indy++];
      let offset = 0;
      const totalSpaces = line.spacesIndex.length;
      const newSpaceWidth = (width - line.width) / totalSpaces;
      const spaceWidth = newSpaceWidth;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        if (j2 === spaceIndex) {
          spaceIndex = line.spacesIndex[indy++];
          offset += spaceWidth;
        }
        line.charPositions[j2] += offset;
      }
    }
  }
  var init_getBitmapTextLayout = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/utils/getBitmapTextLayout.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/BitmapFontManager.mjs
  var BitmapFontManagerClass, BitmapFontManager;
  var init_BitmapFontManager = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/BitmapFontManager.mjs"() {
      init_Cache();
      init_TextStyle();
      init_DynamicBitmapFont();
      init_getBitmapTextLayout();
      init_resolveCharacters();
      BitmapFontManagerClass = class {
        constructor() {
          this.ALPHA = [["a", "z"], ["A", "Z"], " "];
          this.NUMERIC = [["0", "9"]];
          this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
          this.ASCII = [[" ", "~"]];
          this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: false
          };
        }
        getFont(text, style) {
          let fontFamilyKey = style.fontFamily;
          let overrideFill = true;
          if (style._fill.fill) {
            fontFamilyKey += style._fill.fill.uid;
            overrideFill = false;
          }
          if (!Cache.has(fontFamilyKey)) {
            Cache.set(
              fontFamilyKey,
              new DynamicBitmapFont({
                style,
                overrideFill,
                ...this.defaultOptions
              })
            );
          }
          const dynamicFont = Cache.get(fontFamilyKey);
          dynamicFont.ensureCharacters?.(text);
          return dynamicFont;
        }
        getLayout(text, style) {
          const bitmapFont = this.getFont(text, style);
          return getBitmapTextLayout(text.split(""), style, bitmapFont);
        }
        measureText(text, style) {
          return this.getLayout(text, style);
        }
        install(name, textStyle, options) {
          if (!name) {
            throw new Error("[BitmapFontManager] Property `name` is required.");
          }
          options = { ...this.defaultOptions, ...options };
          const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
          const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
          const font = new DynamicBitmapFont({
            style,
            overrideFill,
            skipKerning: options.skipKerning,
            padding: options.padding,
            resolution: options.resolution
          });
          const flatChars = resolveCharacters(options.chars);
          font.ensureCharacters(flatChars.join(""));
          Cache.set(name, font);
          return font;
        }
      };
      BitmapFontManager = new BitmapFontManagerClass();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/bitmap/BitmapTextPipe.mjs
  var GraphicsProxyRenderable, BitmapTextPipe;
  var init_BitmapTextPipe = __esm({
    "node_modules/pixi-v8/lib/scene/text/bitmap/BitmapTextPipe.mjs"() {
      init_Cache();
      init_Extensions();
      init_ProxyRenderable();
      init_PoolGroup();
      init_GraphicsView();
      init_SdfShader();
      init_BitmapFontManager();
      init_getBitmapTextLayout();
      GraphicsProxyRenderable = class extends ProxyRenderable {
        constructor() {
          super({
            view: new GraphicsView()
          });
        }
      };
      BitmapTextPipe = class {
        constructor(renderer) {
          this._gpuBitmapText = {};
          this._renderer = renderer;
        }
        validateRenderable(renderable) {
          const graphicsRenderable = this._getGpuBitmapText(renderable);
          if (renderable.view._didUpdate) {
            renderable.view._didUpdate = false;
            this._updateContext(renderable, graphicsRenderable.view.context);
          }
          const rebuild = this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
          return rebuild;
        }
        addRenderable(renderable, instructionSet) {
          const graphicsRenderable = this._getGpuBitmapText(renderable);
          if (renderable.view._didUpdate) {
            renderable.view._didUpdate = false;
            this._updateContext(renderable, graphicsRenderable.view.context);
          }
          this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
          if (graphicsRenderable.view.context.customShader) {
            this._updateDistanceField(renderable);
          }
        }
        destroyRenderable(renderable) {
          this._destroyRenderableByUid(renderable.uid);
        }
        _destroyRenderableByUid(renderableUid) {
          BigPool.return(this._gpuBitmapText[renderableUid]);
          this._gpuBitmapText[renderableUid] = null;
        }
        updateRenderable(renderable) {
          const graphicsRenderable = this._getGpuBitmapText(renderable);
          this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
          if (graphicsRenderable.view.context.customShader) {
            this._updateDistanceField(renderable);
          }
        }
        _updateContext(renderable, context2) {
          const view = renderable.view;
          const bitmapFont = BitmapFontManager.getFont(view.text, view._style);
          context2.clear();
          if (bitmapFont.distanceField.type !== "none") {
            if (!context2.customShader) {
              if (!this._sdfShader) {
                this._sdfShader = new SdfShader();
              }
              context2.customShader = this._sdfShader;
            }
          }
          const chars = Array.from(view.text);
          const style = view._style;
          let currentY = (style._stroke?.width || 0) / 2;
          currentY += bitmapFont.baseLineOffset;
          const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);
          let index = 0;
          const padding = style.padding;
          const scale = bitmapTextLayout.scale;
          context2.translate(
            -view.anchor._x * bitmapTextLayout.width - padding,
            -view.anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding
          ).scale(scale, scale);
          const tint = style._fill.color;
          for (let i2 = 0; i2 < bitmapTextLayout.lines.length; i2++) {
            const line = bitmapTextLayout.lines[i2];
            for (let j2 = 0; j2 < line.charPositions.length; j2++) {
              const char = chars[index++];
              const charData = bitmapFont.chars[char];
              if (charData?.texture) {
                context2.texture(
                  charData.texture,
                  tint,
                  Math.round(line.charPositions[j2] + charData.xOffset),
                  Math.round(currentY + charData.yOffset)
                );
              }
            }
            currentY += bitmapFont.lineHeight;
          }
        }
        _getGpuBitmapText(renderable) {
          return this._gpuBitmapText[renderable.uid] || this._initGpuText(renderable);
        }
        _initGpuText(renderable) {
          renderable.view._style.update();
          const proxyRenderable = BigPool.get(GraphicsProxyRenderable, renderable);
          this._gpuBitmapText[renderable.uid] = proxyRenderable;
          proxyRenderable.view.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
          this._updateContext(renderable, proxyRenderable.view.context);
          renderable.on("destroyed", () => {
            this.destroyRenderable(renderable);
          });
          return this._gpuBitmapText[renderable.uid];
        }
        _updateDistanceField(renderable) {
          const context2 = this._getGpuBitmapText(renderable).view.context;
          const view = renderable.view;
          const fontFamily = view._style.fontFamily;
          const dynamicFont = Cache.get(fontFamily);
          const { a: a2, b: b2, c: c2, d: d2 } = renderable.layerTransform;
          const dx = Math.sqrt(a2 * a2 + b2 * b2);
          const dy = Math.sqrt(c2 * c2 + d2 * d2);
          const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
          const fontScale = dynamicFont.baseRenderedFontSize / view._style.fontSize;
          const resolution = view.resolution ?? this._renderer.resolution;
          const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;
          context2.customShader.resources.localUniforms.uniforms.uDistance = distance;
        }
        destroy() {
          for (const uid2 in this._gpuBitmapText) {
            this._destroyRenderableByUid(uid2);
          }
          this._gpuBitmapText = null;
          this._sdfShader?.destroy(true);
          this._sdfShader = null;
          this._renderer = null;
        }
      };
      BitmapTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "bitmapText"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextPipe.mjs
  var CanvasTextPipe;
  var init_CanvasTextPipe = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_updateQuadBounds();
      init_BatchableSprite();
      CanvasTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        validateRenderable(renderable) {
          const gpuText = this._getGpuText(renderable);
          const newKey = renderable.view._getKey();
          if (gpuText.currentKey !== newKey) {
            const view = renderable.view;
            const resolution = view.resolution ?? this._renderer.resolution;
            const { width, height } = this._renderer.canvasText.getTextureSize(
              view.text,
              resolution,
              view._style
            );
            if (this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height) {
              return false;
            }
            return true;
          }
          return false;
        }
        addRenderable(renderable, _instructionSet) {
          const gpuText = this._getGpuText(renderable);
          const batchableSprite = gpuText.batchableSprite;
          if (renderable.view._didUpdate) {
            this._updateText(renderable);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite);
        }
        updateRenderable(renderable) {
          const gpuText = this._getGpuText(renderable);
          const batchableSprite = gpuText.batchableSprite;
          if (renderable.view._didUpdate) {
            this._updateText(renderable);
          }
          batchableSprite.batcher.updateElement(batchableSprite);
        }
        destroyRenderable(renderable) {
          this._destroyRenderableById(renderable.uid);
        }
        _destroyRenderableById(renderableUid) {
          const gpuText = this._gpuText[renderableUid];
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[renderableUid] = null;
        }
        _updateText(renderable) {
          const newKey = renderable.view._getKey();
          const gpuText = this._getGpuText(renderable);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(renderable);
          }
          renderable.view._didUpdate = false;
          const padding = renderable.view._style.padding;
          updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
        }
        _updateGpuText(renderable) {
          const gpuText = this._getGpuText(renderable);
          const batchableSprite = gpuText.batchableSprite;
          const view = renderable.view;
          if (gpuText.texture) {
            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          }
          const resolution = view.resolution ?? this._renderer.resolution;
          gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(
            view.text,
            resolution,
            view._style,
            view._getKey()
          );
          gpuText.currentKey = view._getKey();
          batchableSprite.texture = gpuText.texture;
        }
        _getGpuText(renderable) {
          return this._gpuText[renderable.uid] || this._initGpuText(renderable);
        }
        _initGpuText(renderable) {
          const view = renderable.view;
          view._style.update();
          const gpuTextData = {
            texture: null,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite)
          };
          gpuTextData.batchableSprite.renderable = renderable;
          gpuTextData.batchableSprite.bounds = [0, 1, 0, 0];
          gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
          this._gpuText[renderable.uid] = gpuTextData;
          this._updateText(renderable);
          renderable.on("destroyed", () => {
            this.destroyRenderable(renderable);
          });
          return gpuTextData;
        }
        destroy() {
          for (const i2 in this._gpuText) {
            this._destroyRenderableById(i2);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      CanvasTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "text"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/getPo2TextureFromSource.mjs
  function getPo2TextureFromSource(image, width, height, resolution) {
    const bounds = tempBounds3;
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = image.width / resolution | 0;
    bounds.maxY = image.height / resolution | 0;
    const texture = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      resolution,
      false
    );
    texture.source.uploadMethodId = "image";
    texture.source.resource = image;
    texture.source.alphaMode = "premultiply-alpha-on-upload";
    texture.frameWidth = width / resolution;
    texture.frameHeight = height / resolution;
    texture.source.update();
    texture.layout.updateUvs();
    return texture;
  }
  var tempBounds3;
  var init_getPo2TextureFromSource = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/getPo2TextureFromSource.mjs"() {
      init_TexturePool();
      init_Bounds();
      tempBounds3 = new Bounds();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextSystem.mjs
  var CanvasTextSystem;
  var init_CanvasTextSystem = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_pow2();
      init_CanvasPool();
      init_TexturePool();
      init_getPo2TextureFromSource();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      CanvasTextSystem = class {
        constructor() {
          this._activeTextures = {};
        }
        getTextureSize(text, resolution, style) {
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          width = Math.ceil(width - 1e-6);
          height = Math.ceil(height - 1e-6);
          width = nextPow2(width);
          height = nextPow2(height);
          return { width, height };
        }
        getTexture(text, resolution, style, textKey) {
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].texture;
          }
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
          const { canvas: canvas2 } = canvasAndContext;
          this.renderTextToCanvas(text, style, resolution, canvasAndContext);
          const texture = getPo2TextureFromSource(canvas2, width, height, resolution);
          this._activeTextures[textKey] = {
            canvasAndContext,
            texture,
            usageCount: 1
          };
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
            TexturePool.returnTexture(activeTexture.texture);
            const source2 = activeTexture.texture.source;
            source2.resource = null;
            source2.uploadMethodId = "unknown";
            source2.alphaMode = "no-premultiply-alpha";
            this._activeTextures[textKey] = null;
          }
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        renderTextToCanvas(text, style, resolution, canvasAndContext) {
          const { canvas: canvas2, context: context2 } = canvasAndContext;
          const font = fontStringFromTextStyle(style);
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          const lines = measured.lines;
          const lineHeight = measured.lineHeight;
          const lineWidths = measured.lineWidths;
          const maxLineWidth = measured.maxLineWidth;
          const fontProperties = measured.fontProperties;
          const height = canvas2.height;
          context2.resetTransform();
          context2.scale(resolution, resolution);
          context2.clearRect(0, 0, measured.width + 4, measured.height + 4);
          if (style._stroke?.width) {
            const strokeStyle = style._stroke;
            context2.lineWidth = strokeStyle.width;
            context2.miterLimit = strokeStyle.miterLimit;
            context2.lineJoin = strokeStyle.join;
            context2.lineCap = strokeStyle.cap;
          }
          context2.font = font;
          let linePositionX;
          let linePositionY;
          const passesCount = style.dropShadow ? 2 : 1;
          for (let i2 = 0; i2 < passesCount; ++i2) {
            const isShadowPass = style.dropShadow && i2 === 0;
            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
            const dsOffsetShadow = dsOffsetText * resolution;
            if (isShadowPass) {
              context2.fillStyle = "black";
              context2.strokeStyle = "black";
              const shadowOptions = style.dropShadow;
              const dropShadowColor = shadowOptions.color;
              const dropShadowAlpha = shadowOptions.alpha;
              context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
              const dropShadowBlur = shadowOptions.blur * resolution;
              const dropShadowDistance = shadowOptions.distance * resolution;
              context2.shadowBlur = dropShadowBlur;
              context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
              context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
            } else {
              context2.globalAlpha = style._fill?.alpha ?? 1;
              context2.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context2) : null;
              if (style._stroke?.width) {
                context2.strokeStyle = getCanvasFillStyle(style._stroke, context2);
              }
              context2.shadowColor = "black";
            }
            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
            if (lineHeight - fontProperties.fontSize < 0) {
              linePositionYShift = 0;
            }
            const strokeWidth = style._stroke?.width ?? 0;
            for (let i22 = 0; i22 < lines.length; i22++) {
              linePositionX = strokeWidth / 2;
              linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
              if (style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i22];
              } else if (style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
              }
              if (style._stroke) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + style.padding,
                  linePositionY + style.padding - dsOffsetText,
                  true
                );
              }
              if (style._fill !== void 0) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + style.padding,
                  linePositionY + style.padding - dsOffsetText
                );
              }
            }
          }
        }
        _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
          const { context: context2 } = canvasAndContext;
          const letterSpacing = style.letterSpacing;
          let useExperimentalLetterSpacing = false;
          if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
            if (CanvasTextMetrics.experimentalLetterSpacing) {
              context2.letterSpacing = `${letterSpacing}px`;
              context2.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context2.letterSpacing = "0px";
              context2.textLetterSpacing = "0px";
            }
          }
          if (letterSpacing === 0 || useExperimentalLetterSpacing) {
            if (isStroke) {
              context2.strokeText(text, x2, y2);
            } else {
              context2.fillText(text, x2, y2);
            }
            return;
          }
          let currentPosition = x2;
          const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
          let previousWidth = context2.measureText(text).width;
          let currentWidth = 0;
          for (let i2 = 0; i2 < stringArray.length; ++i2) {
            const currentChar = stringArray[i2];
            if (isStroke) {
              context2.strokeText(currentChar, currentPosition, y2);
            } else {
              context2.fillText(currentChar, currentPosition, y2);
            }
            let textStr = "";
            for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
              textStr += stringArray[j2];
            }
            currentWidth = context2.measureText(textStr).width;
            currentPosition += previousWidth - currentWidth + letterSpacing;
            previousWidth = currentWidth;
          }
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      CanvasTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "canvasText"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/HTMLTextPipe.mjs
  var HTMLTextPipe;
  var init_HTMLTextPipe = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/HTMLTextPipe.mjs"() {
      init_Extensions();
      init_Texture();
      init_PoolGroup();
      init_updateQuadBounds();
      init_BatchableSprite();
      HTMLTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        validateRenderable(renderable) {
          const gpuText = this._getGpuText(renderable);
          const newKey = renderable.view._getKey();
          if (gpuText.textureNeedsUploading) {
            gpuText.textureNeedsUploading = false;
            return true;
          }
          if (gpuText.currentKey !== newKey) {
            return true;
          }
          return false;
        }
        addRenderable(renderable) {
          const gpuText = this._getGpuText(renderable);
          const batchableSprite = gpuText.batchableSprite;
          if (renderable.view._didUpdate) {
            this._updateText(renderable);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite);
        }
        updateRenderable(renderable) {
          const gpuText = this._getGpuText(renderable);
          const batchableSprite = gpuText.batchableSprite;
          if (renderable.view._didUpdate) {
            this._updateText(renderable);
          }
          batchableSprite.batcher.updateElement(batchableSprite);
        }
        destroyRenderable(renderable) {
          this._destroyRenderableById(renderable.uid);
        }
        _destroyRenderableById(renderableUid) {
          const gpuText = this._gpuText[renderableUid];
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[renderableUid] = null;
        }
        _updateText(renderable) {
          const newKey = renderable.view._getKey();
          const gpuText = this._getGpuText(renderable);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(renderable).catch((e2) => {
              console.error(e2);
            });
          }
          renderable.view._didUpdate = false;
          const padding = renderable.view._style.padding;
          updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
        }
        async _updateGpuText(renderable) {
          renderable.view._didUpdate = false;
          const gpuText = this._getGpuText(renderable);
          if (gpuText.generatingTexture)
            return;
          const newKey = renderable.view._getKey();
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          gpuText.generatingTexture = true;
          gpuText.currentKey = newKey;
          const view = renderable.view;
          const resolution = view.resolution ?? this._renderer.resolution;
          const texture = await this._renderer.htmlText.getManagedTexture(
            view.text,
            resolution,
            view._style,
            view._getKey()
          );
          const batchableSprite = gpuText.batchableSprite;
          batchableSprite.texture = gpuText.texture = texture;
          gpuText.generatingTexture = false;
          gpuText.textureNeedsUploading = true;
          renderable.view.onUpdate();
          const padding = renderable.view._style.padding;
          updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
        }
        _getGpuText(renderable) {
          return this._gpuText[renderable.uid] || this._initGpuText(renderable);
        }
        _initGpuText(renderable) {
          const view = renderable.view;
          view._style.update();
          const gpuTextData = {
            texture: Texture.EMPTY,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite),
            textureNeedsUploading: false,
            generatingTexture: false
          };
          const batchableSprite = gpuTextData.batchableSprite;
          batchableSprite.renderable = renderable;
          batchableSprite.texture = Texture.EMPTY;
          batchableSprite.bounds = [0, 1, 0, 0];
          batchableSprite.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
          this._gpuText[renderable.uid] = gpuTextData;
          renderable.on("destroyed", () => {
            this.destroyRenderable(renderable);
          });
          return gpuTextData;
        }
        destroy() {
          for (const i2 in this._gpuText) {
            this._destroyRenderableById(i2);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      HTMLTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "htmlText"
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/isSafari.mjs
  function isSafari() {
    const { userAgent } = settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  var init_isSafari = __esm({
    "node_modules/pixi-v8/lib/utils/isSafari.mjs"() {
      init_settings();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/extractFontFamilies.mjs
  function extractFontFamilies(text, fontFamily) {
    const regex = /font-family:([^;"\s]+)/g;
    const matches = text.match(regex);
    const fontFamilies = [fontFamily];
    const dedupe = {};
    dedupe[fontFamily] = true;
    if (matches) {
      matches.forEach((match) => {
        const fontFamily2 = match.split(":")[1].trim();
        if (!dedupe[fontFamily2]) {
          fontFamilies.push(fontFamily2);
          dedupe[fontFamily2] = true;
        }
      });
    }
    return fontFamilies;
  }
  var init_extractFontFamilies = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/extractFontFamilies.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/loadFontAsBase64.mjs
  async function loadFontAsBase64(url) {
    const response = await settings.ADAPTER.fetch(url);
    const blob = await response.blob();
    const reader = new FileReader();
    const dataSrc = await new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    return dataSrc;
  }
  var init_loadFontAsBase64 = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/loadFontAsBase64.mjs"() {
      init_settings();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/loadFontCSS.mjs
  async function loadFontCSS(style, url) {
    const dataSrc = await loadFontAsBase64(url);
    return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
  }
  var init_loadFontCSS = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/loadFontCSS.mjs"() {
      init_loadFontAsBase64();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/getFontCss.mjs
  async function getFontCss(fontFamilies, style) {
    const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(fontFamily)).map((fontFamily, i2) => {
      if (!FontStylePromiseCache.has(fontFamily)) {
        const { url } = Cache.get(fontFamily);
        if (i2 === 0) {
          FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));
        } else {
          FontStylePromiseCache.set(fontFamily, loadFontCSS({
            ...HTMLTextSystem.defaultFontOptions,
            fontFamily
          }, url));
        }
      }
      return FontStylePromiseCache.get(fontFamily);
    });
    return (await Promise.all(fontPromises)).join("\n");
  }
  var init_getFontCss = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/getFontCss.mjs"() {
      init_Cache();
      init_HTMLTextSystem();
      init_loadFontCSS();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/getSVGUrl.mjs
  function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
    const { domElement, styleElement, svgRoot } = htmlTextData;
    domElement.innerHTML = text;
    domElement.setAttribute("style", `transform: scale(${resolution});
${style.cssStyle}`);
    styleElement.textContent = fontCSS;
    const { width, height } = htmlTextData.image;
    svgRoot.setAttribute("width", width.toString());
    svgRoot.setAttribute("height", height.toString());
    return new XMLSerializer().serializeToString(svgRoot);
  }
  var init_getSVGUrl = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/getSVGUrl.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/getTemporaryCanvasFromImage.mjs
  function getTemporaryCanvasFromImage(image, resolution) {
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
      image.width,
      image.height,
      resolution
    );
    const { context: context2 } = canvasAndContext;
    context2.clearRect(0, 0, image.width, image.height);
    context2.drawImage(image, 0, 0);
    CanvasPool.returnCanvasAndContext(canvasAndContext);
    return canvasAndContext.canvas;
  }
  var init_getTemporaryCanvasFromImage = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/getTemporaryCanvasFromImage.mjs"() {
      init_CanvasPool();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/loadSVGImage.mjs
  function loadSVGImage(image, url, delay) {
    return new Promise(async (resolve) => {
      if (delay) {
        await new Promise((resolve2) => setTimeout(resolve2, 100));
      }
      image.onload = () => {
        resolve();
      };
      image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
      image.crossOrigin = "anonymous";
    });
  }
  var init_loadSVGImage = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/loadSVGImage.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/measureHtmlText..mjs
  function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());
    const { domElement, styleElement, svgRoot } = htmlTextRenderData;
    domElement.innerHTML = text;
    domElement.setAttribute("style", style.cssStyle);
    if (fontStyleCSS) {
      styleElement.textContent = fontStyleCSS;
    }
    document.body.appendChild(svgRoot);
    const contentBounds = domElement.getBoundingClientRect();
    svgRoot.remove();
    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;
    return {
      width: contentBounds.width,
      height: contentBounds.height + descenderPadding
    };
  }
  var tempHTMLTextRenderData;
  var init_measureHtmlText = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/measureHtmlText..mjs"() {
      init_CanvasTextMetrics();
      init_HTMLTextSystem();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/HTMLTextSystem.mjs
  var nssvg, nsxhtml, FontStylePromiseCache, HTMLTextRenderData, HTMLTextSystem;
  var init_HTMLTextSystem = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/HTMLTextSystem.mjs"() {
      init_Extensions();
      init_TexturePool();
      init_types();
      init_isSafari();
      init_warn();
      init_PoolGroup();
      init_extractFontFamilies();
      init_getFontCss();
      init_getPo2TextureFromSource();
      init_getSVGUrl();
      init_getTemporaryCanvasFromImage();
      init_loadSVGImage();
      init_measureHtmlText();
      nssvg = "http://www.w3.org/2000/svg";
      nsxhtml = "http://www.w3.org/1999/xhtml";
      FontStylePromiseCache = /* @__PURE__ */ new Map();
      HTMLTextRenderData = class {
        constructor() {
          this.svgRoot = document.createElementNS(nssvg, "svg");
          this.foreignObject = document.createElementNS(nssvg, "foreignObject");
          this.domElement = document.createElementNS(nsxhtml, "div");
          this.styleElement = document.createElementNS(nsxhtml, "style");
          this.image = new Image();
          const { foreignObject, svgRoot, styleElement, domElement } = this;
          foreignObject.setAttribute("width", "10000");
          foreignObject.setAttribute("height", "10000");
          foreignObject.style.overflow = "hidden";
          svgRoot.appendChild(foreignObject);
          foreignObject.appendChild(styleElement);
          foreignObject.appendChild(domElement);
        }
      };
      HTMLTextSystem = class {
        constructor(renderer) {
          this._activeTextures = {};
          this._renderer = renderer;
          this._createCanvas = renderer.type === RendererType.WEBGPU;
        }
        getTexture(options) {
          return this._buildTexturePromise(options.text, options.resolution, options.style);
        }
        getManagedTexture(text, resolution, style, textKey) {
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].promise;
          }
          const promise2 = this._buildTexturePromise(text, resolution, style).then((texture) => {
            this._activeTextures[textKey].texture = texture;
            return texture;
          });
          this._activeTextures[textKey] = {
            texture: null,
            promise: promise2,
            usageCount: 1
          };
          return promise2;
        }
        async _buildTexturePromise(text, resolution, style) {
          const htmlTextData = BigPool.get(HTMLTextRenderData);
          const fontFamilies = extractFontFamilies(text, style.fontFamily);
          const fontCSS = await getFontCss(fontFamilies, style);
          const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          const image = htmlTextData.image;
          image.width = width | 0;
          image.height = height | 0;
          const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
          await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
          let resource = image;
          if (this._createCanvas) {
            resource = getTemporaryCanvasFromImage(image, resolution);
          }
          const texture = getPo2TextureFromSource(resource, resource.width, resource.height, resolution);
          if (this._createCanvas) {
            this._renderer.texture.initSource(texture.source);
          }
          BigPool.return(htmlTextData);
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          if (!activeTexture)
            return;
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            if (activeTexture.texture) {
              this._cleanUp(activeTexture);
            } else {
              activeTexture.promise.then((texture) => {
                activeTexture.texture = texture;
                this._cleanUp(activeTexture);
              }).catch(() => {
                warn("HTMLTextSystem: Failed to clean texture");
              });
            }
            this._activeTextures[textKey] = null;
          }
        }
        _cleanUp(activeTexture) {
          TexturePool.returnTexture(activeTexture.texture);
          activeTexture.texture.source.resource = null;
          activeTexture.texture.source.uploadMethodId = "unknown";
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      HTMLTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "htmlText"
      };
      HTMLTextSystem.defaultFontOptions = {
        fontFamily: "Arial",
        fontStyle: "normal",
        fontWeight: "normal"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/BatcherPipe.mjs
  var BatcherPipe;
  var init_BatcherPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
      init_Extensions();
      init_State();
      init_BatchGeometry();
      init_Batcher();
      BatcherPipe = class {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._batches = /* @__PURE__ */ Object.create(null);
          this._geometries = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
        }
        buildStart(instructionSet) {
          if (!this._batches[instructionSet.uid]) {
            const batcher = new Batcher();
            this._batches[instructionSet.uid] = batcher;
            this._geometries[batcher.uid] = new BatchGeometry();
          }
          this._activeBatch = this._batches[instructionSet.uid];
          this._activeGeometry = this._geometries[this._activeBatch.uid];
          this._activeBatch.begin();
        }
        addToBatch(batchableObject) {
          this._activeBatch.add(batchableObject);
        }
        break(instructionSet) {
          this._activeBatch.break(instructionSet);
        }
        buildEnd(instructionSet) {
          const activeBatch = this._activeBatch;
          const geometry = this._activeGeometry;
          activeBatch.finish(instructionSet);
          geometry.indexBuffer.data = activeBatch.indexBuffer;
          geometry.indexBuffer.update(activeBatch.indexSize * 4);
          geometry.buffers[0].data = activeBatch.attributeBuffer.float32View;
        }
        upload(instructionSet) {
          const batcher = this._batches[instructionSet.uid];
          const geometry = this._geometries[batcher.uid];
          if (batcher.dirty) {
            batcher.dirty = false;
            geometry.buffers[0].update(batcher.attributeSize * 4);
          }
        }
        execute(batch) {
          if (batch.action === "startBatch") {
            const batcher = batch.batcher;
            const geometry = this._geometries[batcher.uid];
            this._adaptor.start(this, geometry);
          }
          this._adaptor.execute(this, batch);
        }
        destroy() {
          this.state = null;
          this.renderer = null;
          this._adaptor.destroy();
          this._adaptor = null;
          for (const i2 in this._batches) {
            this._batches[i2].destroy();
          }
          this._batches = null;
          for (const i2 in this._geometries) {
            this._geometries[i2].destroy();
          }
          this._geometries = null;
        }
      };
      BatcherPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/Filter.mjs
  var _Filter, Filter;
  var init_Filter = __esm({
    "node_modules/pixi-v8/lib/filters/Filter.mjs"() {
      init_Shader();
      init_State();
      _Filter = class extends Shader {
        constructor(options) {
          options = { ..._Filter.defaultOptions, ...options };
          super(options);
          this.enabled = true;
          this._state = State.for2d();
          this.padding = options.padding;
          if (typeof options.antialias === "boolean") {
            this.antialias = options.antialias ? "on" : "off";
          } else {
            this.antialias = options.antialias ?? "inherit";
          }
          this.resolution = options.resolution;
          this.blendRequired = options.blendRequired;
          this.addResource("filterUniforms", 0, 0);
          this.addResource("uSampler", 0, 1);
        }
        apply(filterManager, input, output, clearMode) {
          filterManager.applyFilter(this, input, output, clearMode);
        }
        get blendMode() {
          return this._state.blendMode;
        }
        set blendMode(value) {
          this._state.blendMode = value;
        }
      };
      Filter = _Filter;
      Filter.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "inherit",
        blendRequired: false
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/mask/mask.mjs
  var fragment;
  var init_mask = __esm({
    "node_modules/pixi-v8/lib/filters/mask/mask.mjs"() {
      fragment = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapTexture;\n\nuniform float alpha;\nuniform vec4 maskClamp;\n\nout vec4 fragColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = alpha; \n    vec4 original = texture(uSampler, vTextureCoord);\n    vec4 masky = texture(mapTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    fragColor = original;\n}\n";
    }
  });

  // node_modules/pixi-v8/lib/filters/mask/mask3.mjs
  var vertex;
  var init_mask3 = __esm({
    "node_modules/pixi-v8/lib/filters/mask/mask3.mjs"() {
      vertex = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec4 outputTexture;\nuniform mat3 filterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;\n       \n    position.x = position.x * (2.0 / outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
    }
  });

  // node_modules/pixi-v8/lib/filters/mask/mask2.mjs
  var source;
  var init_mask2 = __esm({
    "node_modules/pixi-v8/lib/filters/mask/mask2.mjs"() {
      source = "struct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n  outputTexture:vec4<f32>,  \n};\n\nstruct MaskUniforms {\n  filterMatrix:mat3x3<f32>,\n  maskClamp:vec4<f32>,\n  alpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uSampler: texture_2d<f32>;\n@group(0) @binding(2) var mySampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var mapTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.globalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.maskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(mapTexture, mySampler, filterUv);\n    var source = textureSample(uSampler, mySampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n    var a = (alphaMul * mask.r) * clip;\n\n    return vec4(source.rgb * a, source.a) * a;\n  \n}";
    }
  });

  // node_modules/pixi-v8/lib/filters/mask/MaskFilter.mjs
  var MaskFilter;
  var init_MaskFilter = __esm({
    "node_modules/pixi-v8/lib/filters/mask/MaskFilter.mjs"() {
      init_Matrix();
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_TextureMatrix();
      init_Filter();
      init_mask();
      init_mask3();
      init_mask2();
      MaskFilter = class extends Filter {
        constructor({ sprite }) {
          const textureMatrix = new TextureMatrix(sprite.texture);
          const filterUniforms = new UniformGroup({
            filterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            maskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
            alpha: { value: 1, type: "f32" }
          });
          const gpuProgram = new GpuProgram({
            vertex: {
              source,
              entryPoint: "mainVertex"
            },
            fragment: {
              source,
              entryPoint: "mainFragment"
            }
          });
          const glProgram = GlProgram.from({
            vertex,
            fragment,
            name: "mask-filter"
          });
          super({
            gpuProgram,
            glProgram,
            resources: {
              filterUniforms,
              mapTexture: sprite.texture.source
            }
          });
          this.sprite = sprite;
          this._textureMatrix = textureMatrix;
        }
        apply(filterManager, input, output, clearMode) {
          this._textureMatrix.texture = this.sprite.texture;
          filterManager.calculateSpriteMatrix(
            this.resources.filterUniforms.uniforms.filterMatrix,
            this.sprite
          ).prepend(this._textureMatrix.mapCoord);
          this.resources.mapTexture = this.sprite.texture.source;
          filterManager.applyFilter(this, input, output, clearMode);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
  var tempBounds4, AlphaMaskEffect, AlphaMaskPipe;
  var init_AlphaMaskPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_MaskFilter();
      init_Bounds();
      init_getGlobalBounds();
      init_buildInstructions();
      init_Sprite();
      init_PoolGroup();
      init_Texture();
      init_TexturePool();
      tempBounds4 = new Bounds();
      AlphaMaskEffect = class extends FilterEffect {
        constructor() {
          super({
            filters: [new MaskFilter({
              sprite: new Sprite(Texture.EMPTY)
            })]
          });
        }
        get sprite() {
          return this.filters[0].sprite;
        }
        set sprite(value) {
          this.filters[0].sprite = value;
        }
      };
      AlphaMaskPipe = class {
        constructor(renderer) {
          this._activeMaskStage = [];
          this._renderer = renderer;
        }
        push(mask, maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "alphaMask",
            action: "pushMaskBegin",
            mask,
            canBundle: false,
            maskedContainer
          });
          if (mask.renderMaskToTexture) {
            const maskContainer = mask.mask;
            maskContainer.includeInBuild = true;
            collectAllRenderables(
              maskContainer,
              instructionSet,
              renderer.renderPipes
            );
            maskContainer.includeInBuild = false;
          }
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "alphaMask",
            action: "pushMaskEnd",
            mask,
            maskedContainer,
            canBundle: false
          });
        }
        pop(mask, _maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "alphaMask",
            action: "popMaskEnd",
            mask,
            canBundle: false
          });
        }
        execute(instruction) {
          const renderer = this._renderer;
          const renderMask = instruction.mask.renderMaskToTexture;
          if (instruction.action === "pushMaskBegin") {
            const filterEffect = BigPool.get(AlphaMaskEffect);
            if (renderMask) {
              instruction.mask.mask.measurable = true;
              const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds4);
              instruction.mask.mask.measurable = false;
              bounds.ceil();
              const filterTexture = TexturePool.getOptimalTexture(
                bounds.width,
                bounds.height,
                1,
                false
              );
              const renderTarget = renderer.renderTarget.push(filterTexture, true);
              renderer.globalUniforms.push({
                projectionData: renderTarget,
                offset: bounds,
                worldColor: 4294967295
              });
              const sprite = filterEffect.sprite;
              sprite.texture = filterTexture;
              sprite.worldTransform.tx = bounds.minX;
              sprite.worldTransform.ty = bounds.minY;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer,
                filterTexture
              });
            } else {
              filterEffect.sprite = instruction.mask.mask;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer
              });
            }
          } else if (instruction.action === "pushMaskEnd") {
            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
            if (renderMask) {
              renderer.renderTarget.pop();
              renderer.globalUniforms.pop();
            }
            renderer.filter.push({
              type: "filter",
              action: "pushFilter",
              container: maskData.maskedContainer,
              filterEffect: maskData.filterEffect,
              canBundle: false
            });
          } else if (instruction.action === "popMaskEnd") {
            renderer.filter.pop();
            const maskData = this._activeMaskStage.pop();
            if (renderMask) {
              TexturePool.returnTexture(maskData.filterTexture);
            }
            BigPool.return(maskData.filterEffect);
          }
        }
        destroy() {
          this._renderer = null;
          this._activeMaskStage = null;
        }
      };
      AlphaMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "alphaMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/color/ColorMaskPipe.mjs
  var ColorMaskPipe;
  var init_ColorMaskPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
      init_Extensions();
      ColorMaskPipe = class {
        constructor(renderer) {
          this._colorStack = [];
          this._colorStackIndex = 0;
          this._currentColor = 0;
          this._renderer = renderer;
        }
        buildStart() {
          this._colorStack[0] = 15;
          this._colorStackIndex = 1;
          this._currentColor = 15;
        }
        push(mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
          const currentColor = this._colorStack[this._colorStackIndex];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              type: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
          this._colorStackIndex++;
        }
        pop(_mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          this._colorStackIndex--;
          const currentColor = colorStack[this._colorStackIndex - 1];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              type: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
        }
        execute(instruction) {
          const renderer = this._renderer;
          renderer.colorMask.setMask(instruction.colorMask);
        }
        destroy() {
          this._colorStack = null;
        }
      };
      ColorMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/const.mjs
  var CLEAR;
  var init_const7 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/const.mjs"() {
      CLEAR = /* @__PURE__ */ ((CLEAR2) => {
        CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
        CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
        CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
        CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
        CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
        CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
        CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
        CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
        return CLEAR2;
      })(CLEAR || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/state/const.mjs
  var STENCIL_MODES;
  var init_const8 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/state/const.mjs"() {
      STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
        STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
        STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";
        STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";
        return STENCIL_MODES2;
      })(STENCIL_MODES || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/stencil/StencilMaskPipe.mjs
  var StencilMaskPipe;
  var init_StencilMaskPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
      init_Extensions();
      init_buildInstructions();
      init_const7();
      init_const8();
      StencilMaskPipe = class {
        constructor(renderer) {
          this._maskStackHash = {};
          this._maskHash = /* @__PURE__ */ new WeakMap();
          this._renderer = renderer;
        }
        push(mask, _container, instructionSet) {
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            type: "stencilMask",
            action: "pushMaskBegin",
            mask,
            canBundle: false
          });
          const maskContainer = effect.mask;
          maskContainer.includeInBuild = true;
          if (!this._maskHash.has(effect)) {
            this._maskHash.set(effect, {
              instructionsStart: 0,
              instructionsLength: 0
            });
          }
          const maskData = this._maskHash.get(effect);
          maskData.instructionsStart = instructionSet.instructionSize;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer.renderPipes
          );
          maskContainer.includeInBuild = false;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "stencilMask",
            action: "pushMaskEnd",
            mask,
            canBundle: false
          });
          const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
          maskData.instructionsLength = instructionsLength;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          if (this._maskStackHash[renderTargetUid] === void 0) {
            this._maskStackHash[renderTargetUid] = 0;
          }
          this._maskStackHash[renderTargetUid]++;
        }
        pop(mask, _container, instructionSet) {
          const effect = mask;
          const renderer = this._renderer;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          this._maskStackHash[renderTargetUid]--;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            type: "stencilMask",
            action: "popMaskBegin",
            canBundle: false
          });
          const maskData = this._maskHash.get(mask);
          if (this._maskStackHash[renderTargetUid] !== 0) {
            for (let i2 = 0; i2 < maskData.instructionsLength; i2++) {
              instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
            }
          }
          instructionSet.add({
            type: "stencilMask",
            action: "popMaskEnd",
            canBundle: false
          });
        }
        execute(instruction) {
          const renderer = this._renderer;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          let maskStackIndex = this._maskStackHash[renderTargetUid] ?? 0;
          if (instruction.action === "pushMaskBegin") {
            maskStackIndex++;
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
            renderer.colorMask.setMask(0);
          } else if (instruction.action === "pushMaskEnd") {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            renderer.colorMask.setMask(15);
          } else if (instruction.action === "popMaskBegin") {
            maskStackIndex--;
            if (maskStackIndex !== 0) {
              renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
              renderer.colorMask.setMask(0);
            } else {
              renderer.renderTarget.clear(CLEAR.STENCIL);
            }
          } else if (instruction.action === "popMaskEnd") {
            if (maskStackIndex === 0) {
              renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
            } else {
              renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            }
            renderer.colorMask.setMask(15);
          }
          this._maskStackHash[renderTargetUid] = maskStackIndex;
        }
        destroy() {
          this._renderer = null;
          this._maskStackHash = null;
          this._maskHash = null;
        }
      };
      StencilMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "stencilMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
  var _BackgroundSystem, BackgroundSystem;
  var init_BackgroundSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
      init_Color();
      init_Extensions();
      _BackgroundSystem = class {
        constructor() {
          this._backgroundColorRgba = [0, 0, 0, 0];
          this.clearBeforeRender = true;
          this._backgroundColor = new Color(0);
          this.color = this._backgroundColor;
          this.alpha = 1;
        }
        init(options) {
          options = { ..._BackgroundSystem.defaultOptions, ...options };
          this.clearBeforeRender = options.clearBeforeRender;
          this.color = options.background || options.backgroundColor || this._backgroundColor;
          this.alpha = options.backgroundAlpha;
        }
        get color() {
          return this._backgroundColor;
        }
        set color(value) {
          this._backgroundColor.setValue(value);
          this._backgroundColorRgba = this._backgroundColor.toArray();
        }
        get alpha() {
          return this._backgroundColor.alpha;
        }
        set alpha(value) {
          this._backgroundColor.setAlpha(value);
        }
        get colorRgba() {
          return this._backgroundColorRgba;
        }
        destroy() {
        }
      };
      BackgroundSystem = _BackgroundSystem;
      BackgroundSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "background",
        priority: 0
      };
      BackgroundSystem.defaultOptions = {
        backgroundAlpha: 1,
        backgroundColor: 0,
        clearBeforeRender: true
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/blend-template.mjs
  var blendTemplateFrag;
  var init_blend_template = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/blend-template.mjs"() {
      blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nuniform float uBlend;\n\nuniform sampler2D uSampler;\nuniform sampler2D backTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(backTexture, vTextureCoord);\n    vec4 front = texture(uSampler, vTextureCoord);\n\n    {MAIN}\n}\n";
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/blend-template2.mjs
  var blendTemplateVert;
  var init_blend_template2 = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/blend-template2.mjs"() {
      blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec4 backgroundFrame;\nuniform vec4 outputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;\n    \n    position.x = position.x * (2.0 / outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/blend-template3.mjs
  var blendTemplate;
  var init_blend_template3 = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/blend-template3.mjs"() {
      blendTemplate = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n  outputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uSampler: texture_2d<f32>;\n@group(0) @binding(2) var mySampler : sampler;\n@group(0) @binding(3) var backTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(backTexture, mySampler, uv);\n   var front = textureSample(uSampler, mySampler, uv);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/BlendModeFilter.mjs
  function compileBlendModeShader(options) {
    const { source: source2, functions, main } = options;
    return source2.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
  }
  var BlendModeFilter;
  var init_BlendModeFilter = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/BlendModeFilter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_Texture();
      init_Filter();
      init_blend_template();
      init_blend_template2();
      init_blend_template3();
      BlendModeFilter = class extends Filter {
        constructor(options) {
          const gpuOptions = options.gpu;
          const gpuSource = compileBlendModeShader({ source: blendTemplate, ...gpuOptions });
          const gpuProgram = new GpuProgram({
            vertex: {
              source: gpuSource,
              entryPoint: "mainVertex"
            },
            fragment: {
              source: gpuSource,
              entryPoint: "mainFragment"
            }
          });
          const glOptions = options.gl;
          const glSource = compileBlendModeShader({ source: blendTemplateFrag, ...glOptions });
          const glProgram = new GlProgram({
            vertex: blendTemplateVert,
            fragment: glSource
          });
          const uniformGroup = new UniformGroup({
            uBlend: {
              value: 1,
              type: "f32"
            }
          });
          super({
            gpuProgram,
            glProgram,
            blendRequired: true,
            resources: {
              blendUniforms: uniformGroup,
              backTexture: Texture.EMPTY
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/hls/GLhls.mjs
  var hslgl;
  var init_GLhls = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/hls/GLhls.mjs"() {
      hslgl = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/hls/GPUhls.mjs
  var hslgpu;
  var init_GPUhls = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/hls/GPUhls.mjs"() {
      hslgpu = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/ColorBlend.mjs
  var ColorBlend;
  var init_ColorBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/ColorBlend.mjs"() {
      init_BlendModeFilter();
      init_GLhls();
      init_GPUhls();
      ColorBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/ColorBurnBlend.mjs
  var ColorBurnBlend;
  var init_ColorBurnBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/ColorBurnBlend.mjs"() {
      init_BlendModeFilter();
      ColorBurnBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                fragColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `
            },
            gpu: {
              functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/ColorDodgeBlend.mjs
  var ColorDodgeBlend;
  var init_ColorDodgeBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/ColorDodgeBlend.mjs"() {
      init_BlendModeFilter();
      ColorDodgeBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/DarkenBlend.mjs
  var DarkenBlend;
  var init_DarkenBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/DarkenBlend.mjs"() {
      init_BlendModeFilter();
      DarkenBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/DifferenceBlend.mjs
  var DifferenceBlend;
  var init_DifferenceBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/DifferenceBlend.mjs"() {
      init_BlendModeFilter();
      DifferenceBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                fragColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `
            },
            gpu: {
              functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/DivideBlend.mjs
  var DivideBlend;
  var init_DivideBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/DivideBlend.mjs"() {
      init_BlendModeFilter();
      DivideBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/ExclusionBlend.mjs
  var ExclusionBlend;
  var init_ExclusionBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/ExclusionBlend.mjs"() {
      init_BlendModeFilter();
      ExclusionBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/HardLightBlend.mjs
  var HardLightBlend;
  var init_HardLightBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/HardLightBlend.mjs"() {
      init_BlendModeFilter();
      HardLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                fragColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `
            },
            gpu: {
              functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/HardMixBlend.mjs
  var HardMixBlend;
  var init_HardMixBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/HardMixBlend.mjs"() {
      init_BlendModeFilter();
      HardMixBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                fragColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `
            },
            gpu: {
              functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/LightenBlend.mjs
  var LightenBlend;
  var init_LightenBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/LightenBlend.mjs"() {
      init_BlendModeFilter();
      LightenBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/LinearBurnBlend.mjs
  var LinearBurnBlend;
  var init_LinearBurnBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/LinearBurnBlend.mjs"() {
      init_BlendModeFilter();
      LinearBurnBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/LinearDodgeBlend.mjs
  var LinearDodgeBlend;
  var init_LinearDodgeBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/LinearDodgeBlend.mjs"() {
      init_BlendModeFilter();
      LinearDodgeBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/LinearLightBlend.mjs
  var LinearLightBlend;
  var init_LinearLightBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/LinearLightBlend.mjs"() {
      init_BlendModeFilter();
      LinearLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                fragColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/LuminosityBlend.mjs
  var LuminosityBlend;
  var init_LuminosityBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/LuminosityBlend.mjs"() {
      init_BlendModeFilter();
      init_GLhls();
      init_GPUhls();
      LuminosityBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/NegationBlend.mjs
  var NegationBlend;
  var init_NegationBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/NegationBlend.mjs"() {
      init_BlendModeFilter();
      NegationBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/OverlayBlend.mjs
  var OverlayBlend;
  var init_OverlayBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/OverlayBlend.mjs"() {
      init_BlendModeFilter();
      OverlayBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float overlay(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/PinLightBlend.mjs
  var PinLightBlend;
  var init_PinLightBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/PinLightBlend.mjs"() {
      init_BlendModeFilter();
      PinLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                fragColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/SaturationBlend.mjs
  var SaturationBlend;
  var init_SaturationBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/SaturationBlend.mjs"() {
      init_BlendModeFilter();
      init_GLhls();
      init_GPUhls();
      SaturationBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                fragColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `
            },
            gpu: {
              functions: `
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/SoftLightBlend.mjs
  var SoftLightBlend;
  var init_SoftLightBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/SoftLightBlend.mjs"() {
      init_BlendModeFilter();
      SoftLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/SubtractBlend.mjs
  var SubtractBlend;
  var init_SubtractBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/SubtractBlend.mjs"() {
      init_BlendModeFilter();
      SubtractBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                fragColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `
            },
            gpu: {
              functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/blend-modes/VividLightBlend.mjs
  var VividLightBlend;
  var init_VividLightBlend = __esm({
    "node_modules/pixi-v8/lib/filters/blend-modes/VividLightBlend.mjs"() {
      init_BlendModeFilter();
      VividLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                fragColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `
            },
            gpu: {
              functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
  var BLEND_MODE_FILTERS, BlendModePipe;
  var init_BlendModePipe = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
      init_Extensions();
      init_ColorBlend();
      init_ColorBurnBlend();
      init_ColorDodgeBlend();
      init_DarkenBlend();
      init_DifferenceBlend();
      init_DivideBlend();
      init_ExclusionBlend();
      init_HardLightBlend();
      init_HardMixBlend();
      init_LightenBlend();
      init_LinearBurnBlend();
      init_LinearDodgeBlend();
      init_LinearLightBlend();
      init_LuminosityBlend();
      init_NegationBlend();
      init_OverlayBlend();
      init_PinLightBlend();
      init_SaturationBlend();
      init_SoftLightBlend();
      init_SubtractBlend();
      init_VividLightBlend();
      init_FilterEffect();
      init_warn();
      BLEND_MODE_FILTERS = {
        color: ColorBlend,
        "color-burn": ColorBurnBlend,
        "color-dodge": ColorDodgeBlend,
        darken: DarkenBlend,
        difference: DifferenceBlend,
        divide: DivideBlend,
        exclusion: ExclusionBlend,
        "hard-light": HardLightBlend,
        "hard-mix": HardMixBlend,
        lighten: LightenBlend,
        "linear-burn": LinearBurnBlend,
        "linear-dodge": LinearDodgeBlend,
        "linear-light": LinearLightBlend,
        luminosity: LuminosityBlend,
        negation: NegationBlend,
        overlay: OverlayBlend,
        "pin-light": PinLightBlend,
        saturation: SaturationBlend,
        "soft-light": SoftLightBlend,
        subtract: SubtractBlend,
        "vivid-light": VividLightBlend
      };
      BlendModePipe = class {
        constructor(renderer) {
          this._isAdvanced = false;
          this._filterHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        setBlendMode(renderable, blendMode, instructionSet) {
          if (this._activeBlendMode === blendMode) {
            if (this._isAdvanced)
              this._renderableList.push(renderable);
            return;
          }
          this._activeBlendMode = blendMode;
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
          this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
          if (this._isAdvanced) {
            this._beginAdvancedBlendMode(instructionSet);
            this._renderableList.push(renderable);
          }
        }
        _beginAdvancedBlendMode(instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          const blendMode = this._activeBlendMode;
          if (!BLEND_MODE_FILTERS[blendMode]) {
            warn(`Unable to assign 'BLEND_MODES.${blendMode}' using the blend mode pipeline`);
            return;
          }
          if (!this._filterHash[blendMode]) {
            this._filterHash[blendMode] = new FilterEffect({
              filters: [new BLEND_MODE_FILTERS[blendMode]()]
            });
          }
          const instruction = {
            type: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect: this._filterHash[blendMode],
            canBundle: false
          };
          this._renderableList = instruction.renderables;
          instructionSet.add(instruction);
        }
        _endAdvancedBlendMode(instructionSet) {
          this._renderableList = null;
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        buildStart() {
          this._isAdvanced = false;
        }
        buildEnd(instructionSet) {
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
        }
        destroy() {
          this._renderer = null;
          this._renderableList = null;
          for (const i2 in this._filterHash) {
            this._filterHash[i2].destroy();
          }
          this._filterHash = null;
        }
      };
      BlendModePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "blendMode"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
  var _ExtractSystem, ExtractSystem;
  var init_ExtractSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
      init_Extensions();
      init_Container();
      init_Texture();
      _ExtractSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        _normalizeOptions(options, defaults = {}) {
          if (options instanceof Container || options instanceof Texture) {
            return {
              target: options,
              ...defaults
            };
          }
          return {
            ...defaults,
            ...options
          };
        }
        async image(options) {
          const image = new Image();
          image.src = await this.base64(options);
          return image;
        }
        async base64(options) {
          options = this._normalizeOptions(
            options,
            _ExtractSystem.defaultImageOptions
          );
          const { format, quality } = options;
          const canvas2 = this.canvas(options);
          if (canvas2.toBlob !== void 0) {
            return new Promise((resolve, reject) => {
              canvas2.toBlob((blob) => {
                if (!blob) {
                  reject(new Error("ICanvas.toBlob failed!"));
                  return;
                }
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              }, format, quality);
            });
          }
          if (canvas2.toDataURL !== void 0) {
            return canvas2.toDataURL(format, quality);
          }
          if (canvas2.convertToBlob !== void 0) {
            const blob = await canvas2.convertToBlob({ type: format, quality });
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            });
          }
          throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        canvas(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
          const canvas2 = renderer.texture.generateCanvas(texture);
          if (target instanceof Container) {
            texture.destroy();
          }
          return canvas2;
        }
        pixels(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
          const pixelInfo = renderer.texture.getPixels(texture);
          if (target instanceof Container) {
            texture.destroy();
          }
          return pixelInfo;
        }
        texture(options) {
          options = this._normalizeOptions(options);
          if (options.target instanceof Texture)
            return options.target;
          return this._renderer.textureGenerator.generateTexture(options);
        }
        download(options) {
          options = this._normalizeOptions(options);
          const canvas2 = this.canvas(options);
          const link = document.createElement("a");
          link.download = options.filename ?? "image.png";
          link.href = canvas2.toDataURL("image/png");
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
        log(options) {
          const width = options.width ?? 200;
          options = this._normalizeOptions(options);
          const canvas2 = this.canvas(options);
          const base64 = canvas2.toDataURL();
          console.log(`[Pixi Texture] ${canvas2.width}px ${canvas2.height}px`);
          const style = [
            "font-size: 1px;",
            `padding: ${width}px ${300}px;`,
            `background: url(${base64}) no-repeat;`,
            "background-size: contain;"
          ].join(" ");
          console.log("%c ", style);
        }
        destroy() {
          this._renderer = null;
        }
      };
      ExtractSystem = _ExtractSystem;
      ExtractSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "extract"
      };
      ExtractSystem.defaultImageOptions = {
        format: "png",
        quality: 1
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/RenderTexture.mjs
  var RenderTexture;
  var init_RenderTexture = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
      init_TextureSource();
      init_Texture();
      RenderTexture = class extends Texture {
        static create(options) {
          return new Texture({
            source: new TextureSource(options)
          });
        }
        resize(width, height, resolution) {
          this.source.resize(width, height, resolution);
          return this;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
  var tempRect2, tempBounds5, noColor, GenerateTextureSystem;
  var init_GenerateTextureSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_Matrix();
      init_Rectangle();
      init_Bounds();
      init_getLocalBounds();
      init_Container();
      init_RenderTexture();
      tempRect2 = new Rectangle();
      tempBounds5 = new Bounds();
      noColor = [0, 0, 0, 0];
      GenerateTextureSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        generateTexture(options) {
          if (options instanceof Container) {
            options = {
              target: options,
              frame: void 0,
              textureSourceOptions: {},
              resolution: void 0
            };
          }
          const resolution = options.resolution || this._renderer.resolution;
          const container = options.target;
          let clearColor = options.clearColor;
          if (clearColor) {
            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
          } else {
            clearColor = noColor;
          }
          const region = options.frame?.copyTo(tempRect2) || getLocalBounds(container, tempBounds5).rectangle;
          region.width = Math.max(region.width, 1 / resolution) | 0;
          region.height = Math.max(region.height, 1 / resolution) | 0;
          const target = RenderTexture.create({
            ...options.textureSourceOptions,
            width: region.width,
            height: region.height,
            resolution
          });
          const transform = Matrix.shared.translate(-region.x, -region.y);
          this._renderer.render({
            container,
            transform,
            target,
            clearColor
          });
          return target;
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
        }
      };
      GenerateTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGenerator"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
  var GlobalUniformSystem;
  var init_GlobalUniformSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_BindGroup();
      init_UniformGroup();
      GlobalUniformSystem = class {
        constructor(renderer) {
          this._stackIndex = 0;
          this._globalUniformDataStack = [];
          this._uniformsPool = [];
          this._activeUniforms = [];
          this._bindGroupPool = [];
          this._activeBindGroups = [];
          this._renderer = renderer;
        }
        reset() {
          this._stackIndex = 0;
          for (let i2 = 0; i2 < this._activeUniforms.length; i2++) {
            this._uniformsPool.push(this._activeUniforms[i2]);
          }
          for (let i2 = 0; i2 < this._activeBindGroups.length; i2++) {
            this._bindGroupPool.push(this._activeBindGroups[i2]);
          }
          this._activeUniforms.length = 0;
          this._activeBindGroups.length = 0;
        }
        start(options) {
          this.reset();
          this.push(options);
        }
        bind({
          projectionData,
          worldTransformMatrix,
          worldColor,
          offset
        }) {
          const renderTarget = this._renderer.renderTarget.renderTarget;
          const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
            projectionData: renderTarget,
            worldTransformMatrix: new Matrix(),
            worldColor: 4294967295,
            offset: new Point()
          };
          const globalUniformData = {
            projectionMatrix: projectionData?.projectionMatrix || renderTarget.projectionMatrix,
            resolution: projectionData?.size || renderTarget.size,
            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
            worldColor: worldColor || currentGlobalUniformData.worldColor,
            offset: offset || currentGlobalUniformData.offset,
            bindGroup: null
          };
          const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
          this._activeUniforms.push(uniformGroup);
          const uniforms = uniformGroup.uniforms;
          uniforms.projectionMatrix = globalUniformData.projectionMatrix;
          uniforms.uResolution = globalUniformData.resolution;
          uniforms.worldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
          uniforms.worldTransformMatrix.tx -= globalUniformData.offset.x;
          uniforms.worldTransformMatrix.ty -= globalUniformData.offset.y;
          uniforms.worldAlpha = (globalUniformData.worldColor >> 24 & 255) / 255;
          uniformGroup.update();
          let bindGroup;
          if (this._renderer.renderPipes.uniformBatch) {
            bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
          } else {
            this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
            bindGroup = this._bindGroupPool.pop() || new BindGroup();
            this._activeBindGroups.push(bindGroup);
            bindGroup.setResource(uniformGroup, 0);
          }
          globalUniformData.bindGroup = bindGroup;
          this._currentGlobalUniformData = globalUniformData;
        }
        push(options) {
          this.bind(options);
          this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
          this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
        }
        get bindGroup() {
          return this._currentGlobalUniformData.bindGroup;
        }
        get uniformGroup() {
          return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
          const globalUniforms = new UniformGroup({
            projectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            worldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            worldAlpha: { value: 1, type: "f32" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          }, {
            ubo: true,
            isStatic: true
          });
          return globalUniforms;
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
        }
      };
      GlobalUniformSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "globalUniforms"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/createUBOElements.mjs
  function createUBOElements(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let size2 = 0;
    let chunkSize = 0;
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      size2 = WGSL_TO_STD40_SIZE[uboElement.data.type];
      if (!size2) {
        throw new Error(`Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size2 = Math.max(size2, 16) * uboElement.data.size;
      }
      uboElement.size = size2;
      if (chunkSize % size2 !== 0 && chunkSize < 16) {
        const lineUpValue = chunkSize % size2 % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size2 > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size2;
        chunkSize = size2;
      } else {
        uboElement.offset = offset;
        chunkSize += size2;
        offset += size2;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_TO_STD40_SIZE;
  var init_createUBOElements = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/createUBOElements.mjs"() {
      WGSL_TO_STD40_SIZE = {
        "f32": 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "mat2x2<f32>": 16 * 3,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/uniformBufferParsers.mjs
  var uniformBufferParsers;
  var init_uniformBufferParsers = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/uniformBufferParsers.mjs"() {
      uniformBufferParsers = [
        {
          type: "mat3x3<f32>",
          test: (data) => data.value.a !== void 0,
          code: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];

                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];

                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
        },
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
          code: (name) => `
                        v = uv.${name};

                        data[offset] = v.x;
                        data[offset+1] = v.y;
                        data[offset+2] = v.width;
                        data[offset+3] = v.height;
                    `
        },
        {
          type: "vec2<f32>",
          test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
          code: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                `
        }
      ];
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/createUniformBufferSync.mjs
  function generateUniformBufferSync(uboElements) {
    const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
    `];
    let prev = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      const name = uboElement.data.name;
      let parsed = false;
      let offset = 0;
      for (let j2 = 0; j2 < uniformBufferParsers.length; j2++) {
        const uniformParser = uniformBufferParsers[j2];
        if (uniformParser.test(uboElement.data)) {
          offset = uboElement.offset / 4;
          funcFragments.push(
            `offset += ${offset - prev};`,
            uniformBufferParsers[j2].code(name)
          );
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
          const elementSize = uboElement.data.value.length / uboElement.data.size;
          const remainder = (4 - elementSize % 4) % 4;
          offset = uboElement.offset / 4;
          funcFragments.push(
            `
                    v = uv.${name};
                    offset += ${offset - prev};

                    let arrayOffset = offset;
                    
                    t = 0;

                    for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                    {
                        for(var j = 0; j < ${elementSize}; j++)
                        {
                            data[arrayOffset++] = v[t++];
                        }
                        ${remainder !== 0 ? "arrayOffset += ${remainder};" : ""}
                    }
                `
          );
        } else {
          const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
          offset = uboElement.offset / 4;
          funcFragments.push(
            `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
          );
        }
      }
      prev = offset;
    }
    const fragmentSrc = funcFragments.join("\n");
    return new Function(
      "uv",
      "data",
      "offset",
      fragmentSrc
    );
  }
  var UBO_TO_SINGLE_SETTERS;
  var init_createUniformBufferSync = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/createUniformBufferSync.mjs"() {
      init_createUBOElements();
      init_uniformBufferParsers();
      UBO_TO_SINGLE_SETTERS = {
        "f32": `
        data[offset] = v;
    `,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
        "mat4x4<f32>": `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/UniformBufferSystem.mjs
  var UniformBufferSystem;
  var init_UniformBufferSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/UniformBufferSystem.mjs"() {
      init_Extensions();
      init_Buffer();
      init_const5();
      init_createUBOElements();
      init_createUniformBufferSync();
      UniformBufferSystem = class {
        constructor() {
          this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
        }
        ensureUniformGroup(uniformGroup) {
          if (!uniformGroup._syncFunction) {
            this._initUniformGroup(uniformGroup);
          }
        }
        _initUniformGroup(uniformGroup) {
          const uniformGroupSignature = uniformGroup.signature;
          let uniformData = this._syncFunctionHash[uniformGroupSignature];
          if (!uniformData) {
            const elements = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
            const layout = createUBOElements(elements);
            const syncFunction = generateUniformBufferSync(layout.uboElements);
            uniformData = this._syncFunctionHash[uniformGroupSignature] = {
              layout,
              syncFunction
            };
          }
          uniformGroup._syncFunction = uniformData.syncFunction;
          uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          });
          return uniformGroup._syncFunction;
        }
        syncUniformGroup(uniformGroup, data, offset) {
          const syncFunction = uniformGroup._syncFunction || this._initUniformGroup(uniformGroup);
          data || (data = uniformGroup.buffer.data);
          offset || (offset = 0);
          syncFunction(uniformGroup.uniforms, data, offset);
          return true;
        }
        updateUniformGroup(uniformGroup) {
          if (uniformGroup.isStatic && !uniformGroup.dirtyId)
            return false;
          uniformGroup.dirtyId = 0;
          const synced = this.syncUniformGroup(uniformGroup);
          uniformGroup.buffer.update();
          return synced;
        }
        destroy() {
          this._syncFunctionHash = null;
        }
      };
      UniformBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "uniformBuffer"
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/sayHello.mjs
  function sayHello(type) {
    if (saidHello) {
      return;
    }
    if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const args = [
        `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...args);
    } else if (globalThis.console) {
      globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
    }
    saidHello = true;
  }
  var saidHello, VERSION;
  var init_sayHello = __esm({
    "node_modules/pixi-v8/lib/utils/sayHello.mjs"() {
      init_settings();
      saidHello = false;
      VERSION = "8.0.0-beta.3";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/startup/HelloSystem.mjs
  var HelloSystem;
  var init_HelloSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
      init_Extensions();
      init_sayHello();
      HelloSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        init(options) {
          if (options.hello) {
            sayHello(this._renderer.name);
          }
        }
      };
      HelloSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "hello",
        priority: 0
      };
      HelloSystem.defaultOptions = {
        hello: false
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
  var _TextureGCSystem, TextureGCSystem;
  var init_TextureGCSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
      init_Extensions();
      _TextureGCSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
          this.count = 0;
          this.checkCount = 0;
        }
        init(options) {
          options = { ..._TextureGCSystem.defaultOptions, ...options };
          this.checkCountMax = options.textureGCCheckCountMax;
          this.maxIdle = options.textureGCAMaxIdle;
          this.active = options.textureGCActive;
        }
        postrender() {
          if (!this._renderer.renderingToScreen) {
            return;
          }
          this.count++;
          if (!this.active)
            return;
          this.checkCount++;
          if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
          }
        }
        run() {
          const managedTextures = this._renderer.texture.managedTextures;
          for (let i2 = 0; i2 < managedTextures.length; i2++) {
            const texture = managedTextures[i2];
            if (texture.resource && texture.touched > -1 && this.count - texture.touched > this.maxIdle) {
              texture.touched = -1;
              texture.unload();
            }
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      TextureGCSystem = _TextureGCSystem;
      TextureGCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGC"
      };
      TextureGCSystem.defaultOptions = {
        textureGCActive: true,
        textureGCAMaxIdle: 60 * 60,
        textureGCCheckCountMax: 600
      };
      extensions.add(TextureGCSystem);
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
  var CanvasSource;
  var init_CanvasSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
      init_settings();
      init_TextureSource();
      CanvasSource = class extends TextureSource {
        constructor(options) {
          if (!options.resource) {
            options.resource = settings.ADAPTER.createCanvas();
          }
          if (!options.width) {
            options.width = options.resource.width;
            if (!options.autoDensity) {
              options.width /= options.resolution;
            }
          }
          if (!options.height) {
            options.height = options.resource.height;
            if (!options.autoDensity) {
              options.height /= options.resolution;
            }
          }
          options.alphaMode ?? (options.alphaMode = "premultiply-alpha-on-upload");
          super(options);
          this.uploadMethodId = "image";
          this.autoDensity = options.autoDensity;
          const canvas2 = options.resource;
          if (this.pixelWidth !== canvas2.width || this.pixelWidth !== canvas2.height) {
            this.resizeCanvas();
          }
        }
        resizeCanvas() {
          if (this.autoDensity) {
            this.resource.style.width = `${this.width}px`;
            this.resource.style.height = `${this.height}px`;
          }
          this.resource.width = this.pixelWidth;
          this.resource.height = this.pixelHeight;
        }
        resize(width = this.width, height = this.height, resolution = this._resolution) {
          super.resize(width, height, resolution);
          this.resizeCanvas();
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
  function getCanvasTexture(canvas2, options) {
    if (!canvasCache.has(canvas2)) {
      const texture = new Texture({
        source: new CanvasSource({
          resource: canvas2,
          ...options
        })
      });
      canvasCache.set(canvas2, texture);
    }
    return canvasCache.get(canvas2);
  }
  var canvasCache;
  var init_getCanvasTexture = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
      init_CanvasSource();
      init_Texture();
      canvasCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/view/ViewSystem.mjs
  var _ViewSystem, ViewSystem;
  var init_ViewSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
      init_Extensions();
      init_Rectangle();
      init_settings();
      init_deprecation();
      init_getCanvasTexture();
      _ViewSystem = class {
        get resolution() {
          return this.texture.source._resolution;
        }
        set resolution(value) {
          this.texture.source.resize(
            this.texture.source.width,
            this.texture.source.height,
            value
          );
        }
        init(options) {
          options = {
            ..._ViewSystem.defaultOptions,
            ...options
          };
          if (options.element) {
            deprecation(v8_0_0, "ViewSystem.element has been renamed to ViewSystem.canvas");
            options.canvas = options.element;
          }
          this.screen = new Rectangle(0, 0, options.width, options.height);
          this.canvas = options.canvas || settings.ADAPTER.createCanvas();
          this.antialias = !!options.antialias;
          this.texture = getCanvasTexture(this.canvas, options);
          this.multiView = !!options.multiView;
          if (this.autoDensity) {
            this.canvas.style.width = `${this.texture.width}px`;
            this.canvas.style.height = `${this.texture.height}px`;
          }
        }
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.screen.width = this.texture.frameWidth;
          this.screen.height = this.texture.frameHeight;
          if (this.autoDensity) {
            this.canvas.style.width = `${desiredScreenWidth}px`;
            this.canvas.style.height = `${desiredScreenHeight}px`;
          }
        }
        destroy(options = false) {
          const removeView = typeof options === "boolean" ? options : !!options?.removeView;
          if (removeView && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
        }
      };
      ViewSystem = _ViewSystem;
      ViewSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "view",
        priority: 0
      };
      ViewSystem.defaultOptions = {
        width: 800,
        height: 600,
        resolution: settings.RESOLUTION,
        autoDensity: false,
        antialias: false
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/system/SharedSystems.mjs
  var SharedSystems, SharedRenderPipes;
  var init_SharedSystems = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
      init_AccessibilitySystem();
      init_FilterPipe();
      init_FilterSystem();
      init_LayerPipe();
      init_LayerSystem();
      init_GraphicsContextSystem();
      init_GraphicsPipe();
      init_MeshPipe();
      init_SpritePipe();
      init_TilingSpritePipe();
      init_BitmapTextPipe();
      init_CanvasTextPipe();
      init_CanvasTextSystem();
      init_HTMLTextPipe();
      init_HTMLTextSystem();
      init_BatcherPipe();
      init_AlphaMaskPipe();
      init_ColorMaskPipe();
      init_StencilMaskPipe();
      init_BackgroundSystem();
      init_BlendModePipe();
      init_ExtractSystem();
      init_GenerateTextureSystem();
      init_GlobalUniformSystem();
      init_UniformBufferSystem();
      init_HelloSystem();
      init_TextureGCSystem();
      init_ViewSystem();
      SharedSystems = [
        BackgroundSystem,
        FilterSystem,
        GraphicsContextSystem,
        GlobalUniformSystem,
        HelloSystem,
        ViewSystem,
        CanvasTextSystem,
        HTMLTextSystem,
        LayerSystem,
        UniformBufferSystem,
        TextureGCSystem,
        GenerateTextureSystem,
        ExtractSystem,
        AccessibilitySystem
      ];
      SharedRenderPipes = [
        BlendModePipe,
        BatcherPipe,
        SpritePipe,
        LayerPipe,
        MeshPipe,
        GraphicsPipe,
        CanvasTextPipe,
        HTMLTextPipe,
        BitmapTextPipe,
        TilingSpritePipe,
        FilterPipe,
        AlphaMaskPipe,
        StencilMaskPipe,
        ColorMaskPipe
      ];
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/BindGroupSystem.mjs
  var BindGroupSystem;
  var init_BindGroupSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
      init_Extensions();
      BindGroupSystem = class {
        constructor(renderer) {
          this._hash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getBindGroup(bindGroup, program, groupIndex) {
          bindGroup.updateKey();
          const gpuBindGroup = this._hash[bindGroup.key] || this._createBindGroup(bindGroup, program, groupIndex);
          return gpuBindGroup;
        }
        _createBindGroup(group, program, groupIndex) {
          const device = this._gpu.device;
          const groupLayout = program.layout[groupIndex];
          const entries = [];
          for (const j2 in groupLayout) {
            const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
            let gpuResource;
            if (resource.resourceType === "uniformGroup") {
              const uniformGroup = resource;
              this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
              const buffer = uniformGroup.buffer;
              gpuResource = {
                buffer: this._renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource.resourceType === "buffer") {
              const buffer = resource;
              gpuResource = {
                buffer: this._renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource.resourceType === "bufferResource") {
              const bufferResource = resource;
              gpuResource = {
                buffer: this._renderer.buffer.getGPUBuffer(bufferResource.buffer),
                offset: bufferResource.offset,
                size: bufferResource.size
              };
            } else if (resource.resourceType === "textureSampler") {
              const sampler = resource;
              gpuResource = this._renderer.texture.getGpuSampler(sampler);
            } else if (resource.resourceType === "textureSource") {
              const texture = resource;
              gpuResource = this._renderer.texture.getGpuSource(texture).createView({});
            }
            entries.push({
              binding: groupLayout[j2],
              resource: gpuResource
            });
          }
          const gpuBindGroup = device.createBindGroup({
            layout: program._gpuLayout.bindGroups[groupIndex],
            entries
          });
          this._hash[group.key] = gpuBindGroup;
          return gpuBindGroup;
        }
        destroy() {
          for (const key of Object.keys(this._hash)) {
            this._hash[key] = null;
          }
          this._hash = null;
          const writeable = this;
          writeable._renderer = null;
        }
      };
      BindGroupSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "bindGroup"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
  var BufferSystem;
  var init_GpuBufferSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
      init_Extensions();
      init_fastCopy();
      BufferSystem = class {
        constructor() {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getGPUBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        }
        updateBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
          if (buffer._updateID && buffer.data) {
            buffer._updateID = 0;
            this._gpu.device.queue.writeBuffer(gpuBuffer, 0, buffer.data.buffer, 0, buffer._updateSize);
          }
          return gpuBuffer;
        }
        destroyAll() {
          for (const id in this._gpuBuffers) {
            this._gpuBuffers[id].destroy();
          }
          this._gpuBuffers = {};
        }
        createGPUBuffer(buffer) {
          const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
          buffer._updateID = 0;
          if (buffer.data) {
            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
            gpuBuffer.unmap();
          }
          this._gpuBuffers[buffer.uid] = gpuBuffer;
          buffer.on("update", this.updateBuffer, this);
          buffer.on("change", this.onBufferChange, this);
          buffer.on("destroy", this.onBufferDestroy, this);
          return gpuBuffer;
        }
        onBufferChange(buffer) {
          let gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          gpuBuffer = this.createGPUBuffer(buffer);
          buffer._updateID = 0;
        }
        onBufferDestroy(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          this._gpuBuffers[buffer.uid] = null;
        }
        destroy() {
          for (const k2 of Object.keys(this._gpuBuffers)) {
            const key = Number(k2);
            const gpuBuffer = this._gpuBuffers[key];
            gpuBuffer.destroy();
            this._gpuBuffers[key] = null;
          }
          this._gpuBuffers = null;
          const writeable = this;
          writeable._renderer = null;
        }
      };
      BufferSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
  var GpuColorMaskSystem;
  var init_GpuColorMaskSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
      init_Extensions();
      GpuColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.pipeline.setColorMask(colorMask);
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
          this._colorMaskCache = null;
        }
      };
      GpuColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
  var GpuDeviceSystem;
  var init_GpuDeviceSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
      init_Extensions();
      GpuDeviceSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        async init() {
          if (this._initPromise)
            return this._initPromise;
          this._initPromise = this._createDeviceAndAdaptor({}).then((gpu) => {
            this.gpu = gpu;
            this._renderer.runners.contextChange.emit(this.gpu);
          });
          return this._initPromise;
        }
        contextChange(gpu) {
          this._renderer.gpu = gpu;
        }
        async _createDeviceAndAdaptor(options) {
          const adapter = await navigator.gpu.requestAdapter(options);
          const device = await adapter.requestDevice();
          return { adapter, device };
        }
        destroy() {
          this.gpu = null;
          this._renderer = null;
        }
      };
      GpuDeviceSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "device"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
  var GpuEncoderSystem;
  var init_GpuEncoderSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
      init_Extensions();
      GpuEncoderSystem = class {
        constructor(renderer) {
          this._boundBindGroup = /* @__PURE__ */ Object.create(null);
          this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        start() {
          this.commandFinished = new Promise((resolve) => {
            this._resolveCommandFinished = resolve;
          });
          this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        }
        beginRenderPass(renderTarget, gpuRenderTarget) {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
          }
          this._clearCache();
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
          this._setViewport(renderTarget.viewport);
        }
        _setViewport(viewport) {
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        }
        setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
          const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
          this.setPipeline(pipeline);
        }
        setPipeline(pipeline) {
          if (this._boundPipeline === pipeline)
            return;
          this._boundPipeline = pipeline;
          this.renderPassEncoder.setPipeline(pipeline);
        }
        _setVertexBuffer(index, buffer) {
          if (this._boundVertexBuffer[index] === buffer)
            return;
          this._boundVertexBuffer[index] = buffer;
          this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
        }
        _setIndexBuffer(buffer) {
          if (this._boundIndexBuffer === buffer)
            return;
          this._boundIndexBuffer = buffer;
          this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), "uint32");
        }
        setBindGroup(index, bindGroup, program) {
          if (this._boundBindGroup[index] === bindGroup)
            return;
          this._boundBindGroup[index] = bindGroup;
          bindGroup.touch(this._renderer.textureGC.count);
          const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
          this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
        }
        setGeometry(geometry) {
          for (const i2 in geometry.attributes) {
            const attribute = geometry.attributes[i2];
            this._setVertexBuffer(attribute.shaderLocation, attribute.buffer);
          }
          if (geometry.indexBuffer) {
            this._setIndexBuffer(geometry.indexBuffer);
          }
        }
        _setShaderBindGroups(shader, skipSync) {
          for (const i2 in shader.groups) {
            const bindGroup = shader.groups[i2];
            if (!skipSync) {
              this._syncBindGroup(bindGroup);
            }
            this.setBindGroup(i2, bindGroup, shader.gpuProgram);
          }
        }
        _syncBindGroup(bindGroup) {
          for (const j2 in bindGroup.resources) {
            const resource = bindGroup.resources[j2];
            if (resource.isUniformGroup) {
              this._renderer.uniformBuffer.updateUniformGroup(resource);
            }
          }
        }
        draw(options) {
          const { geometry, shader, state, topology, size: size2, start, instanceCount, skipSync } = options;
          this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
          this.setGeometry(geometry);
          this._setShaderBindGroups(shader, skipSync);
          if (geometry.indexBuffer) {
            this.renderPassEncoder.drawIndexed(size2 || geometry.indexBuffer.data.length, instanceCount || 1, start || 0);
          } else {
            this.renderPassEncoder.draw(size2 || geometry.getSize(), instanceCount || 1, start || 0);
          }
        }
        finishRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
            this.renderPassEncoder = null;
          }
        }
        postrender() {
          this.finishRenderPass();
          this._gpu.device.queue.submit([this.commandEncoder.finish()]);
          this._resolveCommandFinished();
        }
        restoreRenderPass() {
          const descriptor = this._renderer.renderTarget.getDescriptor(
            this._renderer.renderTarget.renderTarget,
            false,
            [0, 0, 0, 1]
          );
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
          const boundPipeline = this._boundPipeline;
          const boundVertexBuffer = { ...this._boundVertexBuffer };
          const boundIndexBuffer = this._boundIndexBuffer;
          const boundBindGroup = { ...this._boundBindGroup };
          this._clearCache();
          const viewport = this._renderer.renderTarget.renderTarget.viewport;
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          this.setPipeline(boundPipeline);
          for (const i2 in boundVertexBuffer) {
            this._setVertexBuffer(i2, boundVertexBuffer[i2]);
          }
          for (const i2 in boundBindGroup) {
            this.setBindGroup(i2, boundBindGroup[i2], null);
          }
          this._setIndexBuffer(boundIndexBuffer);
        }
        _clearCache() {
          for (let i2 = 0; i2 < 16; i2++) {
            this._boundBindGroup[i2] = null;
            this._boundVertexBuffer[i2] = null;
          }
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
          this._gpu = null;
          this._boundBindGroup = null;
          this._boundVertexBuffer = null;
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
      };
      GpuEncoderSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "encoder"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
  var GpuStencilSystem;
  var init_GpuStencilSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
      init_Extensions();
      init_const8();
      GpuStencilSystem = class {
        constructor(renderer) {
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(renderTarget) {
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this._activeRenderTarget = renderTarget;
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          const renderer = this._renderer;
          renderer.pipeline.setStencilMode(stencilMode);
          renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
        }
        destroy() {
          this._renderer.renderTarget.onRenderTargetChange.remove(this);
          const writeable = this;
          writeable._renderer = null;
          this._activeRenderTarget = null;
          this._renderTargetStencilState = null;
        }
      };
      GpuStencilSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/BufferResource.mjs
  var BufferResource;
  var init_BufferResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
      init_eventemitter3();
      init_uid();
      BufferResource = class extends eventemitter3_default {
        constructor({ buffer, offset, size: size2 }) {
          super();
          this.uid = uid("buffer");
          this.touched = 0;
          this.resourceType = "bufferResource";
          this.resourceId = uid("buffer");
          this.bufferResource = true;
          this.buffer = buffer;
          this.offset = offset;
          this.size = size2;
          this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
          this.resourceId = uid("buffer");
          this.emit("change", this);
        }
        destroy(destroyBuffer = false) {
          if (destroyBuffer) {
            this.buffer.destroy();
          }
          this.buffer = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/buffer/UniformBufferBatch.mjs
  var UniformBufferBatch;
  var init_UniformBufferBatch = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/buffer/UniformBufferBatch.mjs"() {
      UniformBufferBatch = class {
        constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
          this._minUniformOffsetAlignment = 256;
          this.byteIndex = 0;
          this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
          this.data = new Float32Array(65535);
        }
        clear() {
          this.byteIndex = 0;
        }
        addEmptyGroup(size2) {
          if (size2 > this._minUniformOffsetAlignment / 4) {
            throw new Error(`UniformBufferBatch: array is too large: ${size2 * 4}`);
          }
          const start = this.byteIndex;
          let newSize = start + size2 * 4;
          newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
          if (newSize > this.data.length * 4) {
            throw new Error("UniformBufferBatch: ubo batch got too big");
          }
          this.byteIndex = newSize;
          return start;
        }
        addGroup(array) {
          const offset = this.addEmptyGroup(array.length);
          for (let i2 = 0; i2 < array.length; i2++) {
            this.data[offset / 4 + i2] = array[i2];
          }
          return offset;
        }
        destroy() {
          this._buffer.destroy();
          this._buffer = null;
          this.data = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
  var minUniformOffsetAlignment, GpuUniformBatchPipe;
  var init_GpuUniformBatchPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
      init_Extensions();
      init_Buffer();
      init_BufferResource();
      init_const5();
      init_UniformBufferBatch();
      init_BindGroup();
      minUniformOffsetAlignment = 128;
      GpuUniformBatchPipe = class {
        constructor(renderer) {
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._buffers = [];
          this._bindGroups = [];
          this._bufferResources = [];
          this._renderer = renderer;
          this._batchBuffer = new UniformBufferBatch({ minUniformOffsetAlignment });
          const totalBuffers = 256 / minUniformOffsetAlignment;
          for (let i2 = 0; i2 < totalBuffers; i2++) {
            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
            if (i2 === 0)
              usage |= BufferUsage.COPY_SRC;
            this._buffers.push(new Buffer2({
              data: this._batchBuffer.data,
              usage
            }));
          }
        }
        renderEnd() {
          this._uploadBindGroups();
          this._resetBindGroups();
        }
        _resetBindGroups() {
          for (const i2 in this._bindGroupHash) {
            this._bindGroupHash[i2] = null;
          }
          this._batchBuffer.clear();
        }
        getUniformBindGroup(group, duplicate) {
          if (!duplicate && this._bindGroupHash[group.uid]) {
            return this._bindGroupHash[group.uid];
          }
          this._renderer.uniformBuffer.ensureUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addEmptyGroup(data.length);
          this._renderer.uniformBuffer.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
          this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
          return this._bindGroupHash[group.uid];
        }
        getUniformBufferResource(group) {
          this._renderer.uniformBuffer.updateUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addGroup(data);
          return this._getBufferResource(offset / minUniformOffsetAlignment);
        }
        getArrayBindGroup(data) {
          const offset = this._batchBuffer.addGroup(data);
          return this._getBindGroup(offset / minUniformOffsetAlignment);
        }
        getArrayBufferResource(data) {
          const offset = this._batchBuffer.addGroup(data);
          const index = offset / minUniformOffsetAlignment;
          return this._getBufferResource(index);
        }
        _getBufferResource(index) {
          if (!this._bufferResources[index]) {
            const buffer = this._buffers[index % 2];
            this._bufferResources[index] = new BufferResource({
              buffer,
              offset: (index / 2 | 0) * 256,
              size: minUniformOffsetAlignment
            });
          }
          return this._bufferResources[index];
        }
        _getBindGroup(index) {
          if (!this._bindGroups[index]) {
            const bindGroup = new BindGroup({
              0: this._getBufferResource(index)
            });
            this._bindGroups[index] = bindGroup;
          }
          return this._bindGroups[index];
        }
        _uploadBindGroups() {
          const bufferSystem = this._renderer.buffer;
          const firstBuffer = this._buffers[0];
          firstBuffer.update(this._batchBuffer.byteIndex);
          bufferSystem.updateBuffer(firstBuffer);
          const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
          for (let i2 = 1; i2 < this._buffers.length; i2++) {
            const buffer = this._buffers[i2];
            commandEncoder.copyBufferToBuffer(
              bufferSystem.getGPUBuffer(firstBuffer),
              minUniformOffsetAlignment,
              bufferSystem.getGPUBuffer(buffer),
              0,
              this._batchBuffer.byteIndex
            );
          }
          this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        }
        destroy() {
          for (let i2 = 0; i2 < this._bindGroups.length; i2++) {
            this._bindGroups[i2].destroy();
          }
          this._bindGroups = null;
          this._bindGroupHash = null;
          for (let i2 = 0; i2 < this._buffers.length; i2++) {
            this._buffers[i2].destroy();
          }
          this._buffers = null;
          for (let i2 = 0; i2 < this._bufferResources.length; i2++) {
            this._bufferResources[i2].destroy();
          }
          this._bufferResources = null;
          this._batchBuffer.destroy();
          this._bindGroupHash = null;
          this._renderer = null;
        }
      };
      GpuUniformBatchPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "uniformBatch"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuUniformBufferPipe.mjs
  var UniformBindGroup, GpuUniformBufferPipe;
  var init_GpuUniformBufferPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuUniformBufferPipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_Buffer();
      init_const5();
      init_BindGroup();
      UniformBindGroup = class extends BindGroup {
        constructor() {
          super({
            0: new Buffer2({
              data: new Float32Array(128),
              usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
            })
          });
        }
        get buffer() {
          return this.resources[0];
        }
        get data() {
          return this.resources[0].data;
        }
      };
      GpuUniformBufferPipe = class {
        constructor(renderer) {
          this._activeBindGroups = [];
          this._activeBindGroupIndex = 0;
          this._renderer = renderer;
        }
        getUniformBindGroup(uniformGroup) {
          const renderer = this._renderer;
          renderer.uniformBuffer.ensureUniformGroup(uniformGroup);
          const bindGroup = BigPool.get(UniformBindGroup);
          renderer.uniformBuffer.syncUniformGroup(uniformGroup, bindGroup.data, 0);
          bindGroup.buffer.update(uniformGroup.buffer.data.byteLength);
          this._activeBindGroups[this._activeBindGroupIndex++] = bindGroup;
          return bindGroup;
        }
        renderEnd() {
          for (let i2 = 0; i2 < this._activeBindGroupIndex; i2++) {
            BigPool.return(this._activeBindGroups[i2]);
          }
          this._activeBindGroupIndex = 0;
        }
      };
      GpuUniformBufferPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "uniformBuffer"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
  var GpuStencilModesToPixi;
  var init_GpuStencilModesToPixi = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
      init_const8();
      GpuStencilModesToPixi = [];
      GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
      GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
        format: "stencil8",
        depthCompare: "always",
        depthWriteEnabled: false,
        stencilWriteMask: 0,
        stencilReadMask: 0,
        stencilBack: {
          compare: "always",
          passOp: "keep"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
        format: "stencil8",
        depthCompare: "always",
        depthWriteEnabled: false,
        stencilBack: {
          compare: "always",
          passOp: "increment-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
        format: "stencil8",
        depthCompare: "always",
        depthWriteEnabled: false,
        stencilBack: {
          compare: "always",
          passOp: "increment-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
        format: "stencil8",
        depthCompare: "always",
        depthWriteEnabled: false,
        stencilBack: {
          compare: "always",
          passOp: "decrement-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
        format: "stencil8",
        depthCompare: "always",
        depthWriteEnabled: false,
        stencilWriteMask: 0,
        stencilBack: {
          compare: "equal",
          passOp: "keep"
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
  function getKey(geometryId, programId, stateId, blendModeId, stencilStateId, multiSampleCount, colorMask, topology) {
    return geometryId << 26 | programId << 18 | colorMask << 14 | stateId << 8 | blendModeId << 3 | topology << 1 | stencilStateId << 4 | multiSampleCount;
  }
  var topologyStringToId, PipelineSystem;
  var init_PipelineSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
      init_Extensions();
      init_const8();
      init_createIdFromString();
      init_GpuStencilModesToPixi();
      topologyStringToId = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4
      };
      PipelineSystem = class {
        constructor(renderer) {
          this._moduleCache = /* @__PURE__ */ Object.create(null);
          this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
          this._pipeCache = /* @__PURE__ */ Object.create(null);
          this._colorMask = 15;
          this._multisampleCount = 1;
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.setStencilMode(STENCIL_MODES.DISABLED);
        }
        setMultisampleCount(multisampleCount) {
          this._multisampleCount = multisampleCount;
        }
        setColorMask(colorMask) {
          this._colorMask = colorMask;
        }
        setStencilMode(stencilMode) {
          this._stencilMode = stencilMode;
          this._stencilState = GpuStencilModesToPixi[stencilMode];
        }
        setPipeline(geometry, program, state, passEncoder) {
          const pipeline = this.getPipeline(geometry, program, state);
          passEncoder.setPipeline(pipeline);
        }
        getPipeline(geometry, program, state, topology) {
          if (!geometry._layoutKey) {
            this._generateBufferKey(geometry);
          }
          if (!program._layoutKey) {
            this._generateProgramKey(program);
            this._renderer.shader.createProgramLayout(program);
          }
          topology = topology || geometry.topology;
          const key = getKey(
            geometry._layoutKey,
            program._layoutKey,
            state.data,
            state._blendModeId,
            this._stencilMode,
            this._multisampleCount,
            this._colorMask,
            topologyStringToId[topology]
          );
          if (this._pipeCache[key])
            return this._pipeCache[key];
          this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
          return this._pipeCache[key];
        }
        _createPipeline(geometry, program, state, topology) {
          const device = this._gpu.device;
          const buffers = this._createVertexBufferLayouts(geometry);
          const blendModes = this._renderer.state.getColorTargets(state);
          let depthStencil = this._stencilState;
          depthStencil = GpuStencilModesToPixi[this._stencilMode];
          blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
          const descriptor = {
            vertex: {
              module: this._getModule(program.vertex.source),
              entryPoint: program.vertex.entryPoint,
              buffers
            },
            fragment: {
              module: this._getModule(program.fragment.source),
              entryPoint: program.fragment.entryPoint,
              targets: blendModes
            },
            primitive: {
              topology,
              cullMode: state.cullMode
            },
            layout: program._gpuLayout.pipeline,
            multisample: {
              count: this._multisampleCount
            },
            depthStencil,
            label: `PIXI Pipeline`
          };
          const pipeline = device.createRenderPipeline(descriptor);
          return pipeline;
        }
        _getModule(code) {
          return this._moduleCache[code] || this._createModule(code);
        }
        _createModule(code) {
          const device = this._gpu.device;
          this._moduleCache[code] = device.createShaderModule({
            code
          });
          return this._moduleCache[code];
        }
        _generateProgramKey(program) {
          const { vertex: vertex2, fragment: fragment2 } = program;
          const bigKey = vertex2.source + fragment2.source + vertex2.entryPoint + fragment2.entryPoint;
          program._layoutKey = createIdFromString(bigKey, "program");
          return program._layoutKey;
        }
        _generateBufferKey(geometry) {
          const keyGen = [];
          let index = 0;
          const attributeKeys = Object.keys(geometry.attributes).sort();
          for (let i2 = 0; i2 < attributeKeys.length; i2++) {
            const attribute = geometry.attributes[attributeKeys[i2]];
            keyGen[index++] = attribute.shaderLocation;
            keyGen[index++] = attribute.offset;
            keyGen[index++] = attribute.format;
            keyGen[index++] = attribute.stride;
          }
          const stringKey = keyGen.join("");
          geometry._layoutKey = createIdFromString(stringKey, "geometry");
          return geometry._layoutKey;
        }
        _createVertexBufferLayouts(geometry) {
          if (this._bufferLayoutsCache[geometry._layoutKey]) {
            return this._bufferLayoutsCache[geometry._layoutKey];
          }
          const vertexBuffersLayout = [];
          geometry.buffers.forEach((buffer) => {
            const bufferEntry = {
              arrayStride: 0,
              stepMode: "vertex",
              attributes: []
            };
            const bufferEntryAttributes = bufferEntry.attributes;
            for (const i2 in geometry.attributes) {
              const attribute = geometry.attributes[i2];
              if (attribute.buffer === buffer) {
                bufferEntry.arrayStride = attribute.stride;
                bufferEntryAttributes.push({
                  shaderLocation: attribute.shaderLocation,
                  offset: attribute.offset,
                  format: attribute.format
                });
              }
            }
            if (bufferEntryAttributes.length) {
              vertexBuffersLayout.push(bufferEntry);
            }
          });
          this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;
          return vertexBuffersLayout;
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
          this._bufferLayoutsCache = null;
        }
      };
      PipelineSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "pipeline"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
  function isRenderingToScreen(renderTarget) {
    const resource = renderTarget.colorTexture.source.resource;
    return resource instanceof HTMLCanvasElement && document.body.contains(resource);
  }
  var init_isRenderingToScreen = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
  function calculateProjection(pm, x2, y2, width, height, flipY) {
    const sign = flipY ? 1 : -1;
    pm.identity();
    pm.a = 1 / width * 2;
    pm.d = sign * (1 / height * 2);
    pm.tx = -1 - x2 * pm.a;
    pm.ty = -sign - y2 * pm.d;
    return pm;
  }
  var init_calculateProjection = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
  var _RenderTarget, RenderTarget;
  var init_RenderTarget = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
      init_Matrix();
      init_Rectangle();
      init_uid();
      init_calculateProjection();
      init_TextureSource();
      init_Texture();
      _RenderTarget = class {
        constructor(descriptor = {}) {
          this.uid = uid("renderTarget");
          this.width = 0;
          this.height = 0;
          this.resolution = 1;
          this.colorTextures = [];
          this.dirtyId = 0;
          this.isRoot = false;
          this._projectionMatrix = new Matrix();
          this._size = new Float32Array(2);
          descriptor = { ..._RenderTarget.defaultDescriptor, ...descriptor };
          this.width = descriptor.width;
          this.height = descriptor.height;
          this.resolution = descriptor.resolution;
          this.stencil = descriptor.stencil;
          this._viewport = new Rectangle(0, 0, this.width, this.height);
          if (typeof descriptor.colorTextures === "number") {
            for (let i2 = 0; i2 < descriptor.colorTextures; i2++) {
              this.colorTextures.push(new Texture({
                source: new TextureSource({
                  width: this.width,
                  height: this.height,
                  resolution: descriptor.resolution,
                  antialias: descriptor.antialias
                })
              }));
            }
          } else {
            this.colorTextures = [...descriptor.colorTextures];
            const colorSource = this.colorTexture.source;
            this._resize(colorSource.width, colorSource.height, colorSource._resolution);
          }
          this.colorTexture.source.on("resize", this.onSourceResize, this);
          if (descriptor.depthTexture) {
            this.depthTexture = new Texture({
              source: new TextureSource({
                width: this.width,
                height: this.height,
                resolution: this.resolution,
                format: "stencil8"
              })
            });
          }
        }
        get size() {
          const _size = this._size;
          _size[0] = this.pixelWidth;
          _size[1] = this.pixelHeight;
          return _size;
        }
        get pixelWidth() {
          return this.width * this.resolution;
        }
        get pixelHeight() {
          return this.height * this.resolution;
        }
        get colorTexture() {
          return this.colorTextures[0];
        }
        get projectionMatrix() {
          const texture = this.colorTexture;
          calculateProjection(this._projectionMatrix, 0, 0, texture.frameWidth, texture.frameHeight, !this.isRoot);
          return this._projectionMatrix;
        }
        get viewport() {
          const texture = this.colorTexture;
          const source2 = texture.source;
          const pixelWidth = source2.pixelWidth;
          const pixelHeight = source2.pixelHeight;
          const viewport = this._viewport;
          const frame = texture.layout.frame;
          viewport.x = frame.x * pixelWidth | 0;
          viewport.y = frame.y * pixelHeight | 0;
          viewport.width = frame.width * pixelWidth | 0;
          viewport.height = frame.height * pixelHeight | 0;
          return viewport;
        }
        onSourceResize(source2) {
          this._resize(source2.width, source2.height, source2._resolution, true);
        }
        _resize(width, height, resolution = this.resolution, skipColorTexture = false) {
          this.width = width;
          this.height = height;
          this.resolution = resolution;
          this.dirtyId++;
          this.colorTextures.forEach((colorTexture, i2) => {
            if (skipColorTexture && i2 === 0)
              return;
            colorTexture.source.resize(width, height, resolution);
          });
          if (this.depthTexture) {
            this.depthTexture.source.resize(width, height, resolution);
          }
        }
        destroy() {
          throw new Error("Method not implemented.");
        }
      };
      RenderTarget = _RenderTarget;
      RenderTarget.defaultDescriptor = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: true,
        antialias: false
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
  var GpuRenderTarget;
  var init_GpuRenderTarget = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
      GpuRenderTarget = class {
        constructor() {
          this.contexts = [];
          this.msaaTextures = [];
          this.msaaSamples = 1;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
  var GpuRenderTargetSystem;
  var init_GpuRenderTargetSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_const7();
      init_isRenderingToScreen();
      init_RenderTarget();
      init_SystemRunner();
      init_TextureSource();
      init_Texture();
      init_getCanvasTexture();
      init_GpuRenderTarget();
      GpuRenderTargetSystem = class {
        constructor(renderer) {
          this.rootProjectionMatrix = new Matrix();
          this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
          this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
          this._renderTargetStack = [];
          this._defaultClearColor = [0, 0, 0, 0];
          this._renderer = renderer;
        }
        renderStart({
          target,
          clear,
          clearColor
        }) {
          this.rootRenderTarget = this.getRenderTarget(target);
          this.rootProjectionMatrix = this.rootRenderTarget.projectionMatrix;
          this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
          this._renderTargetStack.length = 0;
          this._renderer.encoder.start();
          this.push(
            this.rootRenderTarget,
            clear,
            clearColor ?? this._renderer.background.colorRgba
          );
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        bind(renderSurface, clear = true, clearColor) {
          const renderTarget = this.getRenderTarget(renderSurface);
          const didChange = this.renderTarget !== renderTarget;
          this.renderTarget = renderTarget;
          this._startRenderPass(clear, clearColor);
          if (didChange) {
            this.onRenderTargetChange.emit(renderTarget);
          }
          return renderTarget;
        }
        _getGpuColorTexture(renderTarget) {
          const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
          if (gpuRenderTarget.contexts[0]) {
            return gpuRenderTarget.contexts[0].getCurrentTexture();
          }
          return this._renderer.texture.getGpuSource(
            renderTarget.colorTextures[0].source
          );
        }
        getDescriptor(renderTarget, clear, clearValue) {
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
          const colorAttachments = renderTarget.colorTextures.map(
            (texture, i2) => {
              const context2 = gpuRenderTarget.contexts[i2];
              let view;
              let resolveTarget;
              if (context2) {
                const currentTexture = context2.getCurrentTexture();
                const canvasTextureView = currentTexture.createView();
                view = canvasTextureView;
              } else {
                view = this._renderer.texture.getTextureView(texture);
              }
              if (gpuRenderTarget.msaaTextures[i2]) {
                resolveTarget = view;
                view = this._renderer.texture.getTextureView(
                  gpuRenderTarget.msaaTextures[i2]
                );
              }
              const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
              clearValue ?? (clearValue = this._defaultClearColor);
              return {
                view,
                resolveTarget,
                clearValue,
                storeOp: "store",
                loadOp
              };
            }
          );
          let depthStencilAttachment;
          if (renderTarget.depthTexture) {
            const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
            depthStencilAttachment = {
              view: this._renderer.texture.getGpuSource(renderTarget.depthTexture.source).createView(),
              stencilStoreOp: "store",
              stencilLoadOp
            };
          }
          const descriptor = {
            colorAttachments,
            depthStencilAttachment
          };
          return descriptor;
        }
        clear(clear = CLEAR.ALL, clearColor) {
          if (!clear)
            return;
          this._startRenderPass(
            clear,
            clearColor
          );
        }
        push(renderSurface, clear = CLEAR.ALL, clearColor) {
          const renderTarget = this.bind(renderSurface, clear, clearColor);
          this._renderTargetStack.push(renderTarget);
          return renderTarget;
        }
        pop() {
          this._renderTargetStack.pop();
          this.bind(
            this._renderTargetStack[this._renderTargetStack.length - 1],
            false
          );
        }
        getRenderTarget(renderSurface) {
          return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, origin, size2) {
          const renderer = this._renderer;
          const baseGpuTexture = renderer.renderTarget._getGpuColorTexture(
            sourceRenderSurfaceTexture
          );
          const backGpuTexture = renderer.texture.getGpuSource(
            destinationTexture.source
          );
          renderer.encoder.commandEncoder.copyTextureToTexture(
            {
              texture: baseGpuTexture,
              origin
            },
            {
              texture: backGpuTexture
            },
            size2
          );
          return destinationTexture;
        }
        restart() {
          this.bind(this.rootRenderTarget, CLEAR.NONE);
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
          this._renderSurfaceToRenderTargetHash.clear();
        }
        _startRenderPass(clear = true, clearColor) {
          const renderTarget = this.renderTarget;
          const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
          if (renderTarget.width !== gpuRenderTarget.width || renderTarget.height !== gpuRenderTarget.height) {
            this._resizeGpuRenderTarget(renderTarget);
          }
          const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
          gpuRenderTarget.descriptor = descriptor;
          this._renderer.encoder.beginRenderPass(renderTarget, gpuRenderTarget);
          this._renderer.pipeline.setMultisampleCount(gpuRenderTarget.msaaSamples);
        }
        _initRenderTarget(renderSurface) {
          let renderTarget = null;
          if (renderSurface instanceof HTMLCanvasElement) {
            renderSurface = getCanvasTexture(renderSurface);
          }
          if (renderSurface instanceof RenderTarget) {
            renderTarget = renderSurface;
          } else if (renderSurface instanceof Texture) {
            renderTarget = new RenderTarget({
              colorTextures: [renderSurface],
              depthTexture: renderSurface.source.depthStencil
            });
          }
          renderTarget.isRoot = true;
          this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
          return renderTarget;
        }
        _getGpuRenderTarget(renderTarget) {
          return this._gpuRenderTargetHash[renderTarget.uid] || this._initGpuRenderTarget(renderTarget);
        }
        _initGpuRenderTarget(renderTarget) {
          renderTarget.isRoot = true;
          const gpuRenderTarget = new GpuRenderTarget();
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            if (colorTexture.source.resource instanceof HTMLCanvasElement) {
              const context2 = renderTarget.colorTexture.source.resource.getContext(
                "webgpu"
              );
              try {
                context2.configure({
                  device: this._gpu.device,
                  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                  format: "bgra8unorm",
                  alphaMode: "opaque"
                });
              } catch (e2) {
                console.error(e2);
              }
              gpuRenderTarget.contexts[i2] = context2;
            }
            gpuRenderTarget.msaa = colorTexture.source.antialias;
            if (colorTexture.source.antialias) {
              const msaaTexture = new TextureSource({
                width: 0,
                height: 0,
                sampleCount: 4
              });
              gpuRenderTarget.msaaTextures[i2] = msaaTexture;
            }
          });
          if (gpuRenderTarget.msaa) {
            gpuRenderTarget.msaaSamples = 4;
            if (renderTarget.depthTexture) {
              renderTarget.depthTexture.source.sampleCount = 4;
            }
          }
          this._gpuRenderTargetHash[renderTarget.uid] = gpuRenderTarget;
          return gpuRenderTarget;
        }
        _resizeGpuRenderTarget(renderTarget) {
          const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.width;
          gpuRenderTarget.height = renderTarget.height;
          if (gpuRenderTarget.msaa) {
            renderTarget.colorTextures.forEach((colorTexture, i2) => {
              const msaaTexture = gpuRenderTarget.msaaTextures[i2];
              msaaTexture?.resize(
                colorTexture.source.width,
                colorTexture.source.height,
                colorTexture.source._resolution
              );
            });
          }
        }
      };
      GpuRenderTargetSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
  var GpuShaderSystem;
  var init_GpuShaderSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
      init_Extensions();
      GpuShaderSystem = class {
        contextChange(gpu) {
          this._gpu = gpu;
        }
        createProgramLayout(program) {
          const device = this._gpu.device;
          if (!program._gpuLayout) {
            if (program.gpuLayout) {
              const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
              const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
              program._gpuLayout = {
                bindGroups,
                pipeline: device.createPipelineLayout(pipelineLayoutDesc)
              };
            } else {
              program._gpuLayout = {
                bindGroups: null,
                pipeline: "auto"
              };
            }
          }
        }
        destroy() {
          this._gpu = null;
        }
      };
      GpuShaderSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
  var GpuBlendModesToPixi;
  var init_GpuBlendModesToPixi = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
      GpuBlendModesToPixi = {};
      GpuBlendModesToPixi.normal = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.add = {
        alpha: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.multiply = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "dst",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.screen = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.overlay = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.none = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "zero",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["normal-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["add-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["screen-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.erase = {
        alpha: {
          srcFactor: "zero",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
  var GpuStateSystem;
  var init_GpuStateSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_GpuBlendModesToPixi();
      GpuStateSystem = class {
        constructor() {
          this.defaultState = new State();
          this.defaultState.blend = true;
        }
        contextChange(gpu) {
          this.gpu = gpu;
        }
        getColorTargets(state) {
          const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
          return [
            {
              format: "bgra8unorm",
              writeMask: 0,
              blend
            }
          ];
        }
        destroy() {
          this.gpu = null;
        }
      };
      GpuStateSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "state"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
  var gpuUploadBufferImageResource;
  var init_gpuUploadBufferImageResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
      gpuUploadBufferImageResource = {
        type: "image",
        upload(source2, gpuTexture, gpu) {
          const resource = source2.resource;
          const total = (source2.pixelWidth | 0) * (source2.pixelHeight | 0);
          const bytesPerPixel = resource.byteLength / total;
          gpu.device.queue.writeTexture(
            { texture: gpuTexture },
            resource,
            {
              offset: 0,
              rowsPerImage: source2.pixelWidth,
              bytesPerRow: source2.pixelWidth * bytesPerPixel
            },
            {
              width: source2.pixelWidth,
              height: source2.pixelHeight,
              depthOrArrayLayers: 1
            }
          );
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
  var gpuUploadImageResource;
  var init_gpuUploadImageSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
      gpuUploadImageResource = {
        type: "image",
        upload(source2, gpuTexture, gpu) {
          const resource = source2.resource;
          if (!resource)
            return;
          const width = source2.resourceWidth || source2.pixelWidth;
          const height = source2.resourceHeight || source2.pixelHeight;
          const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
          gpu.device.queue.copyExternalImageToTexture(
            { source: resource },
            { texture: gpuTexture, premultipliedAlpha },
            {
              width,
              height
            }
          );
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
  var gpuUploadVideoResource;
  var init_gpuUploadVideoSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
      init_gpuUploadImageSource();
      gpuUploadVideoResource = {
        type: "video",
        upload(source2, gpuTexture, gpu) {
          gpuUploadImageResource.upload(source2, gpuTexture, gpu);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
  var GpuMipmapGenerator;
  var init_GpuMipmapGenerator = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
      GpuMipmapGenerator = class {
        constructor(device) {
          this.device = device;
          this.sampler = device.createSampler({ minFilter: "linear" });
          this.pipelines = {};
        }
        _getMipmapPipeline(format) {
          let pipeline = this.pipelines[format];
          if (!pipeline) {
            if (!this.mipmapShaderModule) {
              this.mipmapShaderModule = this.device.createShaderModule({
                code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
              });
            }
            pipeline = this.device.createRenderPipeline({
              layout: "auto",
              vertex: {
                module: this.mipmapShaderModule,
                entryPoint: "vertexMain"
              },
              fragment: {
                module: this.mipmapShaderModule,
                entryPoint: "fragmentMain",
                targets: [{ format }]
              }
            });
            this.pipelines[format] = pipeline;
          }
          return pipeline;
        }
        generateMipmap(texture) {
          const pipeline = this._getMipmapPipeline(texture.format);
          if (texture.dimension === "3d" || texture.dimension === "1d") {
            throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
          }
          let mipTexture = texture;
          const arrayLayerCount = texture.depthOrArrayLayers || 1;
          const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
          if (!renderToSource) {
            const mipTextureDescriptor = {
              size: {
                width: Math.ceil(texture.width / 2),
                height: Math.ceil(texture.height / 2),
                depthOrArrayLayers: arrayLayerCount
              },
              format: texture.format,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
              mipLevelCount: texture.mipLevelCount - 1
            };
            mipTexture = this.device.createTexture(mipTextureDescriptor);
          }
          const commandEncoder = this.device.createCommandEncoder({});
          const bindGroupLayout = pipeline.getBindGroupLayout(0);
          for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
            let srcView = texture.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            let dstMipLevel = renderToSource ? 1 : 0;
            for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
              const dstView = mipTexture.createView({
                baseMipLevel: dstMipLevel++,
                mipLevelCount: 1,
                dimension: "2d",
                baseArrayLayer: arrayLayer,
                arrayLayerCount: 1
              });
              const passEncoder = commandEncoder.beginRenderPass({
                colorAttachments: [{
                  view: dstView,
                  storeOp: "store",
                  loadOp: "clear",
                  clearValue: { r: 0, g: 0, b: 0, a: 0 }
                }]
              });
              const bindGroup = this.device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{
                  binding: 0,
                  resource: this.sampler
                }, {
                  binding: 1,
                  resource: srcView
                }]
              });
              passEncoder.setPipeline(pipeline);
              passEncoder.setBindGroup(0, bindGroup);
              passEncoder.draw(3, 1, 0, 0);
              passEncoder.end();
              srcView = dstView;
            }
          }
          if (!renderToSource) {
            const mipLevelSize = {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            };
            for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
              commandEncoder.copyTextureToTexture({
                texture: mipTexture,
                mipLevel: i2 - 1
              }, {
                texture,
                mipLevel: i2
              }, mipLevelSize);
              mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
              mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
            }
          }
          this.device.queue.submit([commandEncoder.finish()]);
          if (!renderToSource) {
            mipTexture.destroy();
          }
          return texture;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
  var GpuTextureSystem;
  var init_GpuTextureSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
      init_Extensions();
      init_settings();
      init_CanvasPool();
      init_BindGroup();
      init_gpuUploadBufferImageResource();
      init_gpuUploadImageSource();
      init_gpuUploadVideoSource();
      init_GpuMipmapGenerator();
      GpuTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._gpuSources = /* @__PURE__ */ Object.create(null);
          this._gpuSamplers = /* @__PURE__ */ Object.create(null);
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._textureViewHash = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: gpuUploadImageResource,
            buffer: gpuUploadBufferImageResource,
            video: gpuUploadVideoResource
          };
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        initSource(source2) {
          if (source2.autoGenerateMipmaps) {
            const biggestDimension = Math.max(source2.pixelWidth, source2.pixelHeight);
            source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          const textureDescriptor = {
            size: { width: source2.pixelWidth || 1, height: source2.pixelHeight || 1 },
            format: source2.format,
            sampleCount: source2.sampleCount,
            mipLevelCount: source2.mipLevelCount,
            dimension: source2.dimension,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
          };
          const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
          this._gpuSources[source2.uid] = gpuTexture;
          source2.on("update", this.onSourceUpdate, this);
          source2.on("resize", this.onSourceResize, this);
          source2.on("destroy", this.onSourceDestroy, this);
          source2.on("unload", this.onSourceUnload, this);
          this.managedTextures.push(source2);
          this.onSourceUpdate(source2);
          return gpuTexture;
        }
        onSourceUpdate(source2) {
          const gpuTexture = this.getGpuSource(source2);
          if (!gpuTexture)
            return;
          if (this._uploads[source2.uploadMethodId]) {
            this._uploads[source2.uploadMethodId].upload(source2, gpuTexture, this._gpu);
          }
          if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
            if (!this._mipmapGenerator) {
              this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
            }
            this._mipmapGenerator.generateMipmap(gpuTexture);
          }
        }
        onSourceUnload(source2) {
          const gpuTexture = this._gpuSources[source2.uid];
          if (gpuTexture) {
            this._gpuSources[source2.uid] = null;
            gpuTexture.destroy();
          }
        }
        onSourceDestroy(source2) {
          source2.off("update", this.onSourceUpdate, this);
          source2.off("unload", this.onSourceUnload, this);
          source2.off("destroy", this.onSourceDestroy, this);
          source2.off("resize", this.onSourceResize, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
          this.onSourceUnload(source2);
        }
        onSourceResize(source2) {
          const gpuTexture = this._gpuSources[source2.uid];
          if (gpuTexture.width !== source2.pixelWidth || gpuTexture.height !== source2.pixelHeight) {
            this._textureViewHash[source2.uid] = null;
            this._bindGroupHash[source2.uid] = null;
            this.onSourceUnload(source2);
            this.initSource(source2);
          }
        }
        _initSampler(sampler) {
          this._gpuSamplers[sampler.resourceId] = this._gpu.device.createSampler(sampler);
          return this._gpuSamplers[sampler.resourceId];
        }
        getGpuSampler(sampler) {
          return this._gpuSamplers[sampler.resourceId] || this._initSampler(sampler);
        }
        getGpuSource(source2) {
          return this._gpuSources[source2.uid] || this.initSource(source2);
        }
        getTextureBindGroup(texture) {
          return this._bindGroupHash[texture.id] ?? this._createTextureBindGroup(texture);
        }
        _createTextureBindGroup(texture) {
          const source2 = texture.source;
          const bindGroupId = source2.uid;
          this._bindGroupHash[bindGroupId] = new BindGroup({
            0: source2,
            1: source2.style
          });
          return this._bindGroupHash[bindGroupId];
        }
        getTextureView(texture) {
          const source2 = texture.source;
          return this._textureViewHash[source2.uid] ?? this._createTextureView(source2);
        }
        _createTextureView(texture) {
          this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
          return this._textureViewHash[texture.uid];
        }
        generateCanvas(texture) {
          const renderer = this._renderer;
          const commandEncoder = renderer.gpu.device.createCommandEncoder();
          const canvas2 = settings.ADAPTER.createCanvas();
          canvas2.width = texture.source.pixelWidth;
          canvas2.height = texture.source.pixelHeight;
          const context2 = canvas2.getContext("webgpu");
          context2.configure({
            device: renderer.gpu.device,
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: "bgra8unorm",
            alphaMode: "premultiplied"
          });
          commandEncoder.copyTextureToTexture({
            texture: renderer.texture.getGpuSource(texture.source),
            origin: {
              x: 0,
              y: 0
            }
          }, {
            texture: context2.getCurrentTexture()
          }, {
            width: canvas2.width,
            height: canvas2.height
          });
          renderer.gpu.device.queue.submit([commandEncoder.finish()]);
          return canvas2;
        }
        getPixels(texture) {
          const webGPUCanvas = this.generateCanvas(texture);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
          const context2 = canvasAndContext.context;
          context2.drawImage(webGPUCanvas, 0, 0);
          const { width, height } = webGPUCanvas;
          const imageData = context2.getImageData(0, 0, width, height);
          const pixels = new Uint8ClampedArray(imageData.data.buffer);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return { pixels, width, height };
        }
        destroy() {
          for (const k2 of Object.keys(this._gpuSources)) {
            const key = Number(k2);
            const gpuTexture = this._gpuSources[key];
            gpuTexture.destroy();
            this._gpuSources[key] = null;
          }
          for (const k2 of Object.keys(this._bindGroupHash)) {
            const key = Number(k2);
            const bindGroup = this._bindGroupHash[key];
            bindGroup.destroy();
            this._bindGroupHash[key] = null;
          }
          this._gpu = null;
          this._mipmapGenerator = null;
          this._gpuSources = null;
          this._bindGroupHash = null;
          this._textureViewHash = null;
          this._gpuSamplers = null;
        }
      };
      GpuTextureSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/WebGPURenderer.mjs
  var WebGPURenderer_exports = {};
  __export(WebGPURenderer_exports, {
    WebGPURenderer: () => WebGPURenderer
  });
  var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
  var init_WebGPURenderer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
      init_Extensions();
      init_GpuGraphicsAdaptor();
      init_GpuMeshAdapter();
      init_GpuBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types();
      init_BindGroupSystem();
      init_GpuBufferSystem();
      init_GpuColorMaskSystem();
      init_GpuDeviceSystem();
      init_GpuEncoderSystem();
      init_GpuStencilSystem();
      init_GpuUniformBatchPipe();
      init_GpuUniformBufferPipe();
      init_PipelineSystem();
      init_GpuRenderTargetSystem();
      init_GpuShaderSystem();
      init_GpuStateSystem();
      init_GpuTextureSystem();
      DefaultWebGPUSystems = [
        ...SharedSystems,
        GpuDeviceSystem,
        BufferSystem,
        GpuTextureSystem,
        GpuRenderTargetSystem,
        GpuEncoderSystem,
        GpuShaderSystem,
        GpuStateSystem,
        PipelineSystem,
        GpuColorMaskSystem,
        GpuStencilSystem,
        BindGroupSystem
      ];
      DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe, GpuUniformBufferPipe];
      DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
      systems = [];
      renderPipes = [];
      renderPipeAdaptors = [];
      extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
      extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
      extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
      extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
      WebGPURenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgpu",
            type: RendererType.WEBGPU,
            systems,
            renderPipes,
            renderPipeAdaptors
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
  var GlGraphicsAdaptor;
  var init_GlGraphicsAdaptor = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_const3();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_batchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      GlGraphicsAdaptor = class {
        init() {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
          });
          const glProgram = compileHighShaderGlProgram({
            name: "graphics",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(MAX_TEXTURES),
              localUniformBitGl,
              roundPixelsBitGl
            ]
          });
          this.shader = new Shader({
            glProgram,
            resources: {
              localUniforms: uniforms,
              batchSamplers: batchSamplersUniformGroup
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context2 = renderable.view.context;
          const shader = context2.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            geometry,
            instructions
          } = contextSystem.getContextRenderData(context2);
          renderer.shader.bind(shader);
          renderer.shader.bindUniformBlock(renderer.globalUniforms.uniformGroup, "globalUniforms");
          renderer.geometry.bind(geometry, shader.glProgram);
          const batches = instructions.instructions;
          for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
            const batch = batches[i2];
            if (batch.size) {
              for (let j2 = 0; j2 < batch.textures.textures.length; j2++) {
                renderer.texture.bind(batch.textures.textures[j2], j2);
              }
              renderer.geometry.draw("triangle-list", batch.size, batch.start);
            }
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GlGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/gl/GlMeshAdaptor.mjs
  var GlMeshAdaptor;
  var init_GlMeshAdaptor = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
      init_Extensions();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      GlMeshAdaptor = class {
        init() {
          const glProgram = compileHighShaderGlProgram({
            name: "mesh",
            bits: [
              localUniformBitGl,
              textureBitGl,
              roundPixelsBitGl
            ]
          });
          this._shader = new Shader({
            glProgram,
            resources: {
              uTexture: Texture.EMPTY.source
            }
          });
          this._shader.addResource("globalUniforms", 0, 0);
          this._shader.addResource("localUniforms", 1, 0);
        }
        execute(meshPipe, renderable) {
          const renderer = meshPipe.renderer;
          const view = renderable.view;
          let shader = view._shader;
          if (!shader) {
            shader = this._shader;
            const source2 = view.texture.source;
            shader.resources.uTexture = source2;
            shader.resources.uSampler = source2.style;
          }
          shader.groups[0] = renderer.globalUniforms.bindGroup;
          shader.groups[1] = meshPipe.localUniformsBindGroup;
          renderer.encoder.draw({
            geometry: view._geometry,
            shader,
            state: view.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GlMeshAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
  var GlBatchAdaptor;
  var init_GlBatchAdaptor = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_batchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      init_State();
      init_const3();
      GlBatchAdaptor = class {
        constructor() {
          this._didUpload = false;
          this._tempState = State.for2d();
        }
        init() {
          const uniforms = new UniformGroup({
            tint: { value: new Float32Array([1, 1, 1, 1]), type: "f32" },
            translationMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
          });
          const glProgram = compileHighShaderGlProgram({
            name: "batch",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(MAX_TEXTURES),
              roundPixelsBitGl
            ]
          });
          this._shader = new Shader({
            glProgram,
            resources: {
              uniforms,
              batchSamplers: batchSamplersUniformGroup
            }
          });
        }
        start(batchPipe, geometry) {
          const renderer = batchPipe.renderer;
          renderer.shader.bind(this._shader, this._didUpload);
          renderer.shader.bindUniformBlock(renderer.globalUniforms.uniformGroup, "globalUniforms", 0);
          renderer.geometry.bind(geometry, this._shader.glProgram);
        }
        execute(batchPipe, batch) {
          const renderer = batchPipe.renderer;
          this._didUpload = true;
          this._tempState.blendMode = batch.blendMode;
          renderer.state.set(this._tempState);
          const textures = batch.textures.textures;
          for (let i2 = 0; i2 < textures.length; i2++) {
            renderer.texture.bind(textures[i2], i2);
          }
          renderer.geometry.draw("triangle-list", batch.size, batch.start);
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GlBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/const.mjs
  var BUFFER_TYPE;
  var init_const9 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/const.mjs"() {
      BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
        BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
        return BUFFER_TYPE2;
      })(BUFFER_TYPE || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
  var GlBuffer;
  var init_GlBuffer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
      GlBuffer = class {
        constructor(buffer, type) {
          this.buffer = buffer || null;
          this.updateID = -1;
          this.byteLength = -1;
          this.type = type;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
  var GlBufferSystem;
  var init_GlBufferSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
      init_Extensions();
      init_const5();
      init_const9();
      init_GlBuffer();
      GlBufferSystem = class {
        constructor(renderer) {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._boundBufferBases = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        destroy() {
          const writeable = this;
          this.destroyAll(true);
          this._renderer = null;
          this._gl = null;
          this._gpuBuffers = null;
          writeable._boundBufferBases = null;
        }
        contextChange() {
          this.destroyAll(true);
          this._gl = this._renderer.gl;
        }
        getGlBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
        }
        bind(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        }
        bindBufferBase(buffer, index) {
          const { _gl: gl } = this;
          if (this._boundBufferBases[index] !== buffer) {
            const glBuffer = this.getGlBuffer(buffer);
            this._boundBufferBases[index] = buffer;
            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
          }
        }
        bindBufferRange(buffer, index, offset) {
          const { _gl: gl } = this;
          offset = offset || 0;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
        }
        updateBuffer(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          if (buffer._updateID === glBuffer.updateID) {
            return glBuffer;
          }
          glBuffer.updateID = buffer._updateID;
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
          if (glBuffer.byteLength >= buffer.data.byteLength) {
            gl.bufferSubData(glBuffer.type, 0, buffer.data, 0, buffer._updateSize / 4);
          } else {
            const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
            glBuffer.byteLength = buffer.data.byteLength;
            gl.bufferData(glBuffer.type, buffer.data, drawType);
          }
          return glBuffer;
        }
        destroyAll(contextLost) {
          const gl = this._gl;
          if (!contextLost) {
            for (const id in this._gpuBuffers) {
              gl.deleteBuffer(this._gpuBuffers[id].buffer);
            }
          }
          this._gpuBuffers = {};
        }
        onBufferDestroy(buffer, contextLost) {
          const glBuffer = this._gpuBuffers[buffer.uid];
          const gl = this._gl;
          if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
          }
          this._gpuBuffers[buffer.uid] = null;
        }
        createGLBuffer(buffer) {
          const { _gl: gl } = this;
          let type = BUFFER_TYPE.ARRAY_BUFFER;
          if (buffer.descriptor.usage & BufferUsage.INDEX) {
            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
          } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
            type = BUFFER_TYPE.UNIFORM_BUFFER;
          }
          const glBuffer = new GlBuffer(gl.createBuffer(), type);
          this._gpuBuffers[buffer.uid] = glBuffer;
          buffer.on("destroy", this.onBufferDestroy, this);
          return glBuffer;
        }
      };
      GlBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/context/GlContextSystem.mjs
  var GlContextSystem;
  var init_GlContextSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
      init_Extensions();
      init_warn();
      GlContextSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
          this.webGLVersion = 1;
          this.extensions = /* @__PURE__ */ Object.create(null);
          this.supports = {
            uint32Indices: false
          };
          this.handleContextLost = this.handleContextLost.bind(this);
          this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        get isLost() {
          return !this.gl || this.gl.isContextLost();
        }
        contextChange(gl) {
          this.gl = gl;
          this._renderer.gl = gl;
          if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
            gl.getExtension("WEBGL_lose_context").restoreContext();
          }
        }
        init(options) {
          if (options?.context) {
            this.initFromContext(options.context);
          } else {
            const alpha = this._renderer.background.alpha < 1;
            const premultipliedAlpha = options.premultipliedAlpha ?? true;
            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
            this.initFromOptions({
              alpha,
              premultipliedAlpha,
              antialias,
              stencil: true,
              preserveDrawingBuffer: options.preserveDrawingBuffer,
              powerPreference: options.powerPreference
            });
          }
        }
        initFromContext(gl) {
          this.gl = gl;
          this.validateContext(gl);
          this._renderer.runners.contextChange.emit(gl);
          const element = this._renderer.view.canvas;
          element.addEventListener("webglcontextlost", this.handleContextLost, false);
          element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
        }
        initFromOptions(options) {
          const gl = this.createContext(this._renderer.view.canvas, options);
          this.initFromContext(gl);
        }
        createContext(canvas2, options) {
          const gl = canvas2.getContext("webgl2", options);
          this.webGLVersion = 2;
          this.gl = gl;
          this.getExtensions();
          return this.gl;
        }
        getExtensions() {
          const { gl } = this;
          const common = {
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc")
          };
          Object.assign(this.extensions, common, {
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
          });
        }
        handleContextLost(event) {
          event.preventDefault();
        }
        handleContextRestored() {
          this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
          const element = this._renderer.view.canvas;
          this._renderer = null;
          element.removeEventListener("webglcontextlost", this.handleContextLost);
          element.removeEventListener("webglcontextrestored", this.handleContextRestored);
          this.gl.useProgram(null);
          if (this.extensions.loseContext) {
            this.extensions.loseContext.loseContext();
          }
        }
        validateContext(gl) {
          const attributes = gl.getContextAttributes();
          const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
          if (isWebGl2) {
            this.webGLVersion = 2;
          }
          if (attributes && !attributes.stencil) {
            warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          }
          const hasUint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
          this.supports.uint32Indices = hasUint32;
          if (!hasUint32) {
            warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
          }
        }
      };
      GlContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "context"
      };
      GlContextSystem.defaultOptions = {
        context: null,
        premultipliedAlpha: true,
        preserveDrawingBuffer: false,
        powerPreference: "default"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/const.mjs
  var GL_FORMATS, GL_TARGETS, GL_TYPES;
  var init_const10 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/const.mjs"() {
      GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
        GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
        GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
        GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
        GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
        GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
        GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
        GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
        GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
        return GL_FORMATS2;
      })(GL_FORMATS || {});
      GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
        return GL_TARGETS2;
      })(GL_TARGETS || {});
      GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
        GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
        GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
        GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
        GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
        GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
        GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
        GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
        return GL_TYPES2;
      })(GL_TYPES || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/geometry/utils/getGlInfoFromFormat.mjs
  function getGlInfoFromFormat(format) {
    return infoMap[format] ?? infoMap.float32;
  }
  var infoMap;
  var init_getGlInfoFromFormat = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/geometry/utils/getGlInfoFromFormat.mjs"() {
      init_const10();
      infoMap = {
        uint8x2: { type: GL_TYPES.UNSIGNED_BYTE, size: 2, normalised: false },
        uint8x4: { type: GL_TYPES.UNSIGNED_BYTE, size: 4, normalised: false },
        sint8x2: { type: GL_TYPES.BYTE, size: 2, normalised: false },
        sint8x4: { type: GL_TYPES.BYTE, size: 4, normalised: false },
        unorm8x2: { type: GL_TYPES.UNSIGNED_BYTE, size: 2, normalised: true },
        unorm8x4: { type: GL_TYPES.UNSIGNED_BYTE, size: 4, normalised: true },
        snorm8x2: { type: GL_TYPES.BYTE, size: 2, normalised: true },
        snorm8x4: { type: GL_TYPES.BYTE, size: 4, normalised: true },
        uint16x2: { type: GL_TYPES.UNSIGNED_SHORT, size: 2, normalised: false },
        uint16x4: { type: GL_TYPES.UNSIGNED_SHORT, size: 4, normalised: false },
        sint16x2: { type: GL_TYPES.SHORT, size: 2, normalised: false },
        sint16x4: { type: GL_TYPES.SHORT, size: 4, normalised: false },
        unorm16x2: { type: GL_TYPES.UNSIGNED_SHORT, size: 2, normalised: true },
        unorm16x4: { type: GL_TYPES.UNSIGNED_SHORT, size: 4, normalised: true },
        snorm16x2: { type: GL_TYPES.SHORT, size: 2, normalised: true },
        snorm16x4: { type: GL_TYPES.SHORT, size: 4, normalised: true },
        float16x2: { type: GL_TYPES.HALF_FLOAT, size: 2, normalised: false },
        float16x4: { type: GL_TYPES.HALF_FLOAT, size: 4, normalised: false },
        float32: { type: GL_TYPES.FLOAT, size: 1, normalised: false },
        float32x2: { type: GL_TYPES.FLOAT, size: 2, normalised: false },
        float32x3: { type: GL_TYPES.FLOAT, size: 3, normalised: false },
        float32x4: { type: GL_TYPES.FLOAT, size: 4, normalised: false },
        uint32: { type: GL_TYPES.UNSIGNED_INT, size: 1, normalised: false },
        uint32x2: { type: GL_TYPES.UNSIGNED_INT, size: 2, normalised: false },
        uint32x3: { type: GL_TYPES.UNSIGNED_INT, size: 3, normalised: false },
        uint32x4: { type: GL_TYPES.UNSIGNED_INT, size: 4, normalised: false },
        sint32: { type: GL_TYPES.INT, size: 1, normalised: false },
        sint32x2: { type: GL_TYPES.INT, size: 2, normalised: false },
        sint32x3: { type: GL_TYPES.INT, size: 3, normalised: false },
        sint32x4: { type: GL_TYPES.INT, size: 4, normalised: false }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
  var byteSizeMap, topologyToGlMap, GlGeometrySystem;
  var init_GlGeometrySystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
      init_Extensions();
      init_warn();
      init_getGlInfoFromFormat();
      byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
      topologyToGlMap = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
      };
      GlGeometrySystem = class {
        constructor(renderer) {
          this._geometryVaoHash = {};
          this._renderer = renderer;
          this._activeGeometry = null;
          this._activeVao = null;
          this.hasVao = true;
          this.hasInstance = true;
          this.canUseUInt32ElementIndex = true;
        }
        contextChange() {
          this.gl = this._renderer.gl;
        }
        bind(geometry, program) {
          const gl = this.gl;
          this._activeGeometry = geometry;
          const vao = this.getVao(geometry, program);
          if (this._activeVao !== vao) {
            this._activeVao = vao;
            gl.bindVertexArray(vao);
          }
          this.updateBuffers();
        }
        reset() {
          this.unbind();
        }
        updateBuffers() {
          const geometry = this._activeGeometry;
          const bufferSystem = this._renderer.buffer;
          for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
            const buffer = geometry.buffers[i2];
            bufferSystem.updateBuffer(buffer);
          }
        }
        checkCompatibility(geometry, program) {
          const geometryAttributes = geometry.attributes;
          const shaderAttributes = program.attributeData;
          for (const j2 in shaderAttributes) {
            if (!geometryAttributes[j2]) {
              throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
            }
          }
        }
        getSignature(geometry, program) {
          const attribs = geometry.attributes;
          const shaderAttributes = program.attributeData;
          const strings = ["g", geometry.uid];
          for (const i2 in attribs) {
            if (shaderAttributes[i2]) {
              strings.push(i2, shaderAttributes[i2].location);
            }
          }
          return strings.join("-");
        }
        getVao(geometry, program) {
          return this._geometryVaoHash[geometry.uid]?.[program.key] || this.initGeometryVao(geometry, program);
        }
        initGeometryVao(geometry, program, _incRefCount = true) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          this._renderer.shader.getProgramData(program);
          this.checkCompatibility(geometry, program);
          const signature = this.getSignature(geometry, program);
          if (!this._geometryVaoHash[geometry.uid]) {
            this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
            geometry.on("destroy", this.onGeometryDestroy, this);
          }
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          let vao = vaoObjectHash[signature];
          if (vao) {
            vaoObjectHash[program.key] = vao;
            return vao;
          }
          const buffers = geometry.buffers;
          const attributes = geometry.attributes;
          const tempStride = {};
          const tempStart = {};
          for (const j2 in buffers) {
            tempStride[j2] = 0;
            tempStart[j2] = 0;
          }
          for (const j2 in attributes) {
            if (!attributes[j2].size && program.attributeData[j2]) {
              attributes[j2].size = program.attributeData[j2].size;
            } else if (!attributes[j2].size) {
              warn(`PIXI Geometry attribute '${j2}' size cannot be determined (likely the bound shader does not have the attribute)`);
            }
            tempStride[attributes[j2].buffer.uid] += attributes[j2].size * byteSizeMap[attributes[j2].type];
          }
          for (const j2 in attributes) {
            const attribute = attributes[j2];
            const attribSize = attribute.size;
            if (attribute.stride === void 0) {
              if (tempStride[attribute.buffer.uid] === attribSize * byteSizeMap[attribute.type]) {
                attribute.stride = 0;
              } else {
                attribute.stride = tempStride[attribute.buffer.uid];
              }
            }
            if (attribute.start === void 0) {
              attribute.start = tempStart[attribute.buffer.uid];
              tempStart[attribute.buffer.uid] += attribSize * byteSizeMap[attribute.type];
            }
          }
          vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          for (let i2 = 0; i2 < buffers.length; i2++) {
            const buffer = buffers[i2];
            bufferSystem.bind(buffer);
          }
          this.activateVao(geometry, program);
          vaoObjectHash[program.key] = vao;
          vaoObjectHash[signature] = vao;
          gl.bindVertexArray(null);
          return vao;
        }
        onGeometryDestroy(geometry, contextLost) {
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          const gl = this.gl;
          if (vaoObjectHash) {
            if (contextLost) {
              for (const i2 in vaoObjectHash) {
                if (this._activeVao !== vaoObjectHash[i2]) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[i2]);
              }
            }
            this._geometryVaoHash[geometry.uid] = null;
          }
        }
        destroyAll(contextLost = false) {
          const gl = this.gl;
          for (const i2 in this._geometryVaoHash) {
            if (contextLost) {
              for (const j2 in this._geometryVaoHash[i2]) {
                const vaoObjectHash = this._geometryVaoHash[i2];
                if (this._activeVao !== vaoObjectHash) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[j2]);
              }
            }
            this._geometryVaoHash[i2] = null;
          }
        }
        activateVao(geometry, program) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          const attributes = geometry.attributes;
          if (geometry.indexBuffer) {
            bufferSystem.bind(geometry.indexBuffer);
          }
          let lastBuffer = null;
          for (const j2 in attributes) {
            const attribute = attributes[j2];
            const buffer = attribute.buffer;
            const glBuffer = bufferSystem.getGlBuffer(buffer);
            if (program.attributeData[j2]) {
              if (lastBuffer !== glBuffer) {
                bufferSystem.bind(buffer);
                lastBuffer = glBuffer;
              }
              const location = program.attributeData[j2].location;
              gl.enableVertexAttribArray(location);
              const glInfo = getGlInfoFromFormat(attribute.format);
              gl.vertexAttribPointer(
                location,
                glInfo.size,
                glInfo.type,
                glInfo.normalised,
                attribute.stride,
                attribute.offset
              );
              if (attribute.instance) {
                if (this.hasInstance) {
                  gl.vertexAttribDivisor(location, 1);
                } else {
                  throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
              }
            }
          }
        }
        draw(topology, size2, start, instanceCount) {
          const { gl } = this._renderer;
          const geometry = this._activeGeometry;
          const glTopology = topologyToGlMap[geometry.topology || topology];
          if (geometry.indexBuffer) {
            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
            if (geometry.instanced) {
              gl.drawElementsInstanced(glTopology, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, geometry.instanceCount || 1);
            } else {
              gl.drawElements(glTopology, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else if (geometry.instanced) {
            gl.drawArraysInstanced(glTopology, start, size2 || geometry.getSize(), instanceCount || 1);
          } else {
            gl.drawArrays(glTopology, start, size2 || geometry.getSize());
          }
          return this;
        }
        unbind() {
          this.gl.bindVertexArray(null);
          this._activeVao = null;
          this._activeGeometry = null;
        }
        destroy() {
          this._renderer = null;
          this.gl = null;
          this._activeVao = null;
          this._activeGeometry = null;
        }
      };
      GlGeometrySystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "geometry"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
  var bigTriangleProgram, bigTriangleShader, _GlBackBufferSystem, GlBackBufferSystem;
  var init_GlBackBufferSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
      init_Extensions();
      init_Shader();
      init_State();
      init_TextureSource();
      init_Texture();
      init_GlProgram();
      bigTriangleProgram = new GlProgram({
        vertex: `
        out vec2 vUv;

        void main() {
            vUv = vec2((gl_VertexID << 1) & 2, (gl_VertexID & 2));

            gl_Position = vec4(vUv * 2.0f + -1.0f, 0.0f, 1.0f);

            // flip dem UVs
            vUv.y = 1.0f - vUv.y;
        }`,
        fragment: `
        in vec2 vUv;
        out vec4 fragColor;

        uniform sampler2D uTexture;

        void main() {
            fragColor = texture(uTexture, vUv);
        }`,
        name: "big-triangle"
      });
      bigTriangleShader = new Shader({
        glProgram: bigTriangleProgram,
        resources: {
          uTexture: Texture.WHITE.source
        }
      });
      _GlBackBufferSystem = class {
        constructor(renderer) {
          this.useBackBuffer = false;
          this._useBackBufferThisRender = false;
          this._renderer = renderer;
        }
        init(options = {}) {
          const { useBackBuffer, antialias } = { ..._GlBackBufferSystem.defaultOptions, ...options };
          this.useBackBuffer = useBackBuffer;
          this._antialias = antialias;
        }
        renderStart({ target, clear, clearColor }) {
          this._useBackBufferThisRender = this.useBackBuffer && !!target;
          if (this.useBackBuffer) {
            const renderTarget = this._renderer.renderTarget.getRenderTarget(target);
            this._targetTexture = renderTarget.colorTexture;
            target = this._getBackBufferTexture(renderTarget.colorTexture);
          }
          clearColor ?? (clearColor = this._renderer.background.colorRgba);
          this._renderer.renderTarget.start(target, clear, clearColor);
        }
        renderEnd() {
          this._presentBackBuffer();
        }
        _presentBackBuffer() {
          const renderer = this._renderer;
          renderer.renderTarget.finishRenderPass();
          if (!this._useBackBufferThisRender)
            return;
          const gl = renderer.gl;
          renderer.renderTarget.bind(this._targetTexture, false);
          bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
          renderer.shader.bind(bigTriangleShader, false);
          renderer.state.set(State.for2d());
          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }
        _getBackBufferTexture(targetTexture) {
          const source2 = targetTexture.source;
          this._backBufferTexture = this._backBufferTexture || new Texture({
            source: new TextureSource({
              width: source2.width,
              height: source2.height,
              resolution: source2._resolution,
              antialias: this._antialias
            })
          });
          this._backBufferTexture.source.resize(
            source2.width,
            source2.height,
            source2._resolution
          );
          return this._backBufferTexture;
        }
        destroy() {
          if (this._backBufferTexture) {
            this._backBufferTexture.destroy();
            this._backBufferTexture = null;
          }
        }
      };
      GlBackBufferSystem = _GlBackBufferSystem;
      GlBackBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "backBuffer"
      };
      GlBackBufferSystem.defaultOptions = {
        useBackBuffer: false
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
  var GlColorMaskSystem;
  var init_GlColorMaskSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
      init_Extensions();
      GlColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.gl.colorMask(
            !!(colorMask & 8),
            !!(colorMask & 4),
            !!(colorMask & 2),
            !!(colorMask & 1)
          );
        }
      };
      GlColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlEncoderSystem.mjs
  var GlEncoderSystem;
  var init_GlEncoderSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
      init_Extensions();
      GlEncoderSystem = class {
        constructor(renderer) {
          this.commandFinished = Promise.resolve();
          this._renderer = renderer;
        }
        setGeometry(geometry, shader) {
          this._renderer.geometry.bind(geometry, shader.glProgram);
        }
        finishRenderPass() {
        }
        draw(options) {
          const renderer = this._renderer;
          const { geometry, shader, state, skipSync, topology: type, size: size2, start, instanceCount } = options;
          renderer.shader.bind(shader, skipSync);
          renderer.geometry.bind(geometry, renderer.shader.activeProgram);
          if (state) {
            renderer.state.set(state);
          }
          renderer.geometry.draw(type, size2, start, instanceCount);
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
        }
      };
      GlEncoderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "encoder"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlRenderTarget.mjs
  var GlRenderTarget;
  var init_GlRenderTarget = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
      GlRenderTarget = class {
        constructor() {
          this.width = -1;
          this.height = -1;
          this.msaaRenderBuffer = [];
          this.msaa = false;
          this.dirtyId = -1;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlRenderTargetSystem.mjs
  var GlRenderTargetSystem;
  var init_GlRenderTargetSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlRenderTargetSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_isRenderingToScreen();
      init_RenderTarget();
      init_SystemRunner();
      init_Texture();
      init_getCanvasTexture();
      init_const7();
      init_GlRenderTarget();
      GlRenderTargetSystem = class {
        constructor(renderer) {
          this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
          this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
          this._renderTargetStack = [];
          this._defaultClearColor = [0, 0, 0, 0];
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
          this.rootProjectionMatrix = new Matrix();
          this._renderer = renderer;
        }
        contextChange(gl) {
          this._gl = gl;
        }
        start(rootRenderSurface, clear = true, clearColor) {
          this._renderTargetStack.length = 0;
          const renderTarget = this.getRenderTarget(rootRenderSurface);
          this.rootRenderTarget = renderTarget;
          this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
          this.rootProjectionMatrix = renderTarget.projectionMatrix;
          this.push(renderTarget, clear, clearColor);
        }
        bind(renderSurface, clear = true, clearColor) {
          const renderTarget = this.getRenderTarget(renderSurface);
          this.renderTarget = renderTarget;
          const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
          if (renderTarget.dirtyId !== gpuRenderTarget.dirtyId) {
            gpuRenderTarget.dirtyId = renderTarget.dirtyId;
            this._resizeGpuRenderTarget(renderTarget);
          }
          const gl = this._gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
          renderTarget.colorTextures.forEach((texture) => {
            this._renderer.texture.unbind(texture);
          });
          const viewport = renderTarget.viewport;
          let viewPortY = viewport.y;
          if (renderTarget.isRoot) {
            viewPortY = this._renderer.view.canvas.height - viewport.height;
          }
          const viewPortCache = this._viewPortCache;
          if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
            viewPortCache.x = viewport.x;
            viewPortCache.y = viewPortY;
            viewPortCache.width = viewport.width;
            viewPortCache.height = viewport.height;
            gl.viewport(
              viewport.x,
              viewPortY,
              viewport.width,
              viewport.height
            );
          }
          this.clear(clear, clearColor);
          this.onRenderTargetChange.emit(renderTarget);
          return renderTarget;
        }
        clear(clear, clearColor) {
          if (!clear)
            return;
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const gl = this._gl;
          if (clear & CLEAR.COLOR) {
            clearColor ?? (clearColor = this._defaultClearColor);
            const clearColorCache = this._clearColorCache;
            const clearColorArray = clearColor;
            if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
              clearColorCache[0] = clearColorArray[0];
              clearColorCache[1] = clearColorArray[1];
              clearColorCache[2] = clearColorArray[2];
              clearColorCache[3] = clearColorArray[3];
              gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
            }
          }
          gl.clear(clear);
        }
        push(renderSurface, clear = true, clearColor) {
          const renderTarget = this.bind(renderSurface, clear, clearColor);
          this._renderTargetStack.push(renderTarget);
          return renderTarget;
        }
        pop() {
          this._renderTargetStack.pop();
          this.bind(this._renderTargetStack[this._renderTargetStack.length - 1], false);
        }
        getRenderTarget(renderSurface) {
          return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
        }
        _initRenderTarget(renderSurface) {
          let renderTarget = null;
          if (renderSurface instanceof HTMLCanvasElement) {
            renderSurface = getCanvasTexture(renderSurface);
          }
          if (renderSurface instanceof RenderTarget) {
            renderTarget = renderSurface;
          } else if (renderSurface instanceof Texture) {
            renderTarget = new RenderTarget({
              colorTextures: [renderSurface]
            });
            if (renderSurface.source.resource instanceof HTMLCanvasElement) {
              renderTarget.isRoot = true;
            }
            renderSurface.source.on("destroy", () => {
              renderTarget.destroy();
            });
          }
          this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
          return renderTarget;
        }
        finishRenderPass(renderTarget) {
          renderTarget = renderTarget || this.renderTarget;
          const glRenderTarget = this.getGpuRenderTarget(renderTarget);
          if (!glRenderTarget.msaa)
            return;
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
          gl.blitFramebuffer(
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            gl.COLOR_BUFFER_BIT,
            gl.NEAREST
          );
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, origin, size2) {
          const renderer = this._renderer;
          const glRenderTarget = this.getGpuRenderTarget(sourceRenderSurfaceTexture);
          const gl = renderer.gl;
          this.finishRenderPass(sourceRenderSurfaceTexture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          renderer.texture.bind(destinationTexture, 0);
          gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            origin.x,
            origin.y,
            size2.width,
            size2.height
          );
          return destinationTexture;
        }
        getGpuRenderTarget(renderTarget) {
          return this._gpuRenderTargetHash[renderTarget.uid] || this._initGpuRenderTarget(renderTarget);
        }
        _initGpuRenderTarget(renderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const glRenderTarget = new GlRenderTarget();
          if (renderTarget.colorTexture.source.resource instanceof HTMLCanvasElement) {
            this._gpuRenderTargetHash[renderTarget.uid] = glRenderTarget;
            glRenderTarget.framebuffer = null;
            return glRenderTarget;
          }
          this._initColor(renderTarget, glRenderTarget);
          if (renderTarget.stencil) {
            this._initStencil(glRenderTarget);
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          this._gpuRenderTargetHash[renderTarget.uid] = glRenderTarget;
          return glRenderTarget;
        }
        _resizeGpuRenderTarget(renderTarget) {
          if (renderTarget.isRoot)
            return;
          const glRenderTarget = this.getGpuRenderTarget(renderTarget);
          this._resizeColor(renderTarget, glRenderTarget);
          if (renderTarget.stencil) {
            this._resizeStencil(glRenderTarget);
          }
        }
        _initColor(renderTarget, glRenderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const resolveTargetFramebuffer = gl.createFramebuffer();
          glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
          glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
          glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const source2 = colorTexture.source;
            if (source2.antialias) {
              glRenderTarget.msaa = true;
            }
            renderer.texture.bindSource(source2, 0);
            const glSource = renderer.texture.getGlSource(source2);
            const glTexture = glSource.texture;
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              3553,
              glTexture,
              0
            );
          });
          if (glRenderTarget.msaa) {
            const viewFramebuffer = gl.createFramebuffer();
            glRenderTarget.framebuffer = viewFramebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((_, i2) => {
              const msaaRenderBuffer = gl.createRenderbuffer();
              glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
            });
          } else {
            glRenderTarget.framebuffer = resolveTargetFramebuffer;
          }
        }
        _resizeColor(renderTarget, glRenderTarget) {
          const source2 = renderTarget.colorTexture.source;
          glRenderTarget.width = source2.pixelWidth;
          glRenderTarget.height = source2.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            if (i2 === 0)
              return;
            colorTexture.source.resize(source2.width, source2.height, source2._resolution);
          });
          if (glRenderTarget.msaa) {
            const renderer = this._renderer;
            const gl = renderer.gl;
            const viewFramebuffer = glRenderTarget.framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((colorTexture, i2) => {
              const source22 = colorTexture.source;
              renderer.texture.bindSource(source22, 0);
              const glSource = renderer.texture.getGlSource(source22);
              const glInternalFormat = glSource.internalFormat;
              const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
              gl.bindRenderbuffer(
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
              gl.renderbufferStorageMultisample(
                gl.RENDERBUFFER,
                4,
                glInternalFormat,
                source22.pixelWidth,
                source22.pixelHeight
              );
              gl.framebufferRenderbuffer(
                gl.FRAMEBUFFER,
                gl.COLOR_ATTACHMENT0 + i2,
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
            });
          }
        }
        _initStencil(glRenderTarget) {
          const gl = this._renderer.gl;
          const depthStencilRenderBuffer = gl.createRenderbuffer();
          glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          gl.framebufferRenderbuffer(
            gl.FRAMEBUFFER,
            gl.DEPTH_STENCIL_ATTACHMENT,
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
        }
        _resizeStencil(glRenderTarget) {
          const gl = this._renderer.gl;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            glRenderTarget.depthStencilRenderBuffer
          );
          if (glRenderTarget.msaa) {
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              gl.DEPTH24_STENCIL8,
              glRenderTarget.width,
              glRenderTarget.height
            );
          } else {
            gl.renderbufferStorage(
              gl.RENDERBUFFER,
              gl.DEPTH24_STENCIL8,
              glRenderTarget.width,
              glRenderTarget.height
            );
          }
        }
      };
      GlRenderTargetSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "renderTarget"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlStencilSystem.mjs
  var GlStencilSystem;
  var init_GlStencilSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
      init_Extensions();
      init_GpuStencilModesToPixi();
      init_const8();
      GlStencilSystem = class {
        constructor(renderer) {
          this._stencilCache = {
            enabled: false,
            stencilReference: 0,
            stencilMode: STENCIL_MODES.NONE
          };
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(gl) {
          this._gl = gl;
          this._comparisonFuncMapping = {
            always: gl.ALWAYS,
            never: gl.NEVER,
            equal: gl.EQUAL,
            "not-equal": gl.NOTEQUAL,
            less: gl.LESS,
            "less-equal": gl.LEQUAL,
            greater: gl.GREATER,
            "greater-equal": gl.GEQUAL
          };
          this._stencilOpsMapping = {
            keep: gl.KEEP,
            zero: gl.ZERO,
            replace: gl.REPLACE,
            invert: gl.INVERT,
            "increment-clamp": gl.INCR,
            "decrement-clamp": gl.DECR,
            "increment-wrap": gl.INCR_WRAP,
            "decrement-wrap": gl.DECR_WRAP
          };
        }
        onRenderTargetChange(renderTarget) {
          if (this._activeRenderTarget === renderTarget)
            return;
          this._activeRenderTarget = renderTarget;
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          const gl = this._gl;
          const mode = GpuStencilModesToPixi[stencilMode];
          const _stencilCache = this._stencilCache;
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          if (stencilMode === STENCIL_MODES.DISABLED) {
            if (this._stencilCache.enabled) {
              this._stencilCache.enabled = false;
              gl.disable(gl.STENCIL_TEST);
            }
            return;
          }
          if (!this._stencilCache.enabled) {
            this._stencilCache.enabled = true;
            gl.enable(gl.STENCIL_TEST);
          }
          if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
            _stencilCache.stencilMode = stencilMode;
            _stencilCache.stencilReference = stencilReference;
            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
          }
        }
      };
      GlStencilSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlProgramData.mjs
  var GlProgramData;
  var init_GlProgramData = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
      GlProgramData = class {
        constructor(program, uniformData) {
          this.program = program;
          this.uniformData = uniformData;
          this.uniformGroups = {};
          this.uniformDirtyGroups = {};
          this.uniformBlockBindings = {};
        }
        destroy() {
          this.uniformData = null;
          this.uniformGroups = null;
          this.uniformDirtyGroups = null;
          this.uniformBlockBindings = null;
          this.program = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/compileShader.mjs
  function compileShader(gl, type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  var init_compileShader = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
  function booleanArray(size2) {
    const array = new Array(size2);
    for (let i2 = 0; i2 < array.length; i2++) {
      array[i2] = false;
    }
    return array;
  }
  function defaultValue(type, size2) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size2);
      case "vec3":
        return new Float32Array(3 * size2);
      case "vec4":
        return new Float32Array(4 * size2);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size2);
      case "ivec3":
        return new Int32Array(3 * size2);
      case "ivec4":
        return new Int32Array(4 * size2);
      case "uvec2":
        return new Uint32Array(2 * size2);
      case "uvec3":
        return new Uint32Array(3 * size2);
      case "uvec4":
        return new Uint32Array(4 * size2);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size2);
      case "bvec3":
        return booleanArray(3 * size2);
      case "bvec4":
        return booleanArray(4 * size2);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_defaultValue = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/mapSize.mjs
  function mapSize(type) {
    return GLSL_TO_SIZE[type];
  }
  var GLSL_TO_SIZE;
  var init_mapSize = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/mapSize.mjs"() {
      GLSL_TO_SIZE = {
        float: 1,
        vec2: 2,
        vec3: 3,
        vec4: 4,
        int: 1,
        ivec2: 2,
        ivec3: 3,
        ivec4: 4,
        uint: 1,
        uvec2: 2,
        uvec3: 3,
        uvec4: 4,
        bool: 1,
        bvec2: 2,
        bvec3: 3,
        bvec4: 4,
        mat2: 4,
        mat3: 9,
        mat4: 16,
        sampler2D: 1
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/mapType.mjs
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i2 = 0; i2 < typeNames.length; ++i2) {
        const tn = typeNames[i2];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  var GL_TABLE, GL_TO_GLSL_TYPES;
  var init_mapType = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
      GL_TABLE = null;
      GL_TO_GLSL_TYPES = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getAttributeData.mjs
  function getAttributeData(program, gl) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i2 = 0; i2 < totalAttributes; i2++) {
      const attribData = gl.getActiveAttrib(program, i2);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const type = mapType(gl, attribData.type);
      const data = {
        type,
        name: attribData.name,
        size: mapSize(type),
        location: gl.getAttribLocation(program, attribData.name)
      };
      attributes[attribData.name] = data;
    }
    return attributes;
  }
  var init_getAttributeData = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getAttributeData.mjs"() {
      init_mapSize();
      init_mapType();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getUniformBufferData.mjs
  function getUniformBufferData(program, gl) {
    const uniformBlocks = {};
    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for (let i2 = 0; i2 < totalUniformsBlocks; i2++) {
      const name = gl.getActiveUniformBlockName(program, i2);
      const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
      const size2 = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
      uniformBlocks[name] = {
        name,
        index: uniformBlockIndex,
        size: size2
      };
    }
    return uniformBlocks;
  }
  var init_getUniformBufferData = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getUniformBufferData.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i2 = 0; i2 < totalUniforms; i2++) {
      const uniformData = gl.getActiveUniform(program, i2);
      const name = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray = !!uniformData.name.match(/\[.*?\]$/);
      const type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i2,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }
  var init_getUniformData = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
      init_defaultValue();
      init_mapType();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
      if (n2 && !dedupe[n2]) {
        dedupe[n2] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  var init_logProgramError = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(
          webGLProgram,
          transformFeedbackVaryings.names,
          transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
        );
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program.attributeData = getAttributeData(webGLProgram, gl);
    program.uniformData = getUniformData(webGLProgram, gl);
    program.uniformBlockData = getUniformBufferData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i2 in program.uniformData) {
      const data = program.uniformData[i2];
      uniformData[i2] = {
        location: gl.getUniformLocation(webGLProgram, i2),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram = new GlProgramData(webGLProgram, uniformData);
    return glProgram;
  }
  var init_generateProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
      init_warn();
      init_GlProgramData();
      init_compileShader();
      init_defaultValue();
      init_getAttributeData();
      init_getUniformBufferData();
      init_getUniformData();
      init_logProgramError();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
  var defaultSyncData, GlShaderSystem;
  var init_GlShaderSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
      init_Extensions();
      init_BufferResource();
      init_UniformGroup();
      init_TextureSource();
      init_TextureStyle();
      init_generateProgram();
      defaultSyncData = {
        textureCount: 0,
        blockIndex: 0
      };
      GlShaderSystem = class {
        constructor(renderer) {
          this.activeProgram = null;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._nextIndex = 0;
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        contextChange(gl) {
          this._gl = gl;
          this._maxBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
        }
        bind(shader, skipSync) {
          this._setProgram(shader.glProgram);
          if (skipSync)
            return;
          defaultSyncData.textureCount = 0;
          defaultSyncData.blockIndex = 0;
          const gl = this._gl;
          const programData = this.getProgramData(shader.glProgram);
          for (const i2 in shader.groups) {
            const bindGroup = shader.groups[i2];
            for (const j2 in bindGroup.resources) {
              const resource = bindGroup.resources[j2];
              if (resource instanceof UniformGroup) {
                if (resource.ubo) {
                  this.bindUniformBlock(
                    resource,
                    shader.uniformBindMap[i2][j2],
                    defaultSyncData.blockIndex++
                  );
                } else {
                  this._updateUniformGroup(resource);
                }
              } else if (resource instanceof BufferResource) {
                this.bindUniformBlock(
                  resource,
                  shader.uniformBindMap[i2][j2],
                  defaultSyncData.blockIndex++
                );
              } else if (resource instanceof TextureSource) {
                this._renderer.texture.bind(resource, defaultSyncData.textureCount);
                const uniformName = shader.uniformBindMap[i2][j2];
                const uniformData = programData.uniformData[uniformName];
                if (uniformData) {
                  if (uniformData.value !== defaultSyncData.textureCount) {
                    gl.uniform1i(uniformData.location, defaultSyncData.textureCount);
                  }
                  defaultSyncData.textureCount++;
                }
              } else if (resource instanceof TextureStyle) {
              }
            }
          }
        }
        _updateUniformGroup(uniformGroup) {
          this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this.activeProgram, defaultSyncData);
        }
        bindUniformBlock(uniformGroup, name, index = 0) {
          const bufferSystem = this._renderer.buffer;
          const programData = this.getProgramData(this.activeProgram);
          const isBufferResource = uniformGroup.bufferResource;
          if (isBufferResource) {
            this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
          }
          bufferSystem.updateBuffer(uniformGroup.buffer);
          let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];
          if (boundIndex === void 0) {
            const nextIndex = this._nextIndex++ % this._maxBindings;
            const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];
            if (currentBoundUniformGroup) {
              this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
            }
            boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
            this._boundIndexToUniformsHash[nextIndex] = uniformGroup;
            if (isBufferResource) {
              bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
            } else {
              bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
            }
          }
          const gl = this._gl;
          const uniformBlockIndex = this.activeProgram.uniformBlockData[name].index;
          if (programData.uniformBlockBindings[index] === boundIndex)
            return;
          programData.uniformBlockBindings[index] = boundIndex;
          gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
        }
        _setProgram(program) {
          if (this.activeProgram === program)
            return;
          this.activeProgram = program;
          const programData = this.getProgramData(program);
          this._gl.useProgram(programData.program);
        }
        getProgramData(program) {
          return this._programDataHash[program.key] || this._createProgramData(program);
        }
        _createProgramData(program) {
          const key = program.key;
          this._programDataHash[key] = generateProgram(this._gl, program);
          return this._programDataHash[key];
        }
        destroy() {
          for (const key of Object.keys(this._programDataHash)) {
            const programData = this._programDataHash[key];
            programData.destroy();
            this._programDataHash[key] = null;
          }
          this._programDataHash = null;
          this._boundUniformsIdsToIndexHash = null;
        }
      };
      GlShaderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/unsafeEvalSupported.mjs
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({ a: "b" }, "a", "b") === true;
    } catch (e2) {
      unsafeEval = false;
    }
    return unsafeEval;
  }
  var unsafeEval;
  var init_unsafeEvalSupported = __esm({
    "node_modules/pixi-v8/lib/utils/unsafeEvalSupported.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/uniformParsers.mjs
  var uniformParsers;
  var init_uniformParsers = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/uniformParsers.mjs"() {
      init_Texture();
      uniformParsers = [
        {
          test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
          code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
        },
        {
          test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform instanceof Texture),
          code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
        },
        {
          test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
          code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `
        },
        {
          test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`
        },
        {
          test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
        },
        {
          test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`
        },
        {
          test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`
        },
        {
          test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`
        },
        {
          test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
        }
      ];
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/generateUniformsSync.mjs
  function generateUniformsSync(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const i2 in group.uniforms) {
      const data = uniformData[i2];
      if (!data) {
        if (group.uniforms[i2] instanceof UniformGroup) {
          if (group.uniforms[i2].ubo) {
            funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
          }
        } else if (group.uniforms[i2] instanceof BufferResource) {
          funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
        }
        continue;
      }
      const uniform = group.uniforms[i2];
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        if (uniformParsers[j2].test(data, uniform)) {
          funcFragments.push(uniformParsers[j2].code(i2, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
        const template = templateType[data.type].replace("location", `ud["${i2}"].location`);
        funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var GLSL_TO_SINGLE_SETTERS_CACHED, GLSL_TO_ARRAY_SETTERS;
  var init_generateUniformsSync = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/generateUniformsSync.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_uniformParsers();
      GLSL_TO_SINGLE_SETTERS_CACHED = {
        float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
        vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
        vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
        vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
        int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
        uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
        uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
        uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
        bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
        bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
      };
      GLSL_TO_ARRAY_SETTERS = {
        float: `gl.uniform1fv(location, v)`,
        vec2: `gl.uniform2fv(location, v)`,
        vec3: `gl.uniform3fv(location, v)`,
        vec4: "gl.uniform4fv(location, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        int: "gl.uniform1iv(location, v)",
        ivec2: "gl.uniform2iv(location, v)",
        ivec3: "gl.uniform3iv(location, v)",
        ivec4: "gl.uniform4iv(location, v)",
        uint: "gl.uniform1uiv(location, v)",
        uvec2: "gl.uniform2uiv(location, v)",
        uvec3: "gl.uniform3uiv(location, v)",
        uvec4: "gl.uniform4uiv(location, v)",
        bool: "gl.uniform1iv(location, v)",
        bvec2: "gl.uniform2iv(location, v)",
        bvec3: "gl.uniform3iv(location, v)",
        bvec4: "gl.uniform4iv(location, v)",
        sampler2D: "gl.uniform1iv(location, v)",
        samplerCube: "gl.uniform1iv(location, v)",
        sampler2DArray: "gl.uniform1iv(location, v)"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
  var GlUniformGroupSystem;
  var init_GlUniformGroupSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
      init_Extensions();
      init_unsafeEvalSupported();
      init_generateUniformsSync();
      GlUniformGroupSystem = class {
        constructor(renderer) {
          this.destroyed = false;
          this._cache = {};
          this._uniformGroupSyncHash = {};
          this._renderer = renderer;
          this._systemCheck();
          this.gl = null;
          this._cache = {};
        }
        _systemCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
          }
        }
        contextChange(gl) {
          this.gl = gl;
        }
        updateUniformGroup(group, program, syncData) {
          const programData = this._renderer.shader.getProgramData(program);
          if (!group.isStatic || group.dirtyId !== programData.uniformDirtyGroups[group.uid]) {
            programData.uniformDirtyGroups[group.uid] = group.dirtyId;
            const syncFunc = this._getUniformSyncFunction(group, program);
            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
          }
        }
        _getUniformSyncFunction(group, program) {
          return this._uniformGroupSyncHash[group.signature]?.[program.key] || this._createUniformSyncFunction(group, program);
        }
        _createUniformSyncFunction(group, program) {
          const uniformGroupSyncHash = this._uniformGroupSyncHash[group.signature] || (this._uniformGroupSyncHash[group.signature] = {});
          const id = this._getSignature(group, program.uniformData, "u");
          if (!this._cache[id]) {
            this._cache[id] = generateUniformsSync(group, program.uniformData);
          }
          uniformGroupSyncHash[program.key] = this._cache[id];
          return uniformGroupSyncHash[program.key];
        }
        _getSignature(group, uniformData, preFix) {
          const uniforms = group.uniforms;
          const strings = [`${preFix}-`];
          for (const i2 in uniforms) {
            strings.push(i2);
            if (uniformData[i2]) {
              strings.push(uniformData[i2].type);
            }
          }
          return strings.join("-");
        }
        destroy() {
          this._renderer = null;
          this.destroyed = true;
          this._cache = null;
        }
      };
      GlUniformGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "uniformGroup"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi(gl) {
    const blendMap = {};
    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.add = [gl.ONE, gl.ONE];
    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.none = [0, 0];
    blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    return blendMap;
  }
  var init_mapWebGLBlendModesToPixi = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/state/GlStateSystem.mjs
  var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
  var init_GlStateSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_mapWebGLBlendModesToPixi();
      BLEND2 = 0;
      OFFSET2 = 1;
      CULLING2 = 2;
      DEPTH_TEST2 = 3;
      WINDING2 = 4;
      DEPTH_MASK2 = 5;
      _GlStateSystem = class {
        constructor() {
          this.gl = null;
          this.stateId = 0;
          this.polygonOffset = 0;
          this.blendMode = "none";
          this._blendEq = false;
          this.map = [];
          this.map[BLEND2] = this.setBlend;
          this.map[OFFSET2] = this.setOffset;
          this.map[CULLING2] = this.setCullFace;
          this.map[DEPTH_TEST2] = this.setDepthTest;
          this.map[WINDING2] = this.setFrontFace;
          this.map[DEPTH_MASK2] = this.setDepthMask;
          this.checks = [];
          this.defaultState = new State();
          this.defaultState.blend = true;
        }
        contextChange(gl) {
          this.gl = gl;
          this.blendModesMap = mapWebGLBlendModesToPixi(gl);
          this.set(this.defaultState);
          this.reset();
        }
        set(state) {
          state = state || this.defaultState;
          if (this.stateId !== state.data) {
            let diff = this.stateId ^ state.data;
            let i2 = 0;
            while (diff) {
              if (diff & 1) {
                this.map[i2].call(this, !!(state.data & 1 << i2));
              }
              diff = diff >> 1;
              i2++;
            }
            this.stateId = state.data;
          }
          for (let i2 = 0; i2 < this.checks.length; i2++) {
            this.checks[i2](this, state);
          }
        }
        forceState(state) {
          state = state || this.defaultState;
          for (let i2 = 0; i2 < this.map.length; i2++) {
            this.map[i2].call(this, !!(state.data & 1 << i2));
          }
          for (let i2 = 0; i2 < this.checks.length; i2++) {
            this.checks[i2](this, state);
          }
          this.stateId = state.data;
        }
        setBlend(value) {
          this._updateCheck(_GlStateSystem._checkBlendMode, value);
          this.gl[value ? "enable" : "disable"](this.gl.BLEND);
        }
        setOffset(value) {
          this._updateCheck(_GlStateSystem._checkPolygonOffset, value);
          this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        setDepthTest(value) {
          this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        setDepthMask(value) {
          this.gl.depthMask(value);
        }
        setCullFace(value) {
          this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
        }
        setFrontFace(value) {
          this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
        }
        setBlendMode(value) {
          if (!this.blendModesMap[value]) {
            value = "normal";
          }
          if (value === this.blendMode) {
            return;
          }
          this.blendMode = value;
          const mode = this.blendModesMap[value];
          const gl = this.gl;
          if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
          } else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
          }
          if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
          } else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          }
        }
        setPolygonOffset(value, scale) {
          this.gl.polygonOffset(value, scale);
        }
        reset() {
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
          this.forceState(this.defaultState);
          this._blendEq = true;
          this.blendMode = "";
          this.setBlendMode("normal");
        }
        _updateCheck(func, value) {
          const index = this.checks.indexOf(func);
          if (value && index === -1) {
            this.checks.push(func);
          } else if (!value && index !== -1) {
            this.checks.splice(index, 1);
          }
        }
        static _checkBlendMode(system, state) {
          system.setBlendMode(state.blendMode);
        }
        static _checkPolygonOffset(system, state) {
          system.setPolygonOffset(1, state.polygonOffset);
        }
        destroy() {
          this.gl = null;
          this.checks.length = 0;
        }
      };
      GlStateSystem = _GlStateSystem;
      GlStateSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "state"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/GlTexture.mjs
  var GlTexture;
  var init_GlTexture = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
      init_const10();
      GlTexture = class {
        constructor(texture) {
          this.target = GL_TARGETS.TEXTURE_2D;
          this.texture = texture;
          this.width = -1;
          this.height = -1;
          this.type = GL_TYPES.UNSIGNED_BYTE;
          this.internalFormat = GL_FORMATS.RGBA;
          this.format = GL_FORMATS.RGBA;
          this.samplerType = 0;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
  var glUploadBufferImageResource;
  var init_glUploadBufferImageResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
      glUploadBufferImageResource = {
        id: "image",
        upload(source2, glTexture, gl) {
          if (glTexture.width === source2.width || glTexture.height === source2.height) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              source2.width,
              source2.height,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          }
          glTexture.width = source2.width;
          glTexture.height = source2.height;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
  var glUploadImageResource;
  var init_glUploadImageResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
      glUploadImageResource = {
        id: "image",
        upload(source2, glTexture, gl) {
          const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
          const glWidth = glTexture.width;
          const glHeight = glTexture.height;
          const textureWidth = source2.pixelWidth;
          const textureHeight = source2.pixelHeight;
          const resourceWidth = source2.resourceWidth;
          const resourceHeight = source2.resourceHeight;
          if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
            if (glWidth !== textureWidth || glHeight !== textureHeight) {
              gl.texImage2D(
                glTexture.target,
                0,
                glTexture.internalFormat,
                textureWidth,
                textureHeight,
                0,
                glTexture.format,
                glTexture.type,
                null
              );
            }
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              resourceWidth,
              resourceHeight,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else if (glWidth === textureWidth || glHeight === textureHeight) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          }
          glTexture.width = textureWidth;
          glTexture.height = textureHeight;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
  var glUploadVideoResource;
  var init_glUploadVideoResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
      init_glUploadImageResource();
      glUploadVideoResource = {
        id: "video",
        upload(source2, glTexture, gl) {
          if (!source2.isValid) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              1,
              1,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
            return;
          }
          glUploadImageResource.upload(source2, glTexture, gl);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
  var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
  var init_pixiToGlMaps = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
      scaleModeToGlFilter = {
        linear: 9729,
        nearest: 9728
      };
      mipmapScaleModeToGlFilter = {
        linear: {
          linear: 9987,
          nearest: 9985
        },
        nearest: {
          linear: 9986,
          nearest: 9984
        }
      };
      wrapModeToGlAddress = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
      };
      compareModeToGlCompare = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
  function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam) {
    const castParam = firstParam;
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeToGlAddress[style.addressModeU]);
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeToGlAddress[style.addressModeV]);
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeToGlAddress[style.addressModeW]);
    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
    if (mipmaps) {
      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
    } else {
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
    }
    if (anisotropicExt && style.maxAnisotropy > 1) {
      const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
    }
    if (style.compare) {
      gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
    }
  }
  var init_applyStyleParams = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
      init_pixiToGlMaps();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
  function mapFormatToGlFormat(gl) {
    return {
      r8unorm: gl.RED,
      r8snorm: gl.RED,
      r8uint: gl.RED,
      r8sint: gl.RED,
      r16uint: gl.RED,
      r16sint: gl.RED,
      r16float: gl.RED,
      rg8unorm: gl.RG,
      rg8snorm: gl.RG,
      rg8uint: gl.RG,
      rg8sint: gl.RG,
      r32uint: gl.RED,
      r32sint: gl.RED,
      r32float: gl.RED,
      rg16uint: gl.RG,
      rg16sint: gl.RG,
      rg16float: gl.RG,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.RGBA,
      rgba8snorm: gl.RGBA,
      rgba8uint: gl.RGBA,
      rgba8sint: gl.RGBA,
      bgra8unorm: gl.RGBA,
      "bgra8unorm-srgb": gl.RGBA,
      rgb9e5ufloat: gl.RGB,
      rgb10a2unorm: gl.RGBA,
      rg11b10ufloat: gl.RGB,
      rg32uint: gl.RG,
      rg32sint: gl.RG,
      rg32float: gl.RG,
      rgba16uint: gl.RGBA,
      rgba16sint: gl.RGBA,
      rgba16float: gl.RGBA,
      rgba32uint: gl.RGBA,
      rgba32sint: gl.RGBA,
      rgba32float: gl.RGBA,
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT,
      depth24plus: gl.DEPTH_COMPONENT,
      "depth24plus-stencil8": gl.DEPTH_STENCIL,
      depth32float: gl.DEPTH_COMPONENT,
      "depth32float-stencil8": gl.DEPTH_STENCIL
    };
  }
  var init_mapFormatToGlFormat = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
  function mapFormatToGlInternalFormat(gl) {
    return {
      r8unorm: gl.R8,
      r8snorm: gl.R8_SNORM,
      r8uint: gl.R8UI,
      r8sint: gl.R8I,
      r16uint: gl.R16UI,
      r16sint: gl.R16I,
      r16float: gl.R16F,
      rg8unorm: gl.RG8,
      rg8snorm: gl.RG8_SNORM,
      rg8uint: gl.RG8UI,
      rg8sint: gl.RG8I,
      r32uint: gl.R32UI,
      r32sint: gl.R32I,
      r32float: gl.R32F,
      rg16uint: gl.RG16UI,
      rg16sint: gl.RG16I,
      rg16float: gl.RG16F,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
      rgba8snorm: gl.RGBA8_SNORM,
      rgba8uint: gl.RGBA8UI,
      rgba8sint: gl.RGBA8I,
      bgra8unorm: gl.RGBA8,
      "bgra8unorm-srgb": gl.SRGB8_ALPHA8,
      rgb9e5ufloat: gl.RGB9_E5,
      rgb10a2unorm: gl.RGB10_A2,
      rg11b10ufloat: gl.R11F_G11F_B10F,
      rg32uint: gl.RG32UI,
      rg32sint: gl.RG32I,
      rg32float: gl.RG32F,
      rgba16uint: gl.RGBA16UI,
      rgba16sint: gl.RGBA16I,
      rgba16float: gl.RGBA16F,
      rgba32uint: gl.RGBA32UI,
      rgba32sint: gl.RGBA32I,
      rgba32float: gl.RGBA32F,
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT16,
      depth24plus: gl.DEPTH_COMPONENT24,
      "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
      depth32float: gl.DEPTH_COMPONENT32F,
      "depth32float-stencil8": gl.DEPTH32F_STENCIL8
    };
  }
  var init_mapFormatToGlInternalFormat = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
  function mapFormatToGlType(gl) {
    return {
      r8unorm: gl.UNSIGNED_BYTE,
      r8snorm: gl.BYTE,
      r8uint: gl.UNSIGNED_BYTE,
      r8sint: gl.BYTE,
      r16uint: gl.UNSIGNED_SHORT,
      r16sint: gl.SHORT,
      r16float: gl.HALF_FLOAT,
      rg8unorm: gl.UNSIGNED_BYTE,
      rg8snorm: gl.BYTE,
      rg8uint: gl.UNSIGNED_BYTE,
      rg8sint: gl.BYTE,
      r32uint: gl.UNSIGNED_INT,
      r32sint: gl.INT,
      r32float: gl.FLOAT,
      rg16uint: gl.UNSIGNED_SHORT,
      rg16sint: gl.SHORT,
      rg16float: gl.HALF_FLOAT,
      rgba8unorm: gl.UNSIGNED_BYTE,
      "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
      rgba8snorm: gl.BYTE,
      rgba8uint: gl.UNSIGNED_BYTE,
      rgba8sint: gl.BYTE,
      bgra8unorm: gl.UNSIGNED_BYTE,
      "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
      rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
      rg32uint: gl.UNSIGNED_INT,
      rg32sint: gl.INT,
      rg32float: gl.FLOAT,
      rgba16uint: gl.UNSIGNED_SHORT,
      rgba16sint: gl.SHORT,
      rgba16float: gl.HALF_FLOAT,
      rgba32uint: gl.UNSIGNED_INT,
      rgba32sint: gl.INT,
      rgba32float: gl.FLOAT,
      stencil8: gl.UNSIGNED_BYTE,
      depth16unorm: gl.UNSIGNED_SHORT,
      depth24plus: gl.UNSIGNED_INT,
      "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
      depth32float: gl.FLOAT,
      "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }
  var init_mapFormatToGlType = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
  var TEMP_RECT, BYTES_PER_PIXEL, GlTextureSystem;
  var init_GlTextureSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
      init_Extensions();
      init_Rectangle();
      init_settings();
      init_Texture();
      init_GlTexture();
      init_glUploadBufferImageResource();
      init_glUploadImageResource();
      init_glUploadVideoResource();
      init_applyStyleParams();
      init_mapFormatToGlFormat();
      init_mapFormatToGlInternalFormat();
      init_mapFormatToGlType();
      TEMP_RECT = new Rectangle();
      BYTES_PER_PIXEL = 4;
      GlTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundTextures = [];
          this._activeTextureLocation = -1;
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: glUploadImageResource,
            buffer: glUploadBufferImageResource,
            video: glUploadVideoResource
          };
          this._useSeparateSamplers = false;
          this._renderer = renderer;
        }
        contextChange(gl) {
          this._gl = gl;
          if (!this._mapFormatToInternalFormat) {
            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl);
            this._mapFormatToType = mapFormatToGlType(gl);
            this._mapFormatToFormat = mapFormatToGlFormat(gl);
          }
          for (let i2 = 0; i2 < 16; i2++) {
            this.bind(Texture.EMPTY, i2);
          }
        }
        bind(texture, location = 0) {
          const source2 = texture.source;
          if (texture) {
            this.bindSource(source2, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(source2.style, location);
            }
          } else {
            this.bindSource(null, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(null, location);
            }
          }
        }
        bindSource(source2, location = 0) {
          const gl = this._gl;
          source2.touched = this._renderer.textureGC.count;
          if (this._boundTextures[location] !== source2) {
            this._boundTextures[location] = source2;
            this._activateLocation(location);
            source2 = source2 || Texture.EMPTY.source;
            const glTexture = this.getGlSource(source2);
            gl.bindTexture(glTexture.target, glTexture.texture);
          }
        }
        _bindSampler(style, location = 0) {
          const gl = this._gl;
          if (!style) {
            this._boundSamplers[location] = null;
            gl.bindSampler(location, null);
            return;
          }
          const sampler = this._getGlSampler(style);
          if (this._boundSamplers[location] !== sampler) {
            this._boundSamplers[location] = sampler;
            gl.bindSampler(location, sampler);
          }
        }
        unbind(texture) {
          const source2 = texture.source;
          const boundTextures = this._boundTextures;
          const gl = this._gl;
          for (let i2 = 0; i2 < boundTextures.length; i2++) {
            if (boundTextures[i2] === source2) {
              this._activateLocation(i2);
              const glTexture = this.getGlSource(source2);
              gl.bindTexture(glTexture.target, null);
              boundTextures[i2] = null;
            }
          }
        }
        _activateLocation(location) {
          if (this._activeTextureLocation !== location) {
            this._activeTextureLocation = location;
            this._gl.activeTexture(this._gl.TEXTURE0 + location);
          }
        }
        _initSource(source2) {
          const gl = this._gl;
          const glTexture = new GlTexture(gl.createTexture());
          glTexture.type = this._mapFormatToType[source2.format];
          glTexture.internalFormat = this._mapFormatToInternalFormat[source2.format];
          glTexture.format = this._mapFormatToFormat[source2.format];
          if (source2.autoGenerateMipmaps) {
            const biggestDimension = Math.max(source2.width, source2.height);
            source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          this._glTextures[source2.uid] = glTexture;
          source2.on("update", this.onSourceUpdate, this);
          source2.on("resize", this.onSourceUpdate, this);
          source2.on("styleChange", this.onStyleChange, this);
          source2.on("destroy", this.onSourceDestroy, this);
          source2.on("unload", this.onSourceUnload, this);
          this.managedTextures.push(source2);
          this.onSourceUpdate(source2);
          this.onStyleChange(source2);
          return glTexture;
        }
        onStyleChange(source2) {
          const gl = this._gl;
          const glTexture = this._glTextures[source2.uid];
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source2;
          applyStyleParams(
            source2.style,
            gl,
            source2.mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "texParameteri",
            gl.TEXTURE_2D
          );
        }
        onSourceUnload(source2) {
          const glTexture = this._glTextures[source2.uid];
          if (!glTexture)
            return;
          this.unbind(source2);
          this._glTextures[source2.uid] = null;
          this._gl.deleteTexture(glTexture.texture);
        }
        onSourceUpdate(source2) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source2);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source2;
          if (this._uploads[source2.uploadMethodId]) {
            this._uploads[source2.uploadMethodId].upload(source2, glTexture, this._gl);
            if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
              gl.generateMipmap(glTexture.target);
            }
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source2.pixelWidth, source2.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
        }
        onSourceDestroy(source2) {
          source2.off("destroy", this.onSourceDestroy, this);
          source2.off("update", this.onSourceUpdate, this);
          source2.off("unload", this.onSourceUnload, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
          this.onSourceUnload(source2);
        }
        _initSampler(style) {
          const gl = this._gl;
          const glSampler = this._gl.createSampler();
          this._glSamplers[style.resourceId] = glSampler;
          applyStyleParams(
            style,
            gl,
            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "samplerParameteri",
            glSampler
          );
          return this._glSamplers[style.resourceId];
        }
        _getGlSampler(sampler) {
          return this._glSamplers[sampler.resourceId] || this._initSampler(sampler);
        }
        getGlSource(source2) {
          return this._glTextures[source2.uid] || this._initSource(source2);
        }
        generateCanvas(texture) {
          const { pixels, width, height } = this.getPixels(texture);
          const canvas2 = settings.ADAPTER.createCanvas();
          canvas2.width = width;
          canvas2.height = height;
          const ctx2 = canvas2.getContext("2d");
          if (ctx2) {
            const imageData = ctx2.createImageData(width, height);
            imageData.data.set(pixels);
            ctx2.putImageData(imageData, 0, 0);
          }
          return canvas2;
        }
        getPixels(texture) {
          const resolution = texture.source.resolution;
          const frame = TEMP_RECT;
          frame.x = texture.frameX;
          frame.y = texture.frameY;
          frame.width = texture.frameWidth;
          frame.height = texture.frameHeight;
          const width = Math.max(Math.round(frame.width * resolution), 1);
          const height = Math.max(Math.round(frame.height * resolution), 1);
          const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
          const renderer = this._renderer;
          const renderTarget = renderer.renderTarget.getRenderTarget(texture);
          const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
          const gl = renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
          gl.readPixels(
            Math.round(frame.x * resolution),
            Math.round(frame.y * resolution),
            width,
            height,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            pixels
          );
          if (false) {
            unpremultiplyAlpha(pixels);
          }
          return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
        }
        destroy() {
          const writeable = this;
          writeable._renderer = null;
        }
      };
      GlTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/WebGLRenderer.mjs
  var WebGLRenderer_exports = {};
  __export(WebGLRenderer_exports, {
    WebGLRenderer: () => WebGLRenderer
  });
  var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
  var init_WebGLRenderer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
      init_Extensions();
      init_GlGraphicsAdaptor();
      init_GlMeshAdaptor();
      init_GlBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types();
      init_GlBufferSystem();
      init_GlContextSystem();
      init_GlGeometrySystem();
      init_GlBackBufferSystem();
      init_GlColorMaskSystem();
      init_GlEncoderSystem();
      init_GlRenderTargetSystem();
      init_GlStencilSystem();
      init_GlShaderSystem();
      init_GlUniformGroupSystem();
      init_GlStateSystem();
      init_GlTextureSystem();
      DefaultWebGLSystems = [
        ...SharedSystems,
        GlBackBufferSystem,
        GlContextSystem,
        GlBufferSystem,
        GlTextureSystem,
        GlRenderTargetSystem,
        GlGeometrySystem,
        GlUniformGroupSystem,
        GlShaderSystem,
        GlEncoderSystem,
        GlStateSystem,
        GlStencilSystem,
        GlColorMaskSystem
      ];
      DefaultWebGLPipes = [...SharedRenderPipes];
      DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
      systems2 = [];
      renderPipes2 = [];
      renderPipeAdaptors2 = [];
      extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
      extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
      extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
      extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
      WebGLRenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgl2",
            type: RendererType.WEBGL,
            systems: systems2,
            renderPipes: renderPipes2,
            renderPipeAdaptors: renderPipeAdaptors2
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/autoDetectRenderer.mjs
  async function autoDetectRenderer(options) {
    let preferredOrder = [];
    if (options.preference) {
      preferredOrder.push(options.preference);
      renderPriority.forEach((item) => {
        if (item !== options.preference) {
          preferredOrder.push(item);
        }
      });
    } else {
      preferredOrder = renderPriority.slice();
    }
    let RendererClass;
    if (options.manageImports ?? true) {
      await Promise.resolve().then(() => (init_all(), all_exports));
    }
    let finalOptions = {};
    for (let i2 = 0; i2 < preferredOrder.length; i2++) {
      const rendererType = preferredOrder[i2];
      if (rendererType === "webgpu" && await isWebGPUSupported()) {
        const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
        RendererClass = WebGPURenderer2;
        finalOptions = { ...options, ...options.webgpu };
        break;
      } else if (rendererType === "webgl" && isWebGLSupported()) {
        const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
        RendererClass = WebGLRenderer2;
        finalOptions = { ...options, ...options.webgl };
        break;
      } else if (rendererType === "canvas") {
        finalOptions = { ...options };
        break;
      }
    }
    delete finalOptions.webgpu;
    delete finalOptions.webgl;
    const renderer = new RendererClass();
    await renderer.init(finalOptions);
    return renderer;
  }
  var renderPriority;
  var init_autoDetectRenderer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/autoDetectRenderer.mjs"() {
      init_isWebGLSupported();
      init_isWebGPUSupported();
      renderPriority = ["webgpu", "webgl", "canvas"];
    }
  });

  // node_modules/pixi-v8/lib/assets/BackgroundLoader.mjs
  var BackgroundLoader;
  var init_BackgroundLoader = __esm({
    "node_modules/pixi-v8/lib/assets/BackgroundLoader.mjs"() {
      BackgroundLoader = class {
        constructor(loader, verbose = false) {
          this._loader = loader;
          this._assetList = [];
          this._isLoading = false;
          this._maxConcurrent = 1;
          this.verbose = verbose;
        }
        add(assetUrls) {
          assetUrls.forEach((a2) => {
            this._assetList.push(a2);
          });
          if (this.verbose) {
            console.log("[BackgroundLoader] assets: ", this._assetList);
          }
          if (this._isActive && !this._isLoading) {
            void this._next();
          }
        }
        async _next() {
          if (this._assetList.length && this._isActive) {
            this._isLoading = true;
            const toLoad = [];
            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
            for (let i2 = 0; i2 < toLoadAmount; i2++) {
              toLoad.push(this._assetList.pop());
            }
            await this._loader.load(toLoad);
            this._isLoading = false;
            void this._next();
          }
        }
        get active() {
          return this._isActive;
        }
        set active(value) {
          if (this._isActive === value)
            return;
          this._isActive = value;
          if (value && !this._isLoading) {
            void this._next();
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/isSingleItem.mjs
  var isSingleItem;
  var init_isSingleItem = __esm({
    "node_modules/pixi-v8/lib/assets/utils/isSingleItem.mjs"() {
      isSingleItem = (item) => !Array.isArray(item);
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/Loader.mjs
  var Loader;
  var init_Loader = __esm({
    "node_modules/pixi-v8/lib/assets/loader/Loader.mjs"() {
      init_warn();
      init_path();
      init_convertToList();
      init_isSingleItem();
      Loader = class {
        constructor() {
          this._parsers = [];
          this._parsersValidated = false;
          this.parsers = new Proxy(this._parsers, {
            set: (target, key, value) => {
              this._parsersValidated = false;
              target[key] = value;
              return true;
            }
          });
          this.promiseCache = {};
        }
        reset() {
          this._parsersValidated = false;
          this.promiseCache = {};
        }
        _getLoadPromiseAndParser(url, data) {
          const result = {
            promise: null,
            parser: null
          };
          result.promise = (async () => {
            let asset = null;
            let parser = null;
            if (data.loadParser) {
              parser = this._parserHash[data.loadParser];
              if (!parser) {
                warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
              }
            }
            if (!parser) {
              for (let i2 = 0; i2 < this.parsers.length; i2++) {
                const parserX = this.parsers[i2];
                if (parserX.load && parserX.test?.(url, data, this)) {
                  parser = parserX;
                  break;
                }
              }
              if (!parser) {
                warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
                return null;
              }
            }
            asset = await parser.load(url, data, this);
            result.parser = parser;
            for (let i2 = 0; i2 < this.parsers.length; i2++) {
              const parser2 = this.parsers[i2];
              if (parser2.parse) {
                if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
                  asset = await parser2.parse(asset, data, this) || asset;
                  result.parser = parser2;
                }
              }
            }
            return asset;
          })();
          return result;
        }
        async load(assetsToLoadIn, onProgress) {
          if (!this._parsersValidated) {
            this._validateParsers();
          }
          let count2 = 0;
          const assets = {};
          const singleAsset = isSingleItem(assetsToLoadIn);
          const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
            alias: [item],
            src: item
          }));
          const total = assetsToLoad.length;
          const promises = assetsToLoad.map(async (asset) => {
            const url = path.toAbsolute(asset.src);
            if (!assets[asset.src]) {
              try {
                if (!this.promiseCache[url]) {
                  this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
                }
                assets[asset.src] = await this.promiseCache[url].promise;
                if (onProgress)
                  onProgress(++count2 / total);
              } catch (e2) {
                delete this.promiseCache[url];
                delete assets[asset.src];
                throw new Error(`[Loader.load] Failed to load ${url}.
${e2}`);
              }
            }
          });
          await Promise.all(promises);
          return singleAsset ? assets[assetsToLoad[0].src] : assets;
        }
        async unload(assetsToUnloadIn) {
          const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
            alias: [item],
            src: item
          }));
          const promises = assetsToUnload.map(async (asset) => {
            const url = path.toAbsolute(asset.src);
            const loadPromise = this.promiseCache[url];
            if (loadPromise) {
              const loadedAsset = await loadPromise.promise;
              delete this.promiseCache[url];
              loadPromise.parser?.unload?.(loadedAsset, asset, this);
            }
          });
          await Promise.all(promises);
        }
        _validateParsers() {
          this._parsersValidated = true;
          this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
            if (!parser.name) {
              warn(`[Assets] loadParser should have a name`);
            } else if (hash[parser.name]) {
              warn(`[Assets] loadParser name conflict "${parser.name}"`);
            }
            return { ...hash, [parser.name]: parser };
          }, {});
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/createStringVariations.mjs
  function processX(base, ids, depth, result, tags) {
    const id = ids[depth];
    for (let i2 = 0; i2 < id.length; i2++) {
      const value = id[i2];
      if (depth < ids.length - 1) {
        processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
      } else {
        tags.push(base.replace(result[depth], value));
      }
    }
  }
  function createStringVariations(string) {
    const regex = /\{(.*?)\}/g;
    const result = string.match(regex);
    const tags = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split = vars.substring(1, vars.length - 1).split(",");
        ids.push(split);
      });
      processX(string, ids, 0, result, tags);
    } else {
      tags.push(string);
    }
    return tags;
  }
  var init_createStringVariations = __esm({
    "node_modules/pixi-v8/lib/assets/utils/createStringVariations.mjs"() {
    }
  });

  // node_modules/pixi-v8/lib/assets/resolver/Resolver.mjs
  var Resolver;
  var init_Resolver = __esm({
    "node_modules/pixi-v8/lib/assets/resolver/Resolver.mjs"() {
      init_warn();
      init_path();
      init_convertToList();
      init_createStringVariations();
      init_isSingleItem();
      Resolver = class {
        constructor() {
          this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
            extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
          };
          this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
          this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
          this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
          this._assetMap = {};
          this._preferredOrder = [];
          this._parsers = [];
          this._resolverHash = {};
          this._bundles = {};
        }
        setBundleIdentifier(bundleIdentifier) {
          this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
          this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
          this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
          if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
          }
        }
        prefer(...preferOrders) {
          preferOrders.forEach((prefer) => {
            this._preferredOrder.push(prefer);
            if (!prefer.priority) {
              prefer.priority = Object.keys(prefer.params);
            }
          });
          this._resolverHash = {};
        }
        set basePath(basePath) {
          this._basePath = basePath;
        }
        get basePath() {
          return this._basePath;
        }
        set rootPath(rootPath) {
          this._rootPath = rootPath;
        }
        get rootPath() {
          return this._rootPath;
        }
        get parsers() {
          return this._parsers;
        }
        reset() {
          this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
          this._assetMap = {};
          this._preferredOrder = [];
          this._resolverHash = {};
          this._rootPath = null;
          this._basePath = null;
          this._manifest = null;
          this._bundles = {};
          this._defaultSearchParams = null;
        }
        setDefaultSearchParams(searchParams) {
          if (typeof searchParams === "string") {
            this._defaultSearchParams = searchParams;
          } else {
            const queryValues = searchParams;
            this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
          }
        }
        getAlias(asset) {
          const { alias, name, src, srcs } = asset;
          const aliasesToUse = convertToList(
            alias || name || src || srcs,
            (value) => {
              if (typeof value === "string")
                return value;
              if (Array.isArray(value))
                return value.map((v2) => v2?.src ?? v2?.srcs ?? v2);
              if (value?.src || value?.srcs)
                return value.src ?? value.srcs;
              return value;
            },
            true
          );
          return aliasesToUse;
        }
        addManifest(manifest) {
          if (this._manifest) {
            warn("[Resolver] Manifest already exists, this will be overwritten");
          }
          this._manifest = manifest;
          manifest.bundles.forEach((bundle) => {
            this.addBundle(bundle.name, bundle.assets);
          });
        }
        addBundle(bundleId, assets) {
          const assetNames = [];
          if (Array.isArray(assets)) {
            assets.forEach((asset) => {
              const srcs = asset.src ?? asset.srcs;
              const aliases = asset.alias ?? asset.name;
              let ids;
              if (typeof aliases === "string") {
                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
                assetNames.push(bundleAssetId);
                ids = [aliases, bundleAssetId];
              } else {
                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
                assetNames.push(...bundleIds);
                ids = [...aliases, ...bundleIds];
              }
              this.add({
                ...asset,
                ...{
                  alias: ids,
                  src: srcs
                }
              });
            });
          } else {
            Object.keys(assets).forEach((key) => {
              const aliases = [key, this._createBundleAssetId(bundleId, key)];
              if (typeof assets[key] === "string") {
                this.add({
                  alias: aliases,
                  src: assets[key]
                });
              } else if (Array.isArray(assets[key])) {
                this.add({
                  alias: aliases,
                  src: assets[key]
                });
              } else {
                const asset = assets[key];
                const assetSrc = asset.src ?? asset.srcs;
                this.add({
                  ...asset,
                  ...{
                    alias: aliases,
                    src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]
                  }
                });
              }
              assetNames.push(...aliases);
            });
          }
          this._bundles[bundleId] = assetNames;
        }
        add(aliases) {
          const assets = [];
          if (Array.isArray(aliases)) {
            assets.push(...aliases);
          } else {
            assets.push(aliases);
          }
          let keyCheck;
          keyCheck = (key) => {
            if (this.hasKey(key)) {
              warn(`[Resolver] already has key: ${key} overwriting`);
            }
          };
          const assetArray = convertToList(assets);
          assetArray.forEach((asset) => {
            const { src, srcs } = asset;
            let { data, format, loadParser } = asset;
            const srcsToUse = convertToList(src || srcs).map((src2) => {
              if (typeof src2 === "string") {
                return createStringVariations(src2);
              }
              return Array.isArray(src2) ? src2 : [src2];
            });
            const aliasesToUse = this.getAlias(asset);
            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
            const resolvedAssets = [];
            srcsToUse.forEach((srcs2) => {
              srcs2.forEach((src2) => {
                let formattedAsset = {};
                if (typeof src2 !== "object") {
                  formattedAsset.src = src2;
                  for (let i2 = 0; i2 < this._parsers.length; i2++) {
                    const parser = this._parsers[i2];
                    if (parser.test(src2)) {
                      formattedAsset = parser.parse(src2);
                      break;
                    }
                  }
                } else {
                  data = src2.data ?? data;
                  format = src2.format ?? format;
                  loadParser = src2.loadParser ?? loadParser;
                  formattedAsset = {
                    ...formattedAsset,
                    ...src2
                  };
                }
                if (!aliasesToUse) {
                  throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
                }
                formattedAsset = this._buildResolvedAsset(formattedAsset, {
                  aliases: aliasesToUse,
                  data,
                  format,
                  loadParser
                });
                resolvedAssets.push(formattedAsset);
              });
            });
            aliasesToUse.forEach((alias) => {
              this._assetMap[alias] = resolvedAssets;
            });
          });
        }
        resolveBundle(bundleIds) {
          const singleAsset = isSingleItem(bundleIds);
          bundleIds = convertToList(bundleIds);
          const out2 = {};
          bundleIds.forEach((bundleId) => {
            const assetNames = this._bundles[bundleId];
            if (assetNames) {
              const results = this.resolve(assetNames);
              const assets = {};
              for (const key in results) {
                const asset = results[key];
                assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
              }
              out2[bundleId] = assets;
            }
          });
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        resolveUrl(key) {
          const result = this.resolve(key);
          if (typeof key !== "string") {
            const out2 = {};
            for (const i2 in result) {
              out2[i2] = result[i2].src;
            }
            return out2;
          }
          return result.src;
        }
        resolve(keys) {
          const singleAsset = isSingleItem(keys);
          keys = convertToList(keys);
          const result = {};
          keys.forEach((key) => {
            if (!this._resolverHash[key]) {
              if (this._assetMap[key]) {
                let assets = this._assetMap[key];
                const bestAsset = assets[0];
                const preferredOrder = this._getPreferredOrder(assets);
                preferredOrder?.priority.forEach((priorityKey) => {
                  preferredOrder.params[priorityKey].forEach((value) => {
                    const filteredAssets = assets.filter((asset) => {
                      if (asset[priorityKey]) {
                        return asset[priorityKey] === value;
                      }
                      return false;
                    });
                    if (filteredAssets.length) {
                      assets = filteredAssets;
                    }
                  });
                });
                this._resolverHash[key] = assets[0] ?? bestAsset;
              } else {
                this._resolverHash[key] = this._buildResolvedAsset({
                  alias: [key],
                  src: key
                }, {});
              }
            }
            result[key] = this._resolverHash[key];
          });
          return singleAsset ? result[keys[0]] : result;
        }
        hasKey(key) {
          return !!this._assetMap[key];
        }
        hasBundle(key) {
          return !!this._bundles[key];
        }
        _getPreferredOrder(assets) {
          for (let i2 = 0; i2 < assets.length; i2++) {
            const asset = assets[0];
            const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
            if (preferred) {
              return preferred;
            }
          }
          return this._preferredOrder[0];
        }
        _appendDefaultSearchParams(url) {
          if (!this._defaultSearchParams)
            return url;
          const paramConnector = /\?/.test(url) ? "&" : "?";
          return `${url}${paramConnector}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(formattedAsset, data) {
          const { aliases, data: assetData, loadParser, format } = data;
          if (this._basePath || this._rootPath) {
            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
          }
          formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
          formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
          formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
          formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
          formattedAsset.format = format ?? formattedAsset.src.split(".").pop();
          formattedAsset.srcs = formattedAsset.src;
          formattedAsset.name = formattedAsset.alias;
          return formattedAsset;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/Assets.mjs
  var AssetsClass, Assets;
  var init_Assets = __esm({
    "node_modules/pixi-v8/lib/assets/Assets.mjs"() {
      init_Extensions();
      init_warn();
      init_BackgroundLoader();
      init_Cache();
      init_Loader();
      init_Resolver();
      init_convertToList();
      init_isSingleItem();
      AssetsClass = class {
        constructor() {
          this._detections = [];
          this._initialized = false;
          this.resolver = new Resolver();
          this.loader = new Loader();
          this.cache = Cache;
          this._backgroundLoader = new BackgroundLoader(this.loader);
          this._backgroundLoader.active = true;
          this.reset();
        }
        async init(options = {}) {
          if (this._initialized) {
            warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
            return;
          }
          this._initialized = true;
          if (options.defaultSearchParams) {
            this.resolver.setDefaultSearchParams(options.defaultSearchParams);
          }
          if (options.basePath) {
            this.resolver.basePath = options.basePath;
          }
          if (options.bundleIdentifier) {
            this.resolver.setBundleIdentifier(options.bundleIdentifier);
          }
          if (options.manifest) {
            let manifest = options.manifest;
            if (typeof manifest === "string") {
              manifest = await this.load(manifest);
            }
            this.resolver.addManifest(manifest);
          }
          const resolutionPref = options.texturePreference?.resolution ?? 1;
          const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
          const formats = await this._detectFormats({
            preferredFormats: options.texturePreference?.format,
            skipDetections: options.skipDetections,
            detections: this._detections
          });
          this.resolver.prefer({
            params: {
              format: formats,
              resolution
            }
          });
          if (options.preferences) {
            this.setPreferences(options.preferences);
          }
        }
        add(assets) {
          this.resolver.add(assets);
        }
        async load(urls, onProgress) {
          if (!this._initialized) {
            await this.init();
          }
          const singleAsset = isSingleItem(urls);
          const urlArray = convertToList(urls).map((url) => {
            if (typeof url !== "string") {
              const aliases = this.resolver.getAlias(url);
              if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
                this.add(url);
              }
              return Array.isArray(aliases) ? aliases[0] : aliases;
            }
            if (!this.resolver.hasKey(url))
              this.add({ alias: url, src: url });
            return url;
          });
          const resolveResults = this.resolver.resolve(urlArray);
          const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
          return singleAsset ? out2[urlArray[0]] : out2;
        }
        addBundle(bundleId, assets) {
          this.resolver.addBundle(bundleId, assets);
        }
        async loadBundle(bundleIds, onProgress) {
          if (!this._initialized) {
            await this.init();
          }
          let singleAsset = false;
          if (typeof bundleIds === "string") {
            singleAsset = true;
            bundleIds = [bundleIds];
          }
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          const out2 = {};
          const keys = Object.keys(resolveResults);
          let count2 = 0;
          let total = 0;
          const _onProgress = () => {
            onProgress?.(++count2 / total);
          };
          const promises = keys.map((bundleId) => {
            const resolveResult = resolveResults[bundleId];
            total += Object.keys(resolveResult).length;
            return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
              out2[bundleId] = resolveResult2;
            });
          });
          await Promise.all(promises);
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        async backgroundLoad(urls) {
          if (!this._initialized) {
            await this.init();
          }
          if (typeof urls === "string") {
            urls = [urls];
          }
          const resolveResults = this.resolver.resolve(urls);
          this._backgroundLoader.add(Object.values(resolveResults));
        }
        async backgroundLoadBundle(bundleIds) {
          if (!this._initialized) {
            await this.init();
          }
          if (typeof bundleIds === "string") {
            bundleIds = [bundleIds];
          }
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          Object.values(resolveResults).forEach((resolveResult) => {
            this._backgroundLoader.add(Object.values(resolveResult));
          });
        }
        reset() {
          this.resolver.reset();
          this.loader.reset();
          this.cache.reset();
          this._initialized = false;
        }
        get(keys) {
          if (typeof keys === "string") {
            return Cache.get(keys);
          }
          const assets = {};
          for (let i2 = 0; i2 < keys.length; i2++) {
            assets[i2] = Cache.get(keys[i2]);
          }
          return assets;
        }
        async _mapLoadToResolve(resolveResults, onProgress) {
          const resolveArray = Object.values(resolveResults);
          const resolveKeys = Object.keys(resolveResults);
          this._backgroundLoader.active = false;
          const loadedAssets = await this.loader.load(resolveArray, onProgress);
          this._backgroundLoader.active = true;
          const out2 = {};
          resolveArray.forEach((resolveResult, i2) => {
            const asset = loadedAssets[resolveResult.src];
            const keys = [resolveResult.src];
            if (resolveResult.alias) {
              keys.push(...resolveResult.alias);
            }
            out2[resolveKeys[i2]] = asset;
            Cache.set(keys, asset);
          });
          return out2;
        }
        async unload(urls) {
          if (!this._initialized) {
            await this.init();
          }
          const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
          const resolveResults = this.resolver.resolve(urlArray);
          await this._unloadFromResolved(resolveResults);
        }
        async unloadBundle(bundleIds) {
          if (!this._initialized) {
            await this.init();
          }
          bundleIds = convertToList(bundleIds);
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
          await Promise.all(promises);
        }
        async _unloadFromResolved(resolveResult) {
          const resolveArray = Object.values(resolveResult);
          resolveArray.forEach((resolveResult2) => {
            Cache.remove(resolveResult2.src);
          });
          await this.loader.unload(resolveArray);
        }
        async _detectFormats(options) {
          let formats = [];
          if (options.preferredFormats) {
            formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
          }
          for (const detection of options.detections) {
            if (options.skipDetections || await detection.test()) {
              formats = await detection.add(formats);
            } else if (!options.skipDetections) {
              formats = await detection.remove(formats);
            }
          }
          formats = formats.filter((format, index) => formats.indexOf(format) === index);
          return formats;
        }
        get detections() {
          return this._detections;
        }
        setPreferences(preferences) {
          this.loader.parsers.forEach((parser) => {
            if (!parser.config)
              return;
            Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
              parser.config[key] = preferences[key];
            });
          });
        }
      };
      Assets = new AssetsClass();
      extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/utils/textStyleToCSS.mjs
  function textStyleToCSS(style) {
    const stroke = style._stroke;
    const fill = style._fill;
    return [
      `transform-origin: top left`,
      "display: inline-block",
      `color: ${Color.shared.setValue(fill.color).toHex()}`,
      `font-size: ${style.fontSize}px`,
      `font-family: ${style.fontFamily}`,
      `font-weight: ${style.fontWeight}`,
      `font-style: ${style.fontStyle}`,
      `font-variant: ${style.fontVariant}`,
      `letter-spacing: ${style.letterSpacing}px`,
      `text-align: ${style.align}`,
      `padding: ${style.padding}px`,
      `white-space: ${style.whiteSpace}`,
      ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
      ...style.wordWrap ? [
        `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${style.wordWrapWidth}px`
      ] : [],
      ...stroke ? [
        `-webkit-text-stroke-width: ${stroke.width}px`,
        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
        `text-stroke-width: ${stroke.width}px`,
        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
        "paint-order: stroke"
      ] : [],
      ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
      ...style.cssOverrides
    ].join(";");
  }
  function dropShadowToCSS(dropShadowStyle) {
    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
    const x2 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
    const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
    const position = `${x2}px ${y2}px`;
    if (dropShadowStyle.blur > 0) {
      return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  var init_textStyleToCSS = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/utils/textStyleToCSS.mjs"() {
      init_Color();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/html/HtmlTextStyle.mjs
  var HTMLTextStyle;
  var init_HtmlTextStyle = __esm({
    "node_modules/pixi-v8/lib/scene/text/html/HtmlTextStyle.mjs"() {
      init_warn();
      init_TextStyle();
      init_generateTextStyleKey();
      init_textStyleToCSS();
      HTMLTextStyle = class extends TextStyle {
        constructor(options) {
          super(options);
          this._cssOverrides = [];
          this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
        }
        set cssOverrides(value) {
          this._cssOverrides = value instanceof Array ? value : [value];
          this.update();
        }
        get cssOverrides() {
          return this._cssOverrides;
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
          return this._styleKey;
        }
        update() {
          this._cssStyle = null;
          super.update();
        }
        clone() {
          return new HTMLTextStyle({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides
          });
        }
        get cssStyle() {
          if (!this._cssStyle) {
            this._cssStyle = textStyleToCSS(this);
          }
          return this._cssStyle;
        }
        addOverride(...value) {
          const toAdd = value.filter((v2) => !this.cssOverrides.includes(v2));
          if (toAdd.length > 0) {
            this.cssOverrides.push(...toAdd);
            this.update();
          }
        }
        removeOverride(...value) {
          const toRemove = value.filter((v2) => this.cssOverrides.includes(v2));
          if (toRemove.length > 0) {
            this.cssOverrides = this.cssOverrides.filter((v2) => !toRemove.includes(v2));
            this.update();
          }
        }
        set fill(value) {
          if (typeof value !== "string" && typeof value !== "number") {
            warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
          }
          super.fill = value;
        }
        set stroke(value) {
          if (value && typeof value !== "string" && typeof value !== "number") {
            warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
          }
          super.stroke = value;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/utils/ensureTextStyle.mjs
  function ensureTextStyle(renderMode, style) {
    if (style instanceof TextStyle || style instanceof HTMLTextStyle) {
      return style;
    }
    return renderMode === "html" ? new HTMLTextStyle(style) : new TextStyle(style);
  }
  var init_ensureTextStyle = __esm({
    "node_modules/pixi-v8/lib/scene/text/utils/ensureTextStyle.mjs"() {
      init_HtmlTextStyle();
      init_TextStyle();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/TextView.mjs
  var map, TextView;
  var init_TextView = __esm({
    "node_modules/pixi-v8/lib/scene/text/TextView.mjs"() {
      init_Cache();
      init_ObservablePoint();
      init_View();
      init_uid();
      init_BitmapFont();
      init_BitmapFontManager();
      init_DynamicBitmapFont();
      init_CanvasTextMetrics();
      init_HtmlTextStyle();
      init_measureHtmlText();
      init_ensureTextStyle();
      map = {
        canvas: "text",
        html: "htmlText",
        bitmap: "bitmapText"
      };
      TextView = class {
        constructor(options) {
          this.uid = uid("textView");
          this.renderPipeId = "text";
          this.owner = emptyViewObserver;
          this.batched = true;
          this.resolution = null;
          this._didUpdate = true;
          this.roundPixels = 0;
          this._bounds = [0, 1, 0, 0];
          this._boundsDirty = true;
          this.text = options.text ?? "";
          const renderMode = options.renderMode ?? this._detectRenderType(options.style);
          this._renderMode = renderMode;
          this._style = ensureTextStyle(renderMode, options.style);
          this.renderPipeId = map[renderMode];
          this.anchor = new ObservablePoint(this, 0, 0);
          this.resolution = options.resolution ?? null;
        }
        set text(value) {
          value = value.toString();
          if (this._text === value)
            return;
          this._text = value;
          this.onUpdate();
        }
        get text() {
          return this._text;
        }
        get style() {
          return this._style;
        }
        set style(style) {
          style = style || {};
          this._style?.off("update", this.onUpdate, this);
          this._style = ensureTextStyle(this._renderMode, style);
          this._style.on("update", this.onUpdate, this);
          this.onUpdate();
        }
        get bounds() {
          if (this._boundsDirty) {
            this._updateBounds();
            this._boundsDirty = false;
          }
          return this._bounds;
        }
        addBounds(bounds) {
          const _bounds = this.bounds;
          bounds.addFrame(
            _bounds[0],
            _bounds[2],
            _bounds[1],
            _bounds[3]
          );
        }
        containsPoint(point) {
          const width = this.bounds[2];
          const height = this.bounds[3];
          const x1 = -width * this.anchor.x;
          let y1 = 0;
          if (point.x >= x1 && point.x < x1 + width) {
            y1 = -height * this.anchor.y;
            if (point.y >= y1 && point.y < y1 + height)
              return true;
          }
          return false;
        }
        onUpdate() {
          this._didUpdate = true;
          this._boundsDirty = true;
          this.owner.onViewUpdate();
        }
        _getKey() {
          return `${this.text}:${this._style.styleKey}`;
        }
        _updateBounds() {
          const bounds = this._bounds;
          const padding = this._style.padding;
          const anchor = this.anchor;
          if (this.renderPipeId === "bitmapText") {
            const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);
            const scale = bitmapMeasurement.scale;
            const offset = bitmapMeasurement.offsetY * scale;
            const width = bitmapMeasurement.width * scale;
            const height = bitmapMeasurement.height * scale;
            bounds[0] = -anchor._x * width - padding;
            bounds[1] = bounds[0] + width;
            bounds[2] = -anchor._y * (height + offset) - padding;
            bounds[3] = bounds[2] + height;
          } else if (this.renderPipeId === "htmlText") {
            const htmlMeasurement = measureHtmlText(this.text, this._style);
            const { width, height } = htmlMeasurement;
            bounds[0] = -anchor._x * width - padding;
            bounds[1] = bounds[0] + width;
            bounds[2] = -anchor._y * height - padding;
            bounds[3] = bounds[2] + height;
          } else {
            const canvasMeasurement = CanvasTextMetrics.measureText(this.text, this._style);
            const { width, height } = canvasMeasurement;
            bounds[0] = -anchor._x * width - padding;
            bounds[1] = bounds[0] + width;
            bounds[2] = -anchor._y * height - padding;
            bounds[3] = bounds[2] + height;
          }
        }
        _detectRenderType(style) {
          if (style instanceof HTMLTextStyle) {
            return "html";
          }
          const fontData = Cache.get(style?.fontFamily);
          if (fontData instanceof DynamicBitmapFont || fontData instanceof BitmapFont) {
            return "bitmap";
          }
          return "canvas";
        }
        destroy(options = false) {
          this.owner = null;
          this._bounds = null;
          this.anchor = null;
          this._style.destroy(options);
          this._style = null;
          this._text = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/Text.mjs
  var Text;
  var init_Text = __esm({
    "node_modules/pixi-v8/lib/scene/text/Text.mjs"() {
      init_deprecation();
      init_Container();
      init_definedProps();
      init_TextView();
      Text = class extends Container {
        constructor(...args) {
          let options = args[0];
          if (typeof options === "string" || args[1]) {
            deprecation(v8_0_0, 'use new Text({ text: "hi!", style }) instead');
            options = {
              text: options,
              style: args[1]
            };
          }
          const { style, text, renderMode, resolution, ...rest } = options;
          super({
            view: new TextView(definedProps({ style, text, renderMode, resolution })),
            label: "Text",
            ...rest
          });
          this.allowChildren = false;
        }
        get anchor() {
          return this.view.anchor;
        }
        set anchor(value) {
          this.view.anchor.x = value.x;
          this.view.anchor.y = value.y;
        }
        set text(value) {
          this.view.text = value;
        }
        get text() {
          return this.view.text;
        }
        set style(value) {
          this.view.style = value;
        }
        get style() {
          return this.view.style;
        }
        get roundPixels() {
          return !!this.view.roundPixels;
        }
        set roundPixels(value) {
          this.view.roundPixels = value ? 1 : 0;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/index.mjs
  var import_earcut2;
  var init_lib = __esm({
    "node_modules/pixi-v8/lib/index.mjs"() {
      init_init();
      init_all();
      init_init2();
      init_Assets();
      init_init3();
      init_EventSystem();
      init_init4();
      init_Rectangle();
      init_init6();
      init_autoDetectRenderer();
      init_TextureStyle();
      init_Container();
      init_Sprite();
      init_Text();
      init_init5();
      init_eventemitter3();
      import_earcut2 = __toESM(require_earcut(), 1);
    }
  });

  // src/bunny.ts
  var BunnyV8;
  var init_bunny = __esm({
    "src/bunny.ts"() {
      init_lib();
      BunnyV8 = class {
        constructor(texture, bounds) {
          this.gravity = 0.75;
          this.speedX = Math.random() * 10;
          this.speedY = Math.random() * 10 - 5;
          this.positionX = 0;
          this.positionY = 0;
          this.view = new Sprite(texture);
          this.view.anchor.set(0.5, 1);
          this.bounds = bounds;
        }
        update() {
          let pX = this.positionX;
          let pY = this.positionY;
          pX += this.speedX;
          pY += this.speedY;
          this.speedY += this.gravity;
          if (pX > this.bounds.right) {
            this.speedX *= -1;
            pX = this.bounds.right;
          } else if (pX < this.bounds.left) {
            this.speedX *= -1;
            pX = this.bounds.left;
          }
          if (pY > this.bounds.bottom) {
            this.speedY *= -0.85;
            pY = this.bounds.bottom;
            if (Math.random() > 0.5) {
              this.speedY -= Math.random() * 6;
            }
          } else if (pY < this.bounds.top) {
            this.speedY = 0;
            pY = this.bounds.top;
          }
          this.view.position.x = this.positionX = pX;
          this.view.position.y = this.positionY = pY;
        }
        reset() {
          this.positionX = 0;
          this.positionY = 0;
        }
      };
    }
  });

  // src/jamboree.ts
  var jamboree_exports = {};
  __export(jamboree_exports, {
    jamboRee: () => jamboRee,
    jamboReeUnallocated: () => jamboReeUnallocated
  });
  async function jamboRee({ preference }) {
    const renderer = await autoDetectRenderer({
      preference,
      clearBeforeRender: true,
      backgroundAlpha: 1,
      backgroundColor: 16777215,
      width: 800,
      height: 600,
      resolution: 1,
      antialias: false,
      hello: true
    });
    document.body.appendChild(renderer.view.canvas);
    let initialSize = 1e6;
    const stage = new Container();
    stage.children.length = initialSize;
    const textures = Object.values(await Assets.load([
      "./assets/bunnies/rabbitv3_ash.png",
      "./assets/bunnies/rabbitv3_batman.png",
      "./assets/bunnies/rabbitv3_bb8.png",
      "./assets/bunnies/rabbitv3_frankenstein.png",
      "./assets/bunnies/rabbitv3_neo.png",
      "./assets/bunnies/rabbitv3_sonic.png",
      "./assets/bunnies/rabbitv3_spidey.png",
      "./assets/bunnies/rabbitv3_stormtrooper.png",
      "./assets/bunnies/rabbitv3_superman.png",
      "./assets/bunnies/rabbitv3_tron.png",
      "./assets/bunnies/rabbitv3_wolverine.png",
      "./assets/bunnies/rabbitv3.png"
    ]));
    const bounds = new Rectangle(0, 0, 800, 600);
    const bunnies = new Array(initialSize);
    let bunnyIndex = 0;
    const basicText = new Text("Basic text in pixi");
    basicText.x = 50;
    basicText.y = 100;
    stage.addChild(basicText);
    setInterval(function() {
      basicText.text = bunnyIndex + " vs" + bunnies.length;
    }, 1e3);
    function addBunny() {
      const bunny = bunnyPool.pop() || new BunnyV8(textures[bunnyIndex % textures.length], bounds);
      bunnyIndex++;
      bunny.reset();
      stage.addChild(bunny.view);
      bunnies[bunnyIndex] = bunny;
    }
    function loadWatcher() {
      requestAnimationFrame(() => {
        let t2 = Date.now();
        let fps = Math.round(1e3 / (Date.now() - t2));
        let addHackathonist = true;
        if (fps < 60) {
          console.log("fps danger zone");
          addHackathonist = true;
        }
        if (fps < 24) {
          console.log("fps lag detected");
          addHackathonist = false;
        }
        if (addHackathonist) {
          addBunny();
        }
        loadWatcher();
      });
    }
    loadWatcher();
    let pause = false;
    renderer.view.canvas.addEventListener("mousedown", () => {
      pause = !pause;
    });
    function renderUpdate() {
      if (!pause) {
        for (let i2 = 0; i2 < bunnies.length; i2++) {
          if (!bunnies[i2]) {
            continue;
          }
          bunnies[i2].update();
        }
      }
      renderer.render(stage);
      requestAnimationFrame(renderUpdate);
    }
    renderUpdate();
  }
  async function jamboReeUnallocated({ preference }) {
    const renderer = await autoDetectRenderer({
      preference,
      clearBeforeRender: true,
      backgroundAlpha: 1,
      backgroundColor: 16777215,
      width: 800,
      height: 600,
      resolution: 1,
      antialias: false,
      hello: true
    });
    document.body.appendChild(renderer.view.canvas);
    const stage = new Container();
    const textures = Object.values(await Assets.load([
      "./assets/bunnies/rabbitv3_ash.png",
      "./assets/bunnies/rabbitv3_batman.png",
      "./assets/bunnies/rabbitv3_bb8.png",
      "./assets/bunnies/rabbitv3_frankenstein.png",
      "./assets/bunnies/rabbitv3_neo.png",
      "./assets/bunnies/rabbitv3_sonic.png",
      "./assets/bunnies/rabbitv3_spidey.png",
      "./assets/bunnies/rabbitv3_stormtrooper.png",
      "./assets/bunnies/rabbitv3_superman.png",
      "./assets/bunnies/rabbitv3_tron.png",
      "./assets/bunnies/rabbitv3_wolverine.png",
      "./assets/bunnies/rabbitv3.png"
    ]));
    const bounds = new Rectangle(0, 0, 800, 600);
    const bunnies = [];
    const basicText = new Text("Basic text in pixi");
    basicText.x = 50;
    basicText.y = 100;
    stage.addChild(basicText);
    setInterval(function() {
      basicText.text = "There are total " + bunnies.length;
    }, 1e3);
    function addBunny() {
      const bunny = bunnyPool.pop() || new BunnyV8(textures[bunnies.length % textures.length], bounds);
      bunny.reset();
      stage.addChild(bunny.view);
      bunnies.push(bunny);
    }
    function loadWatcher() {
      requestAnimationFrame(() => {
        let t2 = Date.now();
        let fps = Math.round(1e3 / (Date.now() - t2));
        let addHackathonist = true;
        if (fps < 60) {
          console.log("fps danger zone");
          addHackathonist = true;
        }
        if (fps < 24) {
          console.log("fps lag detected");
          addHackathonist = false;
        }
        if (addHackathonist) {
          addBunny();
        }
        loadWatcher();
      });
    }
    loadWatcher();
    let pause = false;
    renderer.view.canvas.addEventListener("mousedown", () => {
      pause = !pause;
    });
    function renderUpdate() {
      if (!pause) {
        for (let i2 = 0; i2 < bunnies.length; i2++) {
          if (!bunnies[i2]) {
            continue;
          }
          bunnies[i2].update();
        }
      }
      renderer.render(stage);
      requestAnimationFrame(renderUpdate);
    }
    renderUpdate();
  }
  var bunnyPool;
  var init_jamboree = __esm({
    "src/jamboree.ts"() {
      init_lib();
      init_bunny();
      TextureStyle.defaultOptions.scaleMode = "nearest";
      EventSystem.defaultEventFeatures.move = false;
      EventSystem.defaultEventFeatures.globalMove = false;
      bunnyPool = [];
    }
  });

  // src/index.ts
  async function init2() {
    const { jamboRee: jamboRee2, jamboReeUnallocated: jamboReeUnallocated2 } = await Promise.resolve().then(() => (init_jamboree(), jamboree_exports));
    jamboReeUnallocated2({ preference: "webgpu" });
  }
  init2();
})();
